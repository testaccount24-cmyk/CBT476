
;***********************************************************************
;*                                                                     *
;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
;*         All rights reserved.                                        *
;*                                                                     *
;***********************************************************************

;
; Bug fix 12/21/90 - CHARPOS should not be incremented when TYI calls
;                    the stream-input-function and gets back NIL.
;                    This was causing READ-FROM-STRING to return an
;                    incorrect second value.

; ZCREXEC is the function called by the "default ZIL reader", ZDREAD,
; when the file argument is not a symbol.  The file argument is assumed
; to be a stream (which is why we call it "stream" in this code).
;
; ZCREXEC, like ZDREAD, takes six required arguments:
;
;  arg 1 = the stream to perform input operations on.
;  arg 2 = a fixnum built from the boolean values listed below.
;  arg 3 = miscellaneous function-dependent data (e.g. char operand).
;  arg 4 = eof-error-p.
;  arg 5 = eofval.
;  arg 6 = recursive-p.
;
; Arg 2 values are made up from the following bit settings:
;
; 00000000  =  Read an S-expression (READ)
; .....001  =  Read a character (TYI)
; .....010  =  Unread a character (UNTYI)
; .....011  =  Peek a character (TYIPEEK)
; .....100  =  Intern a character (READCH)
; .....110  =  Intern a character (PEEKCH)
; ....1...  =  EOF request
; ...1....  =  EOL (newline) request
; ..1.....  =  1 = set EOF/EOL, 0 = test EOF/EOL
; .1......  =  Read a line of data (READLINE)
; 1.......  =  Readtable functions
; 1......1  =  Set reader macro
; 1.....1.  =  Set MACLISP readtable
; 1....1..  =  Return reader macro character
;

;=======================================================================

(include #.(zil-source-member zcsdfstr))  ; Stream type defstruct.

;=======================================================================

(defmacro read-char (&optional stream eoferp eofval recursive-p)
;(tyi stream eoferp eofval nil))
 `(zcread ,stream #.%%tyi nil ,eoferp ,eofval #.eol))

(defmacro peek-char (&optional arg stream eoferp eofval recursive-p)
;(tyipeek arg stream eoferp eofval nil))
 `(zcread ,stream #.%%tyipeek ,arg ,eoferp ,eofval #.eol))

(defmacro unread-char (arg &optional stream eofval)
;(untyi arg stream eoferp eofval nil))
 `(zcread ,stream #.%%untyi ,arg nil #.eof #.eol))

(defmacro zcrread-character-macro-function (char)
 `(vref (readtable-character-macro-table *readtable*) ,char))

(defmacro zcrread-dispatch-macro-function (char)
 `(vref (readtable-dispatch-macro-table *readtable*) ,char))

(defmacro the-character (i)
 `(vref (readvector-characters readvector) ,i))
(defmacro the-syntax    (i)
 `(vref (readvector-syntaxes   readvector) ,i))
(defmacro the-attribute (i)
 `(vref (readvector-attributes readvector) ,i))

(defargs mxbq 1 1 nil)

;=======================================================================

(defun zcrexec (stream bits misc eoferp eofval recurp)
 (cond
  (;(streamp stream)
   (and (structp stream) (eq (vref stream 0) 'stream))
   (case bits
    (#.%%tyi      (zcrexec-tyi      stream misc eoferp eofval recurp))
    (#.%%untyi    (zcrexec-untyi    stream misc eoferp eofval recurp))
    (#.%%tyipeek  (zcrexec-tyipeek  stream misc eoferp eofval recurp))
    (#.%%read     (zcrexec-read     (zcrexec-prepare-stream stream t)
                                    misc eoferp eofval recurp))
    (#.%%readline (zcrexec-readline (zcrexec-prepare-stream stream t)
                                    misc eoferp eofval recurp))
    (#.%%charpos  (zcrexec-charpos  stream misc eoferp eofval recurp))
    (#.%%readch   (zcrexec-readch   stream misc eoferp eofval recurp))
    (#.%%peekch   (zcrexec-peekch   stream misc eoferp eofval recurp))
    (#.%%eof      (zcrexec-eof      stream misc eoferp eofval recurp))
    (#.%%quit     (zcrexec-quit     stream misc eoferp eofval recurp))
    (#.%%newlinep (zcrexec-newlinep stream misc eoferp eofval recurp))
    (#.%%endread  (zcrexec-endread  stream misc eoferp eofval recurp))
    (#.%%rminit   (zcrexec-rminit   stream misc eoferp eofval recurp))
    (#.%%rdrmacro (zcrexec-rdrmacro stream misc eoferp eofval recurp))
    (#.%%rmmac    (zcrexec-rmmac    stream misc eoferp eofval recurp))
    (#.%%rmchar   (zcrexec-rmchar   stream misc eoferp eofval recurp))
    (#.%%read-delimited-list
                  (zcrexec-readdl   (zcrexec-prepare-stream stream t)
                                    misc eoferp eofval recurp))
    (t
     (zcrexec-error stream (zcrexec-bits-operation bits)
                           "Unknown operation passed to ZCREXEC"
                           (zcrexec-bits-operation bits)))))
  ((symbolp stream)
   (case bits
    (#.%%read     (zcrexec-read     (zcrexec-prepare-stream stream t)
                                    misc eoferp eofval recurp))
    (#.%%readline (zcrexec-readline (zcrexec-prepare-stream stream t)
                                    misc eoferp eofval recurp))
;;;;(#.%%tyipeek  (zcrexec-tyipeek  (zcrexec-prepare-stream stream nil)
;;;;                                misc eoferp eofval recurp))
    (#.%%tyipeek  (zcrexec-tyipeek  stream
                                    misc eoferp eofval recurp))
    (#.%%rminit   (zcrexec-rminit   stream misc eoferp eofval recurp))
    (#.%%rdrmacro (zcrexec-rdrmacro stream misc eoferp eofval recurp))
    (#.%%rmmac    (zcrexec-rmmac    stream misc eoferp eofval recurp))
    (#.%%rmchar   (zcrexec-rmchar   stream misc eoferp eofval recurp))
    (#.%%read-delimited-list
                  (zcrexec-readdl   (zcrexec-prepare-stream stream t)
                                    misc eoferp eofval recurp))
    (t
     (zerror `("Unsupported ZCREXEC operation for input file "
               ,(prin1-to-string stream))
             (zcrexec-bits-operation bits)))))
  (t
   (zerror `("Invalid input file argument to "
             ,(zcrexec-bits-operation bits)
             " (not symbol or stream)")
           (prin1-to-string stream)))))

(defun zcrexec-bits-operation (bits)
 (case bits
       (#.%%read     "READ"       )
       (#.%%tyi      "TYI"        )
       (#.%%untyi    "UNTYI"      )
       (#.%%tyipeek  "TYIPEEK"    )
       (#.%%readch   "READCH"     )
       (#.%%peekch   "PEEKCH"     )
       (#.%%eof      "EOF"        )
       (#.%%quit     "QUIT"       )
       (#.%%newlinep "NEWLINEP"   )
       (#.%%endread  "ENDREAD"    )
       (#.%%readline "READLINE"   )
       (#.%%rminit   "RMINIT"     )
       (#.%%rdrmacro "RDRMACRO"   )
       (#.%%rmmac    "RMMAC"      )
       (#.%%rmchar   "RMCHAR"     )
       (#.%%charpos  "CHARPOS"    )
       (#.%%read-delimited-list "READ-DELIMITED-LIST")
       (t            (string-append "unknown (" (tostring bits) ")"))))

(defun zcrexec-tyi (stream misc eoferp eofval recurp)
 (let ((char (stream-unread-char stream))) ; See if UNTYI was done
  (cond
   (char                            ; If a char was "unread"
    (setf (stream-unread-char stream) nil) ; clear it
   )
   (t                               ; otherwise no unread char
    (setq char
     (funcall (or (stream-input-function stream)
                  (zcrexec-error stream "TYI"
                          "No input operations possible on stream"))
              ))
    (when (null char)   ; If end of file encountered
          (setf (stream-eofp stream) t)
          (if eoferp
              (zcrexec-eof-error stream "TYI")
              (setq char eofval)))))
  (setf (stream-last-char stream) char)  ; Save for possible UNTYI
  (unless (stream-eofp stream)
          (incf (stream-charpos stream)))
  char))

(defun zcrexec-tyipeek (stream arg eoferp eofval recurp)
 (cond
  ((null arg)
   (let ((c (zcrexec-tyi stream nil eoferp eofval recurp)))
        (zcrexec-untyi stream c eoferp eofval recurp)
        c))
  ((eq arg t)
   (zcrexec-insure-readtable)
   (let ((syntaxes (readtable-syntaxes *readtable*)))
    (if (symbolp stream)
        (do ((c (peek-char nil stream eoferp #.eof recurp)
                (peek-char nil stream eoferp #.eof recurp)))
            ((or (eql c #.eof)
                 (not (eq (vref syntaxes c) :whitespace)))
             (if (eql c #.eof) eofval c))
            (read-char stream eoferp #.eof recurp))
        (do ((c (zcrexec-tyipeek stream nil eoferp #.eof recurp)
                (zcrexec-tyipeek stream nil eoferp #.eof recurp)))
            ((or (eql c #.eof)
                 (not (eq (vref syntaxes c) :whitespace)))
             (if (eql c #.eof) eofval c))
            (zcrexec-tyi stream nil eoferp #.eof recurp)))))
  ((characterp arg)
   (do ((c (zcrexec-tyipeek stream nil eoferp #.eof recurp)
           (zcrexec-tyipeek stream nil eoferp #.eof recurp)))
       ((or (eql c #.eof)
            (eql c arg))
        (if (eql c #.eof) eofval c))
       (zcrexec-tyi stream nil eoferp #.eof recurp)))
  (t (zcrexec-error stream "TYIPEEK"
                    "Invalid first arg to TYIPEEK" arg))))

(defun zcrexec-untyi (stream char eoferp eofval recurp)
 (let ((rchar (stream-last-char stream)))
  (cond
   ((null rchar)
    (zcrexec-error stream "UNTYI"
                   "UNTYI issued without intervening TYI" char))
   ((not (eql rchar char))
    (zcrexec-error stream "UNTYI"
                   "UNTYI character does not match" rchar char))
   (t
    (setf (stream-unread-char stream) rchar)
    (decf (stream-charpos stream))
    nil))))

(defun zcrexec-readch (stream misc eoferp eofval recurp)
 (let ((c (zcrexec-tyi stream misc nil #.eof recurp)))
      (if (eql c #.eof)
          (if eoferp
              (zcrexec-eof-error stream "READCH")
              eofval)
          (ebcdic c t))))

(defun zcrexec-peekch   (stream misc eoferp eofval recurp)
 (let ((c (zcrexec-tyipeek stream misc nil #.eof recurp)))
      (if (eql c #.eof)
          (if eoferp
              (zcrexec-eof-error stream "PEEKCH")
              eofval)
          (ebcdic c t))))

(defun zcrexec-eof      (stream misc eoferp eofval recurp)
 (stream-eofp stream))

(defun zcrexec-quit     (stream misc eoferp eofval recurp)
 (setf (stream-eofp stream) t))

(defun zcrexec-newlinep (stream misc eoferp eofval recurp)
 (eql (stream-last-char stream) #.eol))

(defun zcrexec-endread  (stream misc eoferp eofval recurp)
 (and (not (zcrexec-newlinep stream misc eoferp eofval recurp))
      (not (zerop (stream-charpos stream)))
      (zcrexec-tyipeek stream #.eol nil nil nil))
 nil)

(defun zcrexec-readline (stream misc eoferp eofval recurp)
 (cond
  ((stream-eofp stream)
   (if eoferp
       (zcrexec-eof-error stream "READLINE")
       eofval))
  (t
   (zcrread-begin-token stream)
   (zcrexec-endread stream nil nil nil nil)
   (zcrexec-tyi stream nil nil #.eol recurp)
   (do ((c (zcrexec-tyi stream nil nil #.eol recurp)
           (zcrexec-tyi stream nil nil #.eol recurp))
       )
       ((eql c #.eol)
        (zcrexec-untyi stream c nil #.eol recurp)
        (zcrread-make-string stream))
       (zcrread-add-to-token stream c nil nil)))))

(defun zcrexec-eof-error (stream fun)
 (zcrexec-error stream fun "End of file encountered"))

(defun zcrexec-charpos (stream misc eoferp eofval recurp)
 (stream-charpos stream))

(defun zcrexec-rminit (stream misc eoferp eofval recurp)
 (zcrexec-create-readtable))

;;; The Common LISP reader.

;;; Maclisp-compatible definition of READ would be:
;
; (defun read (&optional stream eofval)
;   (zcrexec-read stream nil nil eofval nil))
;
;;; Common Lisp-compatible definition of READ would be:
;
; (defun read (&optional stream eoferp eofval recursive-p)
;   (zcrexec-read stream nil eoferp eofval recursive-p))
;
; (defun read-reserving-whitespace
;       (&optional stream eoferp eofval recursive-p)
;   (zcrexec-read stream t eoferp eofval recursive-p))
;

(defun zcrexec-read
       (stream preserve-whitespace-p eoferp eofval recursive-p)
 (let ((*zcrexec-preserving-whitespace-p*
        (if recursive-p *zcrexec-preserving-whitespace-p*
                        preserve-whitespace-p)))
  (multiple-value-bind (object dotp)
                       (zcrread-1 stream eoferp eofval recursive-p)
   (when dotp
    (zcrexec-error stream "READ"
                   "Dot illegal outside of dotted pair context"))
   object)))

(defun zcrread-1 (stream eoferp eofval recurp)

 (prog (x y z syntax attribute terminating)

   step1   (setq x (read-char stream nil #.eof t))
           (when (eql x #.eof)
                 (if eoferp
                     (zcrexec-error stream "READ"
                                    "End of file encountered")
                     (return (values eofval nil))))
           (setq syntax (syntax-of x))
           (case syntax
                 (:whitespace          #| (go step3) |# (go step1))
                 (:constituent            (go step7))
                 (:terminating-macro      (go step4-terminating))
                 (:non-terminating-macro  (go step4-non-terminating))
                 (:single-escape          (go step5))
                 (:multiple-escape        (go step6))
                 (:illegal                (go step2))
           #+ZIL (:continuation-character (go stepz))
                 (t
                  (zcrread-bad-readtable-syntax x syntax stream)))

   step2 ; x is an illegal character

         (zcrread-illegal-character-error x stream)

;;;step3 ; x is a whitespace character

;;;;;;;;;(go step1)

   step4-non-terminating ; x is a non-terminating macro character

         (setq terminating nil)
         (go step4)

   step4-terminating ; x is a terminating macro character

         (setq terminating t)
;;;;;;;;;(go step4)

   step4 ; x is a macro character (terminating or non-terminating)

         (let ((macro-values (zcrread-macro-values x stream)))
              (cond
               ((null macro-values)
                (go step1))
              (t
               (return (values (car macro-values) nil)))))

   step5 ; x is a single-escape character

         (setq y (read-char stream nil #.eof t))
         (when (eql y #.eof)
               (zcrexec-error stream "READ" x))
         (zcrread-begin-token stream)
         (zcrread-add-to-token stream y :constituent :alphabetic)
         (go step8)

  step6 ; x is a multiple-escape character

         (zcrread-begin-token stream)
         (go step9)

  stepz  ; ZIL only ... x is a continuation character

        (setq y (read-char stream nil #.eof t))
        (when (eql y #.eof) ; Continuation followed by EOF - ignore it
              (zcrread-begin-token stream)
              (go step10))
        (when (eql y #.eol) ; Continuation followed by newline - yes
              (zcrread-begin-token stream)
              (go step8))
        (unread-char y stream)
;;;;;;;;(go step7)          ; Otherwise treat like constituent

  step7 ; x is a constituent character

        (zcrread-begin-token stream)
        (setq x (char-upcase x))
        (zcrread-add-to-token stream x)
;;;;;;;;(go step8)

  step8 ; At this point a token is being accumulated, and an even number
        ; of multiple escape characters have been encountered.

        (setq y (read-char stream nil #.eof t))
        (when (eql y #.eof)
              (go step10))
        (setq syntax (syntax-of y))
        (case syntax
              (:whitespace             (go step8f))
              (:constituent            (go step8a))
              (:terminating-macro      (go step8e))
              (:non-terminating-macro  (go step8a))
              (:single-escape          (go step8b))
              (:multiple-escape     #| (go step8c) |# (go step9))
              (:illegal                (go step8d))
        #+ZIL (:continuation-character (go step8z))
              (t
               (zcrread-bad-readtable-syntax y syntax stream)))

  step8a ; y is a constituent or non-terminating-macro character

         (setq y (char-upcase y))
         (zcrread-add-to-token stream y)
         (go step8)

  step8b ; y is a single-escape character

         (setq z (read-char stream nil #.eof t))
         (when (eql z #.eof)
               (zcrexec-error stream "READ" y))
         (zcrread-add-to-token stream z :constituent :alphabetic)
         (go step8)

;;step8c ; y is a multiple-escape character

;;;;;;;;;(go step9)

  step8d ; y is an illegal character

         (zcrread-illegal-character-error y stream)

  step8e ; y is a terminating macro character

         (unread-char y stream)
         (go step10)

  step8f ; y is a whitespace character

         (unless *zcrexec-preserving-whitespace-p*
          (unread-char y stream)
         )
         (go step10)

  step8z ; ZIL only ... y is a continuation character

         (setq z (read-char stream nil #.eof t))
         (when (eql z #.eof) ; Continuation followed by EOF - ignore it
               (go step10))
         (when (eql z #.eol) ; Continuation followed by newline - yes
               (go step8))
         (unread-char z stream)
         (go step8a)         ; Otherwise treat like constituent

  step9  ; At this point a token is being accumulated, and an odd number
         ; of multiple escape characters have been encountered.

        (setq y (read-char stream nil #.eof t))
        (when (eql y #.eof)
              (zcrexec-error stream "READ" x))
        (setq syntax (syntax-of y))
        (case syntax
              (:whitespace             (go step9a))
              (:constituent            (go step9a))
              (:terminating-macro      (go step9a))
              (:non-terminating-macro  (go step9a))
              (:single-escape          (go step9b))
              (:multiple-escape     #| (go step9c) |# (go step8))
              (:illegal                (go step9d))
        #+ZIL (:continuation-character (go step9z))
              (t
               (zcrread-bad-readtable-syntax y syntax stream)))

  step9a ; y is a constituent, macro or whitespace character

         (zcrread-add-to-token stream y :constituent :alphabetic)
         (go step9)

  step9b ; y is a single-escape character

         (setq z (read-char stream nil #.eof t))
         (when (eql z #.eof)
               (zcrexec-error stream "READ" y))
         (zcrread-add-to-token stream z :constituent :alphabetic)
         (go step9)

;;step9c ; y is a multiple-escape character

;;;;;;;;;(go step8)

  step9d ; y is an illegal character

         (zcrread-illegal-character-error y stream)

  step9z ; ZIL only ... y is a continuation character

         (setq z (read-char stream nil #.eof t))
         (when (eql z #.eof) ; Continuation followed by EOF - ignore it
               (go step10))
         (when (eql z #.eol) ; Continuation followed by newline - yes
               (go step9))
         (unread-char z stream)
         (go step9a)         ; Otherwise treat like constituent

  step10 ; An entire token has been accumulated.

         (return (zcrread-lisp-object stream))))

(defun zcrread-macro-values (char stream)
 (multiple-value-list
  (funcall (or (zcrread-character-macro-function char)
               (zcrexec-error stream "READ"
                              "No reader macro function for character"
                              (string char)))
           stream char)))

(defun zcrread-lisp-object (stream)
 (let ((readvector (stream-readvector stream)))
  (let ((index      (readvector-index readvector))
        (attributes (readvector-attributes readvector))
        (internp t)
        (numericp t)
        (alldotp t)
       )
  (do ((i (1- index) (1- i)))
      ((minusp i)
       (let ((s (zilvtos (readvector-characters readvector) index)))
            (when alldotp
             (case index
                   (0 (setq alldotp nil))
                   (1)
                   (t
              (zcrexec-error stream "READ"
                             "Token of all dots illegal" s))))
             (values (make-atom s internp numericp) alldotp)))
      (case (vref attributes i)
            (:alphabetic
             (setq numericp nil)
             (setq alldotp nil)
            )
            (:alphadigit
             (setq alldotp nil)
            )
            (:dot
            )
            (:illegal
             (zcrread-illegal-character-error (the-character i) stream))
            (t
             (zcrexec-error stream "READ"
                            "Can't deal with this character attribute"
                            (zcrread-hex (the-character i))
                            (the-attribute i))))))))


(defun zcrread-begin-token (stream)
 (let ((readvector (stream-readvector stream)))
      (setf (readvector-index readvector) 0)
      nil))

(defun zcrread-add-to-token (stream char &optional
                                       (syntax (syntax-of char))
                                       (attribute (attribute-of char))
                            )
 (let ((readvector (stream-readvector stream)))
  (let ((index  (readvector-index  readvector))
        (length (readvector-length readvector))
       )
       (when (>= index length)
        (let* ((new-length (+ length 256))
               (new-readvector (make-readvector new-length))
              )
         (setf (readvector-index new-readvector) index)
         (dotimes (i length)
          (setf (vref (readvector-characters new-readvector) i)
                (vref (readvector-characters readvector) i))
          (setf (vref (readvector-syntaxes new-readvector) i)
                (vref (readvector-syntaxes readvector) i))
          (setf (vref (readvector-attributes new-readvector) i)
                (vref (readvector-attributes readvector) i))
         )
         (setq readvector new-readvector)
         (setf (stream-readvector stream) readvector)
        )
       )
       (setf (vref (readvector-characters readvector) index) char)
       (setf (vref (readvector-syntaxes   readvector) index) syntax)
       (setf (vref (readvector-attributes readvector) index) attribute)
       (incf (readvector-index readvector))
       char
 )))

(defun zcrread-illegal-character-error (x stream)
 (zcrexec-error stream "READ" "Illegal character found in input: "
                (string x) (zcrread-hex x)))

(defun zcrread-bad-readtable-syntax (x syntax stream)
 (zcrexec-error stream "READ"
                "Invalid readtable syntax entry for "
                 (string x)
                 (zcrread-hex x)
                 syntax))

(defun zcrread-hex (x)
 (funcall 'format nil "X'~2,'0x'" x) ; Load FORMAT only when needed.
)

;
; ' (quote) reader macro
;

(defun zcrread-\'-macro (stream mchar)
 (list 'quote (zcrexec-read stream nil t nil t)))

;
; ` (backquote) reader macro
;

(defun zcrread-\`-macro (stream mchar)
 (mxbq (zcrexec-read stream nil t nil t)))

;
; ( (left parenthesis) reader macro              ;)
;

(defun zcrread-\(-macro (stream mchar)    ;)
;(read-delimited-list (rp) stream t)
;(zcrexec #.%%read-delimited-list stream (rp) t t t)
 (zcrexec-readdl                  stream (rp) t t t)
)

;                                                ;(
; ) (right parenthesis) reader macro
;

(defun zcrread-\)-macro (stream mchar)
 (zcrexec-error stream "READ" "Unmatched right parenthesis \")\""))

;
; ; (semicolon) reader macro
;

(defun zcrread-\;-macro (stream mchar)
 (peek-char #.eol stream nil #.eof t)
 (values))

;
; , (comma) dispatching reader macro
;

(defun zcrread-\,-macro (stream mchar)
 `(,(case (peek-char t stream t nil t)
          (#\@         (read-char stream) ; Throw away the character.
                       '|,@|)
          (#\.         (read-char stream) ; Throw away the character.
                       '|,.|)
          (t           '|,|))
   ,(zcrexec-read stream nil t nil t)))


;
; " (double quote) reader macro
;

(defun zcrread-\"-macro (stream mchar)
 (zcrread-begin-token stream)
 (prog (c d e)
    loop
       (setq c (read-char stream nil #.eof t))
       (cond
        ((eql c #.eof)
         (go eof-error))
        ((eql c #\")
         (return (zcrread-make-string stream)))
        (t
         (case (syntax-of c)
               (:single-escape
                (setq c (read-char stream nil #.eof t))
                (cond
                 ((eql c #.eof)
                  (go eof-esc-error))
                 (t
                  (zcrread-add-to-token stream c nil nil))))
         #+ZIL (:continuation-character
                (setq e (read-char stream nil #.eof t))
                (cond
                 ((eql e #.eof)
                  (go eof-error))
                 ((eql e #.eol)
                  ())
                 (t
                  (unread-char e stream)
                  (zcrread-add-to-token stream c nil nil))))
               (t
                (zcrread-add-to-token stream c nil nil)))))
       (go loop)
    eof-error
       (zcrexec-error stream "READ"
"End of file encountered while reading string before finding closing \""
       )
    eof-esc-error
       (zcrexec-error stream "READ"
"End of file encountered while reading string following single escape"
       )))

(defun zcrread-make-string (stream)
 ; Since this is called only in 1 place, readvector will never be null.
 (let ((readvector (stream-readvector stream)))
      (zilvtos (readvector-characters readvector)
               (readvector-index readvector))))

;
; READ-DELIMITED-LIST processor
;

(defun zcrexec-readdl (stream char ignore dottedp recurp)
 (unless (characterp char)
         (zcrexec-error stream "READ-DELIMITED-LIST"
                               "Not a character" char))
 (prog (z c thing needatom gotatom (eofval (ncons nil)))
    loop
       (setq c (peek-char t stream nil #.eof t))
       (cond
        ((eql c #.eof)
         (go eof-error))
        ((eql c char)
         (read-char stream) ; Consume the character.
         (cond
          (needatom
           (zcrexec-error stream "READ-DELIMITED-LIST"
                  "Dotted pair error - no object read following \".\""))
          (gotatom
           (return z))
          (t
           (return (nreverse z)))))
        (t
         (case (syntax-of c)
          ((:terminating-macro
            :non-terminating-macro)
           (read-char stream) ; Consume the character.
           (let ((macro-values (zcrread-macro-values c stream)))
                (cond
                 ((null macro-values)
                  (go loop))
                 (t
                  (setq thing (car macro-values))
                  (go push-it)))))
          (t
           (multiple-value-bind (object dotp)
                                (zcrread-1 stream nil eofval t)
            (when (eq object eofval) (go eof-error))
            (cond
             (dotp
              (unless dottedp
                      (zcrexec-error stream "READ-DELIMITED-LIST"
                             "Dot illegal outside dotted pair context"))
              (unless z
                      (zcrexec-error stream "READ-DELIMITED-LIST"
                  "Dotted pair error - no object read preceding \".\""))
              (setq needatom t gotatom nil dottedp nil)
              (go loop)
             )
             (t
              (setq thing object)
              (go push-it))))))))
    push-it
       (cond
        (gotatom
         (zcrexec-error stream "READ-DELIMITED-LIST"
       "Dotted pair error - more than one object read following \".\""))
        (needatom
         (setq z (nreconc z thing))
         (setq needatom nil gotatom t)
        )
        (t
         (push thing z)))
       (go loop)
    eof-error
       (zcrexec-error stream "READ-DELIMITED-LIST"
"End of file encountered while reading list before finding delimiter"
                       (string char))
 ))

;
; # (sharp) dispatching reader macro
;

;
; This function is used to implement the reader macro # in conjunction
; with the Common LISP reader (CLREAD).
;
; Currently the only syntax supported is:
;
;   #'FOO   --> (FUNCTION FOO)
;   #+FOO BAR  --> BAR, only if feature FOO exists
;   #-FOO BAR  --> BAR, only if feature FOO doesn't exist
;   #.FOO   --> evaluated value of FOO.
;   #/FOO   --> the fixnum corresponding to the character FOO.
;   #\FOO   --> same as #/FOO.
;   #¬Y     --> the fixnum correspinding to "CONTROL Y" if it existed.
;   #o777   --> integer expressed in octal.
;   #O777   --> integer expressed in octal.
;   #x7F0   --> integer expressed in hex.
;   #X7F0   --> integer expressed in hex.
;   #b101   --> integer expressed in binary.
;   #B101   --> integer expressed in binary.
;   #nnRnnn --> integer expressed in radix nn.
;   #|...|# --> comments.
;   #(...)  --> vector.
;   #S(...) --> structure (added 1/88).
;
;   #,FOO   --> load-time evaluation of FOO.  Currently this is
;               identical to #.FOO, which it's supposed to be
;               under the interpreter anyhow.
;
; ZIL-only extensions...
;
;   #z7F0   --> FIXNUM expressed in hex.
;   #Z7F0   --> FIXNUM expressed in hex.
;
; and...
;
;   # followed by a character, if set-dispatch-macro-character has been
;     done for that character.
;

(eval-when ()  ; Processed by nobody but READ.
 #.(progn
    (defvar character-types
     '(
           (NULL      .   #X00)
           (HT        .   #X05)
           (TAB       .   #X05)
           (DEL       .   #X07)
           (RUBOUT    .   #X07)
           (VT        .   #X0B)
           (CR        .   #X0D)
           (RETURN    .   #X0D)
           (NL        .   #X15)
           (NEWLINE   .   #X15)
           (BS        .   #X16)
           (BACKSPACE .   #X16)
           (LF        .   #X25)
           (LINEFEED  .   #X25)
           (FF        .   #X2C)
           (FORM      .   #X2C)
           (PAGE      .   #X2C)
           (SP        .   #X40)
           (SPACE     .   #X40)
           (ALT       .   #X100) ; "Invalid".
           (ALTMODE   .   #X100) ; "Invalid".
     ))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun zcrread-\#-macro (f mchar)
 (let* ((c) ; Will be set to first non-numeric character read.
        (n (prog (d z)
             loop
                 (setq c (or (read-char f nil nil t)
                             (zcrexec-error f "READ"
                                "No dispatch character for #")))
                 (setq d (digit-char-p c 10))
                 (when (null d)
                       (return z))
                 (setq z (+ (* 10 (or z 0)) d))
                 (go loop)
          ))
       )
       (funcall (or (zcrread-dispatch-macro-function (char-upcase c))
                    (zcrexec-error f "READ"
             "No dispatching function defined for character following #"
                                   (string c) (zcrread-hex c)))
                f c n)))

;=======================================================================

(defun zcrsharp-n-error (f c n)
 (zcrexec-error f "READ"
   "Numeric modifier not allowed for dispatcher"
   (symbol-name (concat "#" n (string c)))))

;=======================================================================

;
; #'foo --> (FUNCTION foo)
;

(defun zcrsharp-quote (f c n)
 (when n (zcrsharp-n-error f c n))
 `(function ,(zcrexec-read f nil t nil t))
)

;=======================================================================

;
; #.(foo) --> ...whatever the value of (foo) is...
;

(defun zcrsharp-period (f c n)
 (when n (zcrsharp-n-error f c n))
 (catch nil (eval (zcrexec-read f nil t nil t)))
; Return NIL if error evaluating form.
)

;=======================================================================

;
; #,(foo) --> ...whatever the value of (foo) is at load time ...
;

(defun zcrsharp-comma (f c n)
 (when n (zcrsharp-n-error f c n))
 (when (featurep 'zilco) ; If being read by the compiler
  (cterpri)
  (princ "Load-time evaluation (#,) not supported by ZIL compiler.")
  (terpri)
  (princ "Processing as read-time evaluation (#.).")
  (terpri)
 )
 (zcrsharp-period f c n) ; Process like #.
)

;=======================================================================

;
; #+foo --> if foo is a feature, then whatever follows
;

(defun zcrsharp-plus (f c n)
 (when n (zcrsharp-n-error f c n))
 (cond
       ((zcrsharp-eval-features (zcrexec-read f nil t nil t) f)
        (zcrexec-read f nil t nil t))
       (t
        (let ((*read-suppress* t))
             (zcrexec-read f nil t nil t))
        (values))))

;
; #-foo --> if foo is NOT a feature, then whatever follows
;

(defun zcrsharp-minus (f c n)
 (when n (zcrsharp-n-error f c n))
 (cond
       ((zcrsharp-eval-features (zcrexec-read f nil t nil t) f)
        (let ((*read-suppress* t))
             (zcrexec-read f nil t nil t))
        (values))
       (t
        (zcrexec-read f nil t nil t))))

(defun zcrsharp-eval-features (x f)
 (cond
  ((atom x)
   (featurep x))
  ((eq (zcar x) 'or)
   (some #'(lambda (x) (zcrsharp-eval-features x f)) (cdr x)))
  ((eq (zcar x) 'and)
   (every #'(lambda (x) (zcrsharp-eval-features x f)) (cdr x)))
  ((eq (zcar x) 'not)
   (if (and (cdr x) (null (cddr x)))
       (not (zcrsharp-eval-features (zcadr x) f))
       (zcrsharp-feature-error x f)))
  (t
   (zcrsharp-feature-error x f))))

(defun zcrsharp-feature-error (x f)
 (zcrexec-error f "READ" "Invalid feature specification form" x))

;
; #/foo --> returns a character object (actually a fixnum)
; #\foo --> same as #/foo
;

(defun zcrsharp-escape (f c n)
 (when n (zcrsharp-n-error f c n))
 (zcrsharp-character-representation f))

;
; #¬foo --> returns an impossible character object fixnum for CNTL-foo
;

(defun zcrsharp-control (f c n)
 (when n (zcrsharp-n-error f c n))
 (+ 256 (zcrsharp-character-representation f))
)

(defun zcrsharp-character-representation (f)
 (let ((a (peek-char nil f t nil t)))
  (if (alpha-char-p a)
      (let* ((r (zcrexec-read f nil t nil t))
             (c (assq r '#.character-types)))
            (if c (cdr c)
                  (if (eql (string-length r) 1) ; If it read 1 character
                      a
                      (zcrexec-error f "READ"
                                "Unknown character representation" r))))
      (read-char f t nil t))))

;
; #o777 ...
;
(defun zcrsharp-octal (f c n)
 (when n (zcrsharp-n-error f c n))
 (zcrsharp-radix f 8))

;
; #x1AC8 ...
;
(defun zcrsharp-hex (f c n)
 (when n (zcrsharp-n-error f c n))
 (zcrsharp-radix f 16))

;
; #b1011 ...
;
(defun zcrsharp-binary (f c n)
 (when n (zcrsharp-n-error f c n))
 (zcrsharp-radix f 2))

;
; #36rfoobar ...
;
(defun zcrsharp-radix-n (f c n)
 (unless n (zcrexec-error f "READ" "Numeric modifier required for #R"))
 (when (or (< n 2) (> n 36))
       (zcrexec-error f "READ" "Invalid radix modifier for #R" n))
 (zcrsharp-radix f n))

(defun zcrsharp-radix (f radix)
 (prog (a z neg? err)
       (setq z 0)
  get1
       (setq a
             (or (peek-char nil f nil nil t)
                 (zcrexec-error f "READ"
                                  "No digits following # with radix"
                                  radix)))
       (when (eql a #\SP)
             (read-char f) ; Throw away the peeked character.
             (go get1))
       (case a
             ((#\-) (setq neg? t)
                    (go next))
             ((#\+) (setq neg? nil)
                    (go next))
       )
  loop
       (let ((weight (or (digit-char-p a 36) (go ret))))
            (if (not (< weight radix))
                (push (string a) err)
                (setq z (+ weight (* z radix)))))
  next
       (read-char f) ; Throw away the peeked character.
       (setq a (peek-char nil f nil #.eof t))
       (if (eql a #.eof)
           (go ret)
           (go loop)
       )
  ret
       (when err
             (zcrexec-error f "READ"
                            "Invalid digit(s) for radix"
                            radix (nreverse err)))
       (return (if neg? (minus z) z))
 )
)

;;;
;;; #Znnn is like #Xnnn except that it always produces a fixnum,
;;; which can be two's complement, and therefore cannot have more
;;; than 8 hex characters.
;;;
;;; For example...
;;;
;;; #XFFFFFFFF  =  42
;;; #ZFFFFFFFF  =  -1
;;;

(defun zcrsharp-hex370 (f c n)
 (when n (zcrsharp-n-error f c n))
 (prog (a z count err)
       (setq z 0 count 0)
  get1
       (setq a (or (peek-char nil f nil nil t)
                   (zcrexec-error f "READ" "No digits following #Z")))
       (when (eql a #\SP)
             (read-char f) ; Throw away the peeked character.
             (go get1))
  loop
       (when (> count 8)
             (zcrexec-error f "READ"
                              "Too many hex digits in #Z constant"))
       (setq count (1+ count))
       (let ((weight (or (digit-char-p a 36) (go ret))))
            (if (not (< weight 16))
                (push (string a) err)
                (setq z (+ weight (lsh z 4)))))
  next
       (read-char f) ; Throw away the peeked character.
       (setq a (peek-char nil f nil #.eof t))
       (if (eql a #.eof)
           (go ret)
           (go loop)
       )
  ret
       (when err (zcrexec-error f "READ" "Invalid hex digit(s)"
                                (nreverse err)))
       (return z)
 )
)

;
; #| comment ... |#
;
(defun zcrsharp-comment (f c n)
 (when n (zcrsharp-n-error f c n))
 (zcrsharp-comment-search f)
)

(defun zcrsharp-comment-search (f)
 (prog (k)
  loop                            ; Search for other comment characters.
       (setq k (read-char f nil #.eof t))
  chk1 (cond                      ; See what we got.
        ((eql k #.eof)              ; If end of file, terminate
         (return (values)))         ; with nothing read.
        ((eql k #\|)                ; If we got |, we might have |#.
         (setq k (read-char f nil #.eof t))  ; Get next character.
         (or (eql k #\#) (go chk1)) ; If not #, check as usual.
         (return (values)))         ; If |# found, return to reader.
        ((eql k #\#)                ; If we got #, may be nested #|.
         (setq k (read-char f nil #.eof t))  ; Get next character.
         (or (eql k #\|) (go chk1)) ; If not #|, keep checking.
         (zcrsharp-comment-search f); Process nested comment group.
         (go loop))                 ; and then keep going.
        (t (go loop)))))

;
; #(foo bar baz)
;
(defun zcrsharp-vector (f c n)
 ; Get back the left parenthesis - we need it to read the list
 (unread-char c f)
 (cond
  (n
   (prog (z l i y)
         (setq z (make-vector n))
         (setq l (zcrexec-read f nil t nil t))
         (setq i 0)
         (setq y nil)
    loop
         (cond
          ((eql i n)
           (when l (warn "Too many objects for #(, ignored" l)) ; )
           (return z))
          ((null l)
           (vset z i y))
          ((atom l)
           (zcrexec-error f "READ" "Improper syntax for #(" l))     ; )
          (t
           (setq y (zcar l))
           (vset z i y)))
         (setq l (cdr l))
         (setq i (1+ i))
         (go loop)))

  (t
   (zmvector (zcrexec-read f nil t nil t)))))

;
; #S(foo :bar 1 :baz frob)
;
(defun zcrsharp-struct (f c n)
 (when n (zcrsharp-n-error f c n))
 (unless (eql (peek-char nil f nil nil t) (lp))
         (zcrexec-error f "READ" "#S must be followed by (.")) ; )
 (let ((list (zcrexec-read f nil t nil t)))
       (unless (and list (symbolp (car list)))
        (zcrexec-error f "READ" "Invalid structure name in list" list))
       (unless (get (car list) 'defstruct-properties)
        (zcrexec-error f "READ" "Type not defined as structure" list))
       (eval `(,(or (get (car list) 'defstruct-constructor-macro)
                    (zcrexec-error f "READ"
                      "No constructor defined for this structure type"
                           list))
               . ,(do ((x (cdr list) (cddr x))
                       (z nil)
                      )
                      ((null x) (nreverse z))
                      (push (car x) z)
                      (when (null (cdr x))
                            (zcrexec-error f "READ"
                  "Odd number of arguments following type in #S syntax"
                                   list))
                      (push `',(cadr x) z))))))

;;;
;;; Just a random repository of code that would be inserted into
;;; ZRMSHARP if we wanted to make #¬foo do something.
;;;
;;; We have NOT activated it.  #¬ exists only because of Macsyma,
;;; and we don't want to cause any "real" EBCDIC characters to
;;; start behaving like ASCII control characters.  So we let #¬
;;; generate an "impossible" character instead.
;;;
;;; (defvar control-fakeouts
;;;  (let ((cflist (make-list 256)))
;;;        ;
;;;        ; Since it's not clear whether #¬a is supposed to be the
;;;        ; same as #¬A or not, and #¬ is not even defined as part
;;;        ; of CL, the lower-case letters are left undefined.
;;;        ;
;;;        (setf (nth #\@  cflist) #X00) ; NUL
;;;        (setf (nth #\A  cflist) #X01) ; SOH
;;;        (setf (nth #\B  cflist) #X02) ; STX
;;;        (setf (nth #\C  cflist) #X03) ; ETX
;;;        (setf (nth #\D  cflist) #X37) ; EOT
;;;        (setf (nth #\E  cflist) #X2D) ; ENQ
;;;        (setf (nth #\F  cflist) #X2E) ; ACK
;;;        (setf (nth #\G  cflist) #X2F) ; BEL
;;;        (setf (nth #\H  cflist) #X16) ; BS
;;;        (setf (nth #\I  cflist) #X05) ; HT
;;;        (setf (nth #\J  cflist) #X25) ; LF
;;;        (setf (nth #\K  cflist) #X0B) ; VT
;;;        (setf (nth #\L  cflist) #X0C) ; FF
;;;        (setf (nth #\M  cflist) #X0D) ; CR
;;;        (setf (nth #\N  cflist) #X0E) ; SO
;;;        (setf (nth #\O  cflist) #X0F) ; SI
;;;        (setf (nth #\P  cflist) #X10) ; DLE
;;;        (setf (nth #\Q  cflist) #X11) ; DC1
;;;        (setf (nth #\R  cflist) #X12) ; DC2
;;;        (setf (nth #\S  cflist) #X13) ; DC3
;;;        (setf (nth #\T  cflist) #X3C) ; DC4
;;;        (setf (nth #\U  cflist) #X3D) ; NAK
;;;        (setf (nth #\V  cflist) #X32) ; SYN
;;;        (setf (nth #\W  cflist) #X26) ; ETB
;;;        (setf (nth #\X  cflist) #X18) ; CAN
;;;        (setf (nth #\Y  cflist) #X19) ; EM
;;;        (setf (nth #\Z  cflist) #X3F) ; SUB
;;;        (setf (nth #XAD cflist) #X27) ; ESC   (cntl-left-bracket)
;;;        (setf (nth #\\  cflist) #X1C) ; {I}FS
;;;        (setf (nth #XBD cflist) #X1D) ; {I}GS (cntl-right-bracket)
;;;        (setf (nth #\¬  cflist) #X1E) ; {I}RS
;;;        (setf (nth #\_  cflist) #X1F) ; {I}US
;;;        (setf (nth #\`  cflist) #X40) ; SP
;;;        (setf (nth #\{  cflist) #\; ) ; ;
;;;        (setf (nth #\|  cflist) #\< ) ; <
;;;        (setf (nth #\}  cflist) #\= ) ; =
;;;        (setf (nth #\~  cflist) #\> ) ; >
;;;        (setf (nth #X07 cflist) #\? ) ; ?    (cntl-rubout)
;;;        cflist
;;;  ))
;;;  (defun zcrsharp-control (f)
;;;   (read-char f) ; Throw away the character following the #.
;;;   (let ((c (character-representation f)))
;;;        (or (nth c '#.control-fakeouts)
;;;            (zcrexec-error f "READ"
;;;                         "Unknown ASCII control spec"
;;;                         (string c) (zcrread-hex c)))))

(declare (special *zcrexec-stream-table*))

(defun zcrexec-prepare-stream (stream for-reading-p)
 (when (symbolp stream)
       (unless (boundp '*zcrexec-stream-table*)
               (setq *zcrexec-stream-table* nil))
       (let* ((fileid stream)
              (p (assq fileid *zcrexec-stream-table*))
             )
             (cond
              (p
               (setq stream (cdr p)))
              (t
               (setq stream (make-stream
                                 :identifier
                                 (list 'file fileid (zildsni fileid))
                                 :type 'file
                                 :input-function
                                 #'(lambda ()
                                    (read-char fileid nil nil))))
               (push (cons fileid stream) *zcrexec-stream-table*)))))
 (cond
  (for-reading-p
   (unless (stream-readvector stream)
           (setf (stream-readvector stream) (make-readvector 256))
           (zcrexec-insure-readtable)))
  (t
   (zcrexec-insure-readtable)))
 stream
)

(defun zcrexec-insure-readtable ()
 (unless (boundp '*readtable*)
         (zcrexec-create-readtable)))

(defun zcrexec-create-readtable ()

 (setq *zcrexec-readtable* (make-readtable :name 'default))
 (setf (readtable-character-macro-table *zcrexec-readtable*)
       (make-vector 256 nil))
 (setf (readtable-dispatch-macro-table  *zcrexec-readtable*)
       (make-vector 256 nil))
 (setq *zcrexec-preserving-whitespace-p* nil)
 (setq *read-suppress*                   nil)

; ff. from page 336 of CLtL

 (let ((a (readtable-syntaxes *zcrexec-readtable*)))
      (vset a #/linefeed  :whitespace)
      (vset a #/newline   :whitespace)
      (vset a #/page      :whitespace)
      (vset a #/return    :whitespace)
      (vset a #/space     :whitespace)
      (vset a #/tab       :whitespace)
      (vset a #/\         :single-escape)
      (vset a #/|         :multiple-escape)
      (vset a #/#         :terminating-macro) ; :non-terminating-macro
      (vset a #/(  #|)|#  :terminating-macro)
      (vset a #/)  #|(|#  :terminating-macro)
      (vset a #/;         :terminating-macro)
      (vset a #/,         :terminating-macro)
      (vset a #/`         :terminating-macro)
      (vset a #/'         :terminating-macro)
      (vset a #/"         :terminating-macro)
 #+ZIL(vset a #x4A        :continuation-character) ; cent sign
 )

 ; ff. from page 340 of CLtL

 (let ((a (readtable-attributes *zcrexec-readtable*)))
      (vset a #/!         :alphadigit)
      (vset a #/"         :alphadigit)
      (vset a #/#         :alphadigit)
      (vset a #/$         :alphadigit)
      (vset a #/%         :alphadigit)
      (vset a #/&         :alphadigit)
      (vset a #/'         :alphadigit)
      (vset a #/(  #|)|#  :alphadigit)
      (vset a #/)  #|(|#  :alphadigit)
      (vset a #/*         :alphadigit)
      (vset a #/,         :alphadigit)
      (vset a #/0         :alphadigit)
      (vset a #/1         :alphadigit)
      (vset a #/2         :alphadigit)
      (vset a #/3         :alphadigit)
      (vset a #/4         :alphadigit)
      (vset a #/5         :alphadigit)
      (vset a #/6         :alphadigit)
      (vset a #/7         :alphadigit)
      (vset a #/8         :alphadigit)
      (vset a #/9         :alphadigit)
      (vset a #/:         :alphadigit) ;(not 'package-marker)
      (vset a #/;         :alphadigit)
      (vset a #/<         :alphadigit)
      (vset a #/=         :alphadigit)
      (vset a #/>         :alphadigit)
      (vset a #/?         :alphadigit)
      (vset a #/@         :alphadigit)
      (vset a #xad        :alphadigit)
      (vset a #/\         :alphadigit)
      (vset a #xbd        :alphadigit)
      (vset a #/¬         :alphadigit)
      (vset a #/_         :alphadigit)
      (vset a #/`         :alphadigit)
      (vset a #/{         :alphadigit)
      (vset a #/|         :alphadigit)
      (vset a #/}         :alphadigit)
      (vset a #/~         :alphadigit)
      (vset a #/+         :alphadigit)
      (vset a #/-         :alphadigit)
      (vset a #/.         :dot)
      (vset a #//         :alphadigit) ;(not 'ratio)
      (vset a #/a         :alphadigit)
      (vset a #/b         :alphadigit)
      (vset a #/c         :alphadigit)
      (vset a #/d         :alphadigit)
      (vset a #/e         :alphadigit)
      (vset a #/f         :alphadigit)
      (vset a #/g         :alphadigit)
      (vset a #/h         :alphadigit)
      (vset a #/i         :alphadigit)
      (vset a #/j         :alphadigit)
      (vset a #/k         :alphadigit)
      (vset a #/l         :alphadigit)
      (vset a #/m         :alphadigit)
      (vset a #/n         :alphadigit)
      (vset a #/o         :alphadigit)
      (vset a #/p         :alphadigit)
      (vset a #/q         :alphadigit)
      (vset a #/r         :alphadigit)
      (vset a #/s         :alphadigit)
      (vset a #/t         :alphadigit)
      (vset a #/u         :alphadigit)
      (vset a #/v         :alphadigit)
      (vset a #/w         :alphadigit)
      (vset a #/x         :alphadigit)
      (vset a #/y         :alphadigit)
      (vset a #/z         :alphadigit)
      (vset a #/A         :alphadigit)
      (vset a #/B         :alphadigit)
      (vset a #/C         :alphadigit)
      (vset a #/D         :alphadigit)
      (vset a #/E         :alphadigit)
      (vset a #/F         :alphadigit)
      (vset a #/G         :alphadigit)
      (vset a #/H         :alphadigit)
      (vset a #/I         :alphadigit)
      (vset a #/J         :alphadigit)
      (vset a #/K         :alphadigit)
      (vset a #/L         :alphadigit)
      (vset a #/M         :alphadigit)
      (vset a #/N         :alphadigit)
      (vset a #/O         :alphadigit)
      (vset a #/P         :alphadigit)
      (vset a #/Q         :alphadigit)
      (vset a #/R         :alphadigit)
      (vset a #/S         :alphadigit)
      (vset a #/T         :alphadigit)
      (vset a #/U         :alphadigit)
      (vset a #/V         :alphadigit)
      (vset a #/W         :alphadigit)
      (vset a #/X         :alphadigit)
      (vset a #/Y         :alphadigit)
      (vset a #/Z         :alphadigit)

 #+ZIL(vset a #x4a        :alphadigit) ; not illegal

 )

 (let ((a (readtable-character-macro-table *zcrexec-readtable*)))
      (vset a #/#         #'zcrread-\#-macro)
      (vset a (lp)        #'zcrread-\(-macro)
      (vset a (rp)        #'zcrread-\)-macro)
      (vset a #/;         #'zcrread-\;-macro)
      (vset a #/,         #'zcrread-\,-macro)
      (vset a #/`         #'zcrread-\`-macro)
      (vset a #/'         #'zcrread-\'-macro)
      (vset a #/"         #'zcrread-\"-macro)
 )

 (let ((a (readtable-dispatch-macro-table *zcrexec-readtable*)))
      (vset a #\.                  #'zcrsharp-period)
      (vset a (lp)                 #'zcrsharp-vector)
      (vset a #\+                  #'zcrsharp-plus)
      (vset a #\|                  #'zcrsharp-comment)
      (vset a #\¬                  #'zcrsharp-control)
      (vset a #\-                  #'zcrsharp-minus)
      (vset a #\/                  #'zcrsharp-escape)
      (vset a #\,                  #'zcrsharp-comma)
      (vset a #\'                  #'zcrsharp-quote)
      (vset a #\B                  #'zcrsharp-binary)
      (vset a #\O                  #'zcrsharp-octal)
      (vset a #\R                  #'zcrsharp-radix-n)
      (vset a #\\                  #'zcrsharp-escape)
      (vset a #\S                  #'zcrsharp-struct)
      (vset a #\X                  #'zcrsharp-hex)
      (vset a #\Z                  #'zcrsharp-hex370)
 )

 (setq *readtable*
       (copy-readtable *zcrexec-readtable*
         :syntaxes   (vcopy (readtable-syntaxes   *zcrexec-readtable*))
         :attributes (vcopy (readtable-attributes *zcrexec-readtable*))
         :character-macro-table
          (vcopy (readtable-character-macro-table *zcrexec-readtable*))
         :dispatch-macro-table
          (vcopy (readtable-dispatch-macro-table *zcrexec-readtable*))
       ))

 nil
)

(defun zcrexec-rdrmacro (stream misc eoferp eofval recurp)
 ; MISC   is the reader macro character (symbol, string or fixnum)
 ; EOFERP is the reader macro SUBR, or NIL
 (zcrexec-insure-readtable)
 (let ((cmtable      (readtable-character-macro-table *readtable*))
       (syntaxes     (readtable-syntaxes   *readtable*))
       (old-cmtable  (readtable-character-macro-table
                                           *zcrexec-readtable*))
       (old-syntaxes (readtable-syntaxes   *zcrexec-readtable*))
       (character (cond
                   ((characterp misc)
                    misc)
                   ((and (or (stringp misc) (symbolp misc))
                         (eql (string-length misc) 1))
                    (char misc 0))
                   (t
                    (zcrexec-error stream "RDRMACRO"
                                   "Invalid reader macro character"
                                   misc))))
      )
      (cond
       ((null eoferp)
        (vset cmtable  character nil)
        (vset syntaxes character (vref old-syntaxes character))
       )
       (t
        (vset cmtable  character
              #'(lambda (s c &aux (*zcrexec-rmchar* (ebcdic c t)))
                        (declare (special *zcrexec-rmchar*))
                        (funcall eoferp s)))
        (vset syntaxes character :terminating-macro)
       )
      )

 )
 nil
)

(defun zcrexec-rmmac    (stream misc eoferp eofval recurp)
 (zcrexec-insure-readtable)
 (let ((syntaxes   (readtable-syntaxes   *readtable*))
       (attributes (readtable-attributes *readtable*))
      )
      (vset syntaxes    #//   :single-escape)
      (vset syntaxes    #/\   :constituent)
 )
 nil
)

(defun zcrexec-rmchar   (stream misc eoferp eofval recurp)
 (declare (special *zcrexec-rmchar*))
 *zcrexec-rmchar*
)

(defun zcrexec-error (stream fun message &optional (arg1 () arg1?)
                                                   (arg2 () arg2?)
                                                   (arg3 () arg3?))
 (cterpri)
 (princ "Error detected for stream ")
 (princ (stream-identifier stream))
 (princ ":")
 (terpri)
 (princ message)
 (when arg1? (princ " - ") (prin1 arg1))
 (when arg2? (princ " ")   (prin1 arg2))
 (when arg3? (princ " ")   (prin1 arg3))
 (terpri)
 (zerror `(,fun " failure"))
)

