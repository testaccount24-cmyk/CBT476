
;***********************************************************************
;*                                                                     *
;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
;*         All rights reserved.                                        *
;*                                                                     *
;***********************************************************************

;**********************************************************************
;*                                                                    *
;* GEN-BEGIN                                                          *
;*                                                                    *
;**********************************************************************
;
;***********************************************************************
;*                                                                     *
;* Change activity:                                                    *
;*                                                                     *
;* 06/23/88 - Support for PROG and RETURN removed.                     *
;* 04/14/2000 - Support for HLASM USING checking.                      *
;*                                                                     *
;***********************************************************************
;
;
; Notes:
;
;   MAIN and ALONE are "special" variables (see ZILMACS).
;
;   To support correct processing for tail recursion out of an
;   environment with its own special variable bindings, we use two
;   labels for tail recursion to branch to:  one for normal tail
;   recursion where no variable bindings need be changed, and one
;   for tail recursion where variable bindings must be
;   reestablished.  In order to do this, we had to separate the
;   saving of the current alists from the building of the new
;   alists.  Also, saving the current alists must be done in some
;   cases even if the function's own arguments are not "special"
;   or "pseudolexical".
;
;***********************************************************************
;*
;* NOTE!!! The code generated for LEXPR's is tested for by the garbage
;* collector in ZILCONS.  IF YOU CHANGE ONE YOU MUST CHANGE THE OTHER!!
;*
;***********************************************************************
;
;***********************************************************************
;*
;* NOTE!!! The initial value for CODELEN is based on the size of the
;* code generated by the #ZBEG macro.  IF YOU CHANGE THE #ZBEG MACRO
;* YOU MUST CHANGE THIS HERE TOO!!!
;*
;***********************************************************************
;
;=======================================================================

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(include #.(zil-source-member zilmacs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun zcgbegin (a)
 (prog (name args nargs adconp)
  (desetq (name args main alone) a)
  (setq nargs (length args))
  (setq pdbas
        (if (get (car name) 'lexprarg)
            4
            (* nargs 4)))           ; top of passed argument list
  (setq stack (+ pdbas 12))         ; top of standard interface save

  (setq adconp                      ; True if ZILSINT needs to be called
   (if main
    then
       (and alone
            (or
             (cdr lists) (cdr alfatoms) (cdr numatoms) (cdr alllists)
            ))
    else
       (or (cdr lists) (cdr atoms))
    endif
   ))

  (when (or adconp (and main (not alone)))
        (setf (get (cdr name) 'zzzptrs ) (if main "ZLBPTRS" (gensym)))
        (setf (get (cdr name) 'zzzatoms) (if main "ZILATOM" nil     ))
        (setf (get (cdr name) 'zzzlists) (if main "ZILLIST" (gensym)))
  )
;
; Assign offsets to all args.
;
  (loop for arg in args
   (setf (get (cdr arg) 'offset)
         (* (1- (get (cdr arg) 'position)) 4)))

;
; Assign location names to all subrs.
;
  (mapc #'assign-location (cdr subrs))
;
; Assign location names to all atoms.
;
  (if main
   then     ; Every atom has to have a location known to the main proc.
    (mapc #'assign-location (cdr numatoms))
    (mapc #'assign-location (cdr alfatoms))
   else     ; Internal subfunction. Assign new locations to atoms.
    (mapc #'assign-location (cdr atoms))
   endif
  )
;
; If subroutines are known,
;  or if there are unbound specials (which will cause either ZILVSYM
;  or ZILVSET to be called, in this deep-binding implementation),
;  then it is probable that one of the special subroutines will have to
;  be included.
; Even if we're wrong, set up a label for the subroutine addresses so
;  we're ok for loading of the special subroutines by ZILLOAD.
;

  (setf (get (cdr name) 'zzzsubrs)
        (if (or (cdr subrs) (cdr special-unbounds)) (gensym) nil))
;
; Begin code generation.
;
  (zcgbegin1 nargs)
;
; Generate code to intern and initialize constants if required,
; and to save the current alist pointers if required.
;
  (zcgbegin2 adconp)
;
; Generate code to retrieve values of free variables.
;
  (zcgbegin3)

;
; End variable setting code.
;
; Establish a label to which tail recursion can branch.
;
  (zcgemit 0 zzzcont "DS" "0H" nil)
;
; Reset stack offsets.
;
  (setq stackmax  (if (or (car special-asaved)
                          (car fluid-asaved))
                      (+ stack 8)
                      stack)
        pdmax     (ncons stack)
        argbase   (ncons stack))

 ) ; end PROG
) ; end DEFUN ZCGBEGIN

;=======================================================================

; NOTE! Use of '* (the symbol with a print name of *) means that an
; asterisk is to be inserted in column 72 as a continuation character
; by ZCGENOUT.  Do not use a string there!

(defun zcgbegin1 (nargs)
 (prog (mina maxa rest zzzsubrs zzzptrs zzzatoms zzzlists
                       pdsize vssize cssize acsize)
  (setq mina     (or (get (car name) 'minargs) nargs)
        maxa     (or (get (car name) 'maxargs) nargs)
        rest     (get (car name) 'restarg)
        zzzsubrs (get (cdr name) 'zzzsubrs)
        zzzptrs  (get (cdr name) 'zzzptrs )
        zzzatoms (get (cdr name) 'zzzatoms)
        zzzlists (get (cdr name) 'zzzlists)
        pdsize   (get '*zilco*   'pdsize)
        vssize   (get '*zilco*   'vssize)
        cssize   (get '*zilco*   'cssize)
        acsize   (get '*zilco*   'acsize))

  (setq codelen
   (cond
    ((and main (not alone))
     44)
    (t
     (* 4 (quotient (+ #.(+ 25 3) (string-length (car name))) 4)))))

  (zcgenout nil "TITLE"
               `("'" ,(cdr name) " - source generated by ZIL 1.3'") nil)

  (and alone (go aloneyes))

  (and main (go mainyes))

 mainno ; MAIN = NO, ALONE = NO: Subrte internal to executable program

  (zcgenout (cdr name) "#ZBEG" "MAIN=NO,TYPE=PROGRAM,"              '* )

  (go gen-minargs-and-maxargs)

 mainyes ; MAIN = YES, ALONE = NO: Main procedure of executable program

  (zcgenout (cdr name) "#ZBEG" "MAIN=YES,TYPE=PROGRAM,"             '* )
  #+XA (zcgenout nil nil "RMODE=24,AMODE=31,"                       '* )
  (when pdsize
        (zcgenout nil nil `("PDSIZE=" ,pdsize ",") '* ))
  (when vssize
        (zcgenout nil nil `("VSSIZE=" ,vssize ",") '* ))
  (when cssize
        (zcgenout nil nil `("CSSIZE=" ,cssize ",") '* ))
  (when acsize
        (zcgenout nil nil `("ACSIZE=" ,acsize ",") '* ))

  (go nameonly)

 aloneyes

  ; MAIN = YES, ALONE = YES: Eponymous loadable function
  ; MAIN = NO, ALONE = YES: Subrte internal to loadable function

  (zcgenout (cdr name) "#ZBEG" (if main "MAIN=YES,TYPE=FUNCTION,"
                                        "MAIN=NO,TYPE=FUNCTION,")   '* )

  (when zzzsubrs
   (zcgenout nil nil `("SUBRS=" ,zzzsubrs ",")                      '* )
   (incf codelen 8)
  )

 gen-minargs-and-maxargs

  (when zzzptrs
   (zcgenout nil nil `("PTRS=" ,zzzptrs ",")                        '* )
   (incf codelen 16)
  )

  (when (or zzzatoms zzzlists)
    (zcgenout nil nil `("ATOMS=" ,zzzatoms ",LISTS=" ,zzzlists ",") '* )
  )

  (if (get (car name) 'lexprarg)
   then
        (zcgenout nil nil "LEXPR=T,"                                '* )
   else
        (zcgenout nil nil `("MINARGS=" ,mina ",")                   '* )
        (zcgenout nil nil `("MAXARGS=" ,maxa ",")                   '* )
        (zcgenout nil nil `("RESTARG=" ,(if rest t nil) ",")        '* )
   endif
  )

 nameonly

  (zcgenout nil      nil `("NAME=" ,(quoted (car name)))            nil)

  (if (get (car name) 'lexprarg)

   then

    (zcgenout nil  "L"     "2,0(,1)"        "Get pointer to LEXPR arg.")
    (zcgenout nil  "L"     "2,##CDR(,2)"    "Get fixnum value thereof.")
    (zcgenout nil  "SLA"   "2,2"                    "Multiply it by 4.")
    (zcgenout nil  "LA"    `("0," ,zzzstksz "+4(2,1)")
                                            "Determine max stack size.")
    (zcgenout nil  "#ZPDS" "(0)"             "Signal error if no room.")
    (zcgenout nil  "LR"    "0,1" "Get pointer to original stack frame.")
    (zcgenout nil  "LA"    "1,4(2,1)" "Get pointer to new stack frame.")
    (zcgenout nil  "ST"    "0,0(,1)"    "Store indirect stack pointer.")

    ; Sorry, but we have to make it come out to a fullword boundary
    ; because if several base register adcons have to be inserted
    ; later on, we can't have an additional 2 bytes inserted because
    ; of inline adcons.  Thus, the 2-byte no-operation instruction.

    (zcgenout nil  "NOPR"  "0"              "Insure fullword boundary.")

    (incf codelen 32)

   else

    (zcgenout nil   "#ZPDS" zzzstksz       "Define maximum stack size.")

    (incf codelen 8)

   endif
  )

  (zcgenout nil     "STM"   `("11,12," ,pdbas "(1)")
                                       "Save stack and base registers.")
  (zcgenout nil     "ST"    `("14," ,(+ pdbas 8) "(,1)")
                                                "Save return register.")
  (zcgenout nil     "LR"    "12,15"             "Set up base register.")
;;;
;;; DROP must precede USING, else HLASM will report a warning/error.
;;;
  (zcgenout nil     "DROP"  "15"                                    nil)
  (zcgenout nil     "USING" `(,(cdr name) ",12")
                                            "Establish addressability.")
  (zcgenout nil     "LR"    "11,1"                 "Set up stack base.")

  (incf codelen 12)

;;;
;;;(zcgbase name t) ; Assign additional base registers if applicable.
;;;
;;;
;;;  (zcgenout (gensym) "EQU" `(,(cdr name) "+" ,codelen)
;;;                           "Estimated code offset so far.")
;;;

  (zcgcodck (cdr name) codelen) ; Check estimated code offset.

 )
)

;=======================================================================

;
; If this is a stand-alone function and there are any constant atoms
; or lists (usually via QUOTE) contained within, a call to intern them
; on the object list must be executed, one time only, on entry to the
; function.  For main-line programs, this is handled by ZILINIT, so we
; don't need to include code for it here.  In most cases stand-alone
; functions don't need their own atoms other than T or NIL, so this
; won't happen that often.
;

(defun zcgbegin2 (adconp &aux sasaved1 fasaved1)

 (when adconp                    ; If lists or atoms must be initialized
  (let ((l1 (gensym)) (l2 (gensym)))
   (zcgemit 0 "*" " "  " "       "Code to initialize atoms and lists.")
   (zcgemit 4 l1 "NOP" l2       "Execute once, then branch around it.")
   (zcgemit 4 () "L"   "15,ZLCSINT"          "Get address of ZILSINT.")
   (zcgemit 4 () "LA" `("1," ,(get (cdr name) 'zzzptrs))
                                       "Address the list of pointers.")
   (zcgemit 2 () "BALR" "14,15"                        "Call ZILSINT.")

   (zcgbase name nil) ; Reload base registers if necessary.

   (zcgemit 4 () "OI"   `(,l1 "+1,X'F0'")
                                     "Change NOP to branch next time.")
   (zcgemit 0 l2 "DS"  "0H"                                        nil)
   (zcgemit 0 "*" " "  " "         "End code to init atoms and lists.")
  )
 )
 ;
 ; If necessary, before any other stuff, save the current alists.
 ; This must be done if:
 ;  (1) any function arguments are used as free variables elsewhere,
 ;  (2) any tail-recursive back-branches to the beginning of this
 ;      code come from binding environments with local variables used
 ;      as free variables elsewhere.
 ; In either of the above cases, the original alists on first entry
 ; to this function must be restored upon final exit therefrom.
 ; (I.e. save special-alist if any of these are declared "special",
 ;   and save fluid-alist if any of these are declared "lexical".)
 ;

 (let (
       (free-specials (zcgbegin-any-free 'special tailrecur))
       (free-lexicals (zcgbegin-any-free 'fluid tailrecur))
      )
      (when free-specials
       (zcgemit 4 () "L"  "0,ZLCSALST"  "Get address of special ALIST.")
       (zcgemit 4 () "ST" `("0," ,stack "(,11)")      "Store on stack.")
       (setq sasaved1 (cons 'salist stack))
       (incf stack 4)
      )
      (when free-lexicals
       (zcgemit 4 () "L"  "0,ZLCFALST"  "Get address of lexical ALIST.")
       (zcgemit 4 () "ST" `("0," ,stack "(,11)")      "Store on stack.")
       (setq fasaved1 (cons 'falist stack))
       (incf stack 4)
      )
      (when (or free-specials free-lexicals)
            (zcgemit 0 (setq zzzconp (gensym)) "DS" "0H" nil)
      )
 )

 (push sasaved1 special-asaved)
 (push fasaved1 fluid-asaved)

)

;=======================================================================

;
;
; For each unbound variable referenced by the function,
; generate code to retrieve the value from the appropriate alist and
; place the pointer to the value on the stack.
;

(defun zcgbegin3 (&aux ubl (off stack))

 (when (setq ubl (cdr special-unbounds))
                              ; If any unbound SPECIAL variables
                              ; are referenced in this code

  ;
  ; Begin unbound-variable-stack-slot-initialization code.
  ;
  (zcgemit 4 () "L" "0,ZLCUNBND" "Load pointer to unbound object.")

  (dolist (var ubl)
   (putprop (cdr var) off 'pointer)
   (zcgemit 4 () "ST" `("0," ,off "(,11)")
               `("Mark unbound " ,(if (> (string-length (car var)) 24)
                                      (cdr var)
                                      (car var))))
   (setq off (+ off 4))
  )

 )

 (when (setq ubl (cdr fluid-unbounds)) ; If any unbound lexical vars
                                       ; are referenced in this code
  ;
  ; Begin unbound-variable-retrieval code.
  ;
  (zcgemit 0 "*" " " " "         "Code to retrieve lexical variables.")

  (prog (lng lnf lbl lb1 lb2 var ptr)
   (setq lng (length ubl)
         lnf (gensym)
         lbl (gensym)
         lb2 (gensym))

   (do ((l (* lng 4) (- l 256))
        (m off       (+ m 256))
       )
       ((< l 257)
        (zcgemit 6 () "XC" `(,m "(" ,l ",11)," ,m "(11)")
                                        "Set unbound pointers to zero.")
       )
       (zcgemit 6 () "XC" `(,m "(256,11)," ,m "(11)")
                                        "Set unbound pointers to zero.")
   )

   (when (> lng 1)
    (zcgemit 4 () "LA" `("0," ,lng) "Load number of unbound variables.")
   )
   (zcgemit 4 ()  "L"   "1,ZLCFALST"    "Get address of lexical alist.")
   (zcgemit 2 lbl "CR"  "1,10"            "If not all variables bound,")
   (zcgemit 2 ()  "BER" "13"              "then signal error.")
   (zcgemit 4 ()  "L"   "2,##CAR(,1)"     "Get this alist pair.")
   (zcgemit 4 ()  "L"   "3,##CAR(,2)"     "Get CAR of the pair = atom.")
 srchloop
   (setq var (car ubl))
   (setq ptr (putprop (cdr var) off 'pointer))

   (let ((loc (or (get (cdr var) 'location)
                  (putprop (cdr var) (gensym) 'location)))
        )
        (zcgemit 4 () "C" `("3," ,loc)
                 `("If variable " ,(if (> (string-length (car var)) 24)
                                       (cdr var)
                                       (car var))))
   )
   (and (eql lng 1) (go onlyone))
   (zcgemit 4 () "BNE" (setq lb1 (if (cdr ubl) (gensym) lb2)) "then...")
   (zcgemit 4 () "ICM" `("3,15," ,ptr "(11)")   "check value on stack.")
   (zcgemit 4 () "BNZ" lb2              "If already set, ignore value.")
   (zcgemit 4 () "ST" `("2," ,ptr "(,11)") "Else store value on stack.")
   (zcgemit 4 () "BCT" `("0," ,lb2)          "Continue searching alist")
   (zcgemit 4 () "B"  lnf                "unless no more vars to find.")
   (setq off (+ off 4))
   (when (setq ubl (cdr ubl))
         (zcgemit 0 lb1 "DS" "0H" nil)
         (go srchloop))
   (go aftonly)
 onlyone
   (zcgemit 4 () "BNE" lb2                                    "then...")
   (zcgemit 4 () "ST" `("2," ,ptr "(,11)")      "Store value on stack.")
   (zcgemit 4 () "B"   lnf                "Exit, no more vars to find.")
   (setq off (+ off 4))
 aftonly
   (zcgemit 4 lb2 "L"  "1,##CDR(,1)"          "Get next pair in alist.")
   (zcgemit 4  () "B"  lbl                  "Continue searching alist.")
   (zcgemit 0 lnf "DS" "0H"       "Unfound symbols have zero pointers.")
   (zcgemit 0 "*" " "  " "         "End code to retrieve lexical vars.")

  )

 )

 (setq stack off) ; At end, reset top of stack.

 ;
 ; End of unbound-variable-retrieval code
 ;
)
;=======================================================================

(defun assign-location (x)
 (putprop (cdr x) (gensym) 'location)
)
;=======================================================================

(defun quoted (a)
 (string-appendl (zilcoquo (explodec a)))
)
;=======================================================================

(defun zcgbegin-any-free (type varlist)
 (mapor #'(lambda (x) (eq (car (get (cdr x) 'bindingtype)) type))
        varlist))

