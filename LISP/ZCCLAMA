
;***********************************************************************
;*                                                                     *
;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
;*         All rights reserved.                                        *
;*                                                                     *
;***********************************************************************

;;;
;;; This function is called by ZCCEXPR to process a DEFUN arglist,
;;;                     and by ZCCEVAL to process a LAMBDA arglist.
;;;
;;; Arguments:
;;;
;;;   FUN - the symbol naming the function or lambda expression
;;;         being compiled.  The list of LAMBDA args generated by
;;;         ZILCOARG is on this symbol's property list.
;;;
;;;   LABEL - a generated label where unbindings will be done.
;;;
;;;   FORMS - the body of the function or lambda expression, which
;;;           must be scanned for declarations.
;;;
;;;   E     - the environment (this will eventually be being modified
;;;           in ZCCLAMA-BIND-IT to effect bindings)
;;;
;;; Returns:
;;;
;;;   The body with any declarations stripped off.
;;;
;;; The BINDINGS slot of the contour passed to this function will be
;;; augmented by this function to provide the correct scope for the
;;; bindings in the various INIT forms.  On entry it has no entries
;;; for any of the arguments in the lambda list; on exit it will
;;; have all of them.  Furthermore, SPECIAL declarations will be
;;; dealt with entirely in this function.
;;;

;
;***********************************************************************
;*                                                                     *
;* Change activity:                                                    *
;*                                                                     *
;* 04/25/88 - Support for determination of superfluous initializations *
;*            of PROG and &AUX variables to NIL.  This involves two    *
;*            new fields in the contour that are used to detect cases  *
;*            of a variable unconditionally being set before it is     *
;*            ever referenced.  This is an extension of, and replaces, *
;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *
;*            This also requires a new P-code form, CSETNIL, and a new *
;*            code generator module, ZCGCSNIL.                         *
;* 06/23/88 - Support for PROG and RETURN removed.                     *
;*                                                                     *
;***********************************************************************
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(include #.(zil-source-member zilmacs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun zcclama (fun label forms e
                &aux (decls ())
                     (newbody ())
                     (llvars (get fun 'parms))
                     (cec (car e))
                     (save-tempcond (zilcec-tempcond cec))
               )


;
; Set up fields in the current contour as copies so that they can be
; modified without affecting other contours.
;

 (setf (zilcec-bindings cec)
       (append (zilcec-bindings cec) nil))
 (setf (zilcec-specials cec)
       (append (zilcec-specials cec) nil))

;
; Extract declarations from the body forms and modify forms accordingly.
; If the first form is a documentation string, skip it.
;

 (do ((b (if (and (stringp (car forms)) (cdr forms)) (cdr forms) forms)
         (cdr b))
      (form)
     )
     ((null b))
     (setq form (zilcomex (car b) nil))
     (cond
      ((or (atom form); If not a declaration, finished w/body.
           (neq (car form) 'declare))
       (setq newbody (cons form (cdr b)))
       (return))
      (t              ; If it's a declaration...
       (dolist (declaration (cdr form))
               (if (consp declaration)
                   (push declaration decls)
                   (modq body
                    `(error "Illegal DECLARE subform" ,declaration))
               )))))

;
; At this point DECLS is a list of all DECLARE subforms and
; NEWBODY is the body without the declarations, with the first
; form (probably) macroexpanded already.
;

 ;
 ; ZCCLAMA-HACK-SPECIALS is being executed BEFORE the calls to
 ; ZCCLAMA-BIND-IT, in accordance with CLtL'84, so that SPECIAL
 ; declarations that are not attached to local bindings pertain to
 ; references in INIT forms contained in the lambda list.
 ;
 ; If the proposed modification to the CL standard is adopted, and
 ; all SPECIAL declarations have variable-like scope regardless of
 ; whether they are attached to local bindings, then the call to
 ; ZCCLAMA-HACK-SPECIALS must be moved to AFTER the calls to
 ; ZCCLAMA-BIND-IT.  In this case, for correct operation,
 ; we should save a pointer to ZILCEC-BINDINGS as it existed before
 ; the calls to ZCCLAMA-BIND-IT (although that may not be strictly
 ; necessary, as this code processes, by definition, variables that
 ; are not present in the lambda list).
 ;

;
;.......................................................................
;.                                                                     .
;. DECLARATION SUPPORT...NOT IMPLEMENTED YET                           .
;.                                                                     .
;. Process pervasive declarations here                                 .
;. (i.e. go through all declarations and process all of them one way   .
;.  or another except for SPECIALs, done by ZCCLAMA-HACK-SPECIALS).    .
;. Collect binding-related declarations to prepare to attach them      .
;. to bindings.                                                        .
;.                                                                     .
;.......................................................................
;

 (zcclama-hack-specials llvars decls cec)

;
; Bind each variable on the arglist.
;
; Note that initializations of &OPTIONAL and &AUX variables are done
; before their respective bindings, to follow Common LISP scoping rules.
;

 (loop for x in llvars
       with s = nil
       with l = nil
;
;.......................................................................
;.                                                                     .
;. DECLARATION SUPPORT...NOT IMPLEMENTED YET                           .
;.                                                                     .
;. Attach binding-related declarations (other than SPECIAL decls)      .
;. to bindings for each "x" here.                                      .
;. Don't forget to check global (top-level) declarations.              .
;.                                                                     .
;.......................................................................
;
      ;
      ; If this is an &OPTIONAL variable:
      ; if it has an associated "supplied-p" variable,
      ; generate code to set it to T or NIL depending on whether
      ; the optional value was supplied;
      ; evaluate the initialization form, setting the variable,
      ; and bind the &OPTIONAL variable and (if present)
      ; the "supplied-p" variable.
      ;
       when (get (cdr x) 'optional)
         do (setq s (get (cdr x) 'suppliedp)
                  l (gensym))
            (when s (modq body `(sett t ,(list s) nil)))
            (modq body `(optional ,x ,l nil nil))
            (setf (zilcec-tempcond cec) t)
            (when s (modq body `(setnil nil ,(list s) nil)))
            (zccevcom (get (cdr x) 'init) (list x) nil e)
            (putprop l t 'referenced)
            (setf (zilcec-tempcond cec) save-tempcond)
            (modq body `(label ,l nil nil))
            (zcclama-bind-it x label decls e)
            (when s (zcclama-bind-it s label decls e))
       else
      ;
      ; If this is a &KEY variable:
      ; save it for later use
      ;
       when (get (cdr x) 'key)
       collect x into keyvars
       else
      ;
      ; If this is an &AUX variable,
      ; save it for later use
      ;
       when (get (cdr x) 'aux)
       collect x into auxvars
       else
      ;
      ; If we encounter a variable which is some other variable's
      ; "supplied-p" or destructured variable, ignore it on this
      ; go-round since we handled it when we processed its "owner".
      ;
       when (get (cdr x) 'owned)
         do nil
       else
       ;
       ; Other ("normal") variables are just bound.  There is no
       ; code generated for them since their values will be on the
       ; stack at function/lambda invocation time.
       ;
         do (zcclama-bind-it x label decls e)

       finally
      ;
      ; Go through all &KEY variables, doing the following:
      ; if it has an associated "supplied-p" variable,
      ; generate code to set it to T or NIL depending on whether
      ; the key value was supplied;
      ; evaluate the initialization form, setting the variable,
      ; and bind the &KEY variable and (if present)
      ; the "supplied-p" variable.
      ;
      ; Before the first &KEY variable, generate code to initialize
      ; the variables to "unbound" and then search the &REST list for
      ; key values, filling the slots in.
      ;
        (when keyvars

              (let ((aok (zilcoadd ':allow-other-keys nil)))
                   (putprop (cdr aok) t 'real)
                   (modq body `(keys ,keyvars ,fun ,aok nil nil)))

              (loop for k in keyvars do

                  (let* ((keyword (get (cdr k) 'keyword))
                         (keysymbol (zilcoadd keyword nil)))
                        (putprop (cdr keysymbol) t 'real)
                        (putprop (cdr k) keysymbol 'keysymbol))

                  (setq s (get (cdr k) 'suppliedp)
                        l (gensym))
                  (when s (modq body `(sett t ,(list s) nil)))
                  (modq body `(optional ,k ,l nil nil))
                  (setf (zilcec-tempcond cec) t)
                  (when s (modq body `(setnil nil ,(list s) nil)))
                  (zccevcom (get (cdr k) 'init) (list k) nil e)
                  (putprop l t 'referenced)
                  (setf (zilcec-tempcond cec) save-tempcond)
                  (modq body `(label ,l nil nil))
                  (zcclama-bind-it k label decls e)
                  (when s (zcclama-bind-it s label decls e))))

      ;
      ; Go through all &AUX variables, doing the following:
      ; evaluate its initialization form, setting the variable,
      ; and bind the &AUX variable.
      ;
        (when auxvars
              (loop for a in auxvars do
                    (let ((init (get (cdr a) 'init)))
                         (cond
                          ((null init)
                           (remprop (cdr a) 'set)
                           (remprop (cdr a) 'used)
                           (remprop (cdr a) 'mustinit)
                           (modq body `(csetnil ,a ,(list a) nil))
                          )
                          (t
                           (zccevcom init (list a) nil e))))
                    (zcclama-bind-it a label decls e)))

 )

 ;
 ; Here's where to move the call to ZCCLAMA-HACK-SPECIALS if the CL
 ; standard changes.
 ;

;;; (zcclama-hack-specials llvars decls cec)


 ;
 ; Return the body without the declarations.
 ;

 newbody

)

(defun zcclama-bind-it (x label decls e
                        &aux (v (car x))
                             (cec (car e))
                             (sp (assq v special-freevars))
                       )
 ;
 ; Identify this variable with this contour.
 ;
 (putprop (cdr x) cec 'contour)
 ;
 ; Add binding to contour's list of bindings.
 ;
 (push x (zilcec-bindings cec))
 ;
 ; If the variable named by x is named in a (DECLARE (SPECIAL ...))
 ;  found in this LAMBDA expression,
 ; then add it to the contour's list of locally declared specials.
 ; Else delete it from that list.
 ;
 ; But ignore the SPECIAL declaration if the variable is globally
 ; proclaimed SPECIAL, because it's superfluous in that case.
 ;

 (unless sp
         (cond
          ((loop for d in decls
             thereis (and (eq (car d) 'special)
                          (memq v (cdr d))))
           (pushnew v (zilcec-specials cec) :test #'eq)
           (zccbind x 'special)
          )
          (t
           (setf (zilcec-specials cec)
                 (delq v (zilcec-specials cec)))))
 )
 ;
 ; If the binding is globally proclaimed SPECIAL, indicate so.
 ;
 ; If globally proclaimed special, also show that this
 ; variable is really being used, so that it will get generated.
 ;

 (when sp (zccbind x 'special))

 ;
 ; Tell the code generator about the binding.
 ;
 (modq body `(bind ,x ,label nil nil))
 ;
   ;
   ; If the variable is really a generated variable which represents a
   ; destructuring form in the lambda list, generate the code to
   ; initialize the individual destructured variables and bind them
   ; in sequence.
   ;
 (loop for dvar in (get (cdr x) 'destrvars)
       do (let ((init (get (cdr dvar) 'init)))
               (cond
                ((null init)
                 (remprop (cdr dvar) 'set)
                 (remprop (cdr dvar) 'used)
                 (remprop (cdr dvar) 'mustinit)
                 (modq body `(csetnil ,dvar ,(list dvar) nil))
                )
                (t
                 (zccevcom init (list dvar) nil e))))
          (zcclama-bind-it dvar label decls e)
 )
)


(defun zcclama-hack-specials (llvars decls cec)
 ;
 ; For each variable Z which appears in a SPECIAL declaration local
 ; to this form, where Z is NOT in the current lambda list:
 ;
 ; If Z is already in the contour's list of specials, or if Z is
 ; globally proclaimed SPECIAL, do nothing.  The SPECIAL declaration
 ; may be considered superfluous.
 ;
 ; Otherwise, add Z to the contour's list of specials, and also
 ; delete Z from the contour's list of bindings (which encompasses
 ; the bindings from contours up till now, and does not include
 ; anything from the current lambda list yet).
 ;
 ; In other words, insure that in the form
 ;
 ; (let ((a "local-value-of-a"))
 ;      (let ((b "some-other-junk"))
 ;           (declare (special a))
 ;           (foobar a)))
 ;
 ; the "a" passed to foobar is the SPECIAL a, not the LET-bound one.
 ;
 (dolist (d decls)
         (when (eq (car d) 'special)
               (dolist (x (cdr d))
                (when (and (not (assq x llvars))
                           (not (memq x (zilcec-specials cec)))
                           (not (assq x special-freevars))
                      )
                      (push x (zilcec-specials cec))
        ;
        ; (setf (zilcec-bindings cec)
        ;       (delete x (zilcec-bindings cec) :test #'eq :key #'car))
        ;
                      (when (assq x (zilcec-bindings cec))
                            (setf (zilcec-bindings cec)
                                  (loop for b in (zilcec-bindings cec)
                                        unless (eq (car b) x)
                                        collect b))))))))

