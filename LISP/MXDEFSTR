
;***********************************************************************
;*                                                                     *
;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
;*         All rights reserved.                                        *
;*                                                                     *
;***********************************************************************

;
; The macro expander for DEFSTRUCT.
;
; 12/16/88 - Fixed bug wrt not returning structure name in evaluator.
;
;
; Example: (defstruct kons kar kdr) produces...
;
; (defmacro make-kons ... ) well, see below.
;
;          (defmacro kons-kar (x) `(vref ,x 1))
;          (defmacro kons-kdr (x) `(vref ,x 2))
;          (defmacro kons-p   (x) `(let ((y ,x))
;                                       (and (structp y)
;                                            (eq (vref y 0) 'kons))))
;
; As of 01/06/88, the following syntax is supported:
;
; Minimal: (defstruct struct-name slot1 slot2 slot3 ...)
;
; Maximal: (defstruct (struct-name (conc-name ...)
;                                  (constructor ...)
;                                  (copier ...)
;                                  (eval-when ...)
;                                  {array|tree})
;                     (slot1 default-value)
;                     (slot2 default-value)
;                     (slot3 default-value)
;                     ...)
;
; Note: All default values are evaluated at MAKE-foo time.
;
; Note: The value of the EVAL-WHEN attribute defaults to (COMPILE EVAL).
;       This is so that DEFSTRUCT can be used within compiled FUNCTIONS
;       without generating load-time code to initialize the DEFSTRUCT
;       properties of the structure type name.  If you want to include
;       a DEFSTRUCT in a MODULE, so that one will be able to type in
;       structures, print them out, access them, etc., with the full
;       functionality of DEFSTRUCT, you must specify
;
;     (defstruct (<name> ... (:eval-when (compile load eval)) ...) ...)
;
;       Otherwise the structure is for internal compile-time use only,
;       and structures will be built, but they cannot be processed by
;       run-time hacking.
;
;       This includes the establishment of a default print function,
;       which can be done alternatively by assigning a function to
;       the DEFSTRUCT-PRINT-METHOD property of the symbol.
;       Similarly for DEFSTRUCT-FUNCALL-METHOD, etc.

;;;
;;; This might change somewhat, especially when structures are changed
;;; so that the zeroth element is not a symbol naming the structure type
;;; but a structure called a "structure descriptor".
;;;
;;; A "structure descriptor" is an object of type STRUCTURE-DESCRIPTOR.
;;; It is a structure whose type is STRUCTURE-DESCRIPTOR (in other words
;;; a "structure descriptor" whose name field contains the symbol
;;; STRUCTURE-DESCRIPTOR - somewhat of an infinitely recursive def'n)
;;; and has a name field (the symbol naming the type) and fields that
;;; define the slots for structures of that type.
;;;
;;; The LISP system will have exactly N structure-descriptors, one for
;;; each DEFSTRUCT-defined type, including one for STRUCTURE-DESCRIPTOR
;;; itself.
;;;
;;; ... but like I said, not for a while yet ...
;;;
;;; Instead, all structure info is stored (for now) on the property list
;;; of the name of the structure.  All the property names shall begin
;;; with the characters "DEFSTRUCT", which are documented as "reserved"
;;; (i.e. please don't use) in member $PROP of 'PROGLIB.ZIL.TEXT'.
;;;
;;; Also, the following properties are used by DEFSTRUCT:
;;;
;;; DEFSTRUCT-PROPERTIES     - holds all that DEFSTRUCT info.
;;;
;;; DEFSTRUCT-MACROS         - a list of all the macros defined.
;;;
;;; DEFSTRUCT-DOCUMENTATION  - the documentation string, if present.
;;;
;;; DEFSTRUCT-FUNCALL-METHOD - a function invoked when one tries to
;;;                            FUNCALL/APPLY a structure.  Used most
;;;                            notably by FLAVORS, for SEND.
;;;
;;; DEFSTRUCT-EVAL-METHOD    - a function invoked when one tries to
;;;                            EVAL a structure.
;;;
;;; DEFSTRUCT-PRINT-METHOD   - a function invoked when one tries to
;;;                            PRINT a structure.
;;;
;;; DEFSTRUCT-TYPEP-METHOD   - a function invoked by TYPEP when one
;;;                            asks if the type of the structure is
;;;                            so-and-so (i.e. 2-argument TYPEP).
;;;
;;;
;;; MXDEFSTR is not only the macro expander for DEFSTRUCT, but also the
;;; macro expander for the various macros generated by DEFSTRUCT, viz:
;;;
;;; (defun defstruct macro (x) (mxdefstr x))  ... Note, one arg, a list.
;;;
;;; (defmacro make-foo (&rest g00001)
;;;  (mxdefstr 'constructor 'foo nil g00001)) ... Note, 5 args.
;;;
;;; (defmacro copy-foo (g00001 &rest g00002)
;;;  (mxdefstr 'copier 'foo g00001 g00002))   ... Note, 5 args.
;;;
;;; (defmacro foo-p (g00001)
;;;  (mxdefstr 'predicate 'foo nil g00001))   ... Note, 5 args.
;;;
;;; (defmacro foo-bar (g00001)
;;;  (mxdefstr 'accessor 'foo 1 g00001))      ... Note, 5 args.
;;;
;;; (defmacro foo-baz (g00001)
;;;  (mxdefstr 'accessor 'foo 2 g00001))      ... Note, 5 args.
;;;

(eval-when (eval)
 (defun defstruct macro (x) (mxdefstr x))
)

(defmacro isetq (var val)
 `(if (null ,var)
      (setq ,var ,val)
      (zerror "Conflicting DEFSTRUCT arg specified" ,val)))

(defmacro set-defstruct-property (name prop value)
 (or (symbolp value) (zerror "I want arg 3 to be a symbol. Sorry."))
 `(progn
   (remprop ,name ,prop)
   (when ,value
         (putprop name ,value ,prop))))

;======================================================================

(defun mxdefstr (mkind &optional (sname () sname?) sparm sargs)
 (if (not sname?) ; If only 1 arg
     (mxdefstr-original mkind)
     (case mkind
           ((constructor) (mxdefstr-constructor sname sparm sargs))
           ((copier)      (mxdefstr-copier      sname sparm sargs))
           ((predicate)   (mxdefstr-predicate   sname sparm sargs))
           ((accessor)    (mxdefstr-accessor    sname sparm sargs))
           (t
            (zerror "Invalid call to MXDEFSTR" mkind)))))

(defun mxdefstr-original (original-args)
 (let (((nil type . stuff) original-args)
       (documentation))
  (and stuff (stringp (car stuff))
       (setq documentation (pop stuff)))
  (let ((name (if (atom type) type (car type)))
        (attrs (if (atom type)
                   nil
                   (mapcar #'mxdefstr-consify (cdr type))))
        (slots (mapcar #'mxdefstr-slotify stuff))
        (conc-name nil)
        (implementation nil)
        (constructor)
        (constructor? 'default)
        (boa-constructor nil)
        (boa-constructor-arglist nil)
        (copier)
        (copier? 'default)
        (predicate)
        (predicate? 'default)
        (eval-when '(compile eval)) ; <== Note the default!!!!
       )
       ;
       ; Validate the structure name.
       ;
       (cond
        ((or (not (symbolp name))
             (null name)
             (eq name t))
         (zerror "Invalid DEFSTRUCT type name" name))
        ((memq name '(
                    ;
                    ; Following list taken from TYPEP.  If you add new
                    ; built-in types to TYPEP, be sure to add them here.
                    ;
                      atom bignum character closure code
                      compiled-function cons defstruct double-float
                      fixnum float flonum funarg integer list
                      short-float single-float string struct structure
                      subr symbol vector
                     ))
         (zerror "Cannot use built-in type as DEFSTRUCT type name" name))
       )

       (loop for (attr . value) in attrs
        (case attr
         ((:conc-name conc-name)
          (cond
            ((null value)                 ; (CONC-NAME) specified
             nil)
            ((null (cdr value))           ; (CONC-NAME arg1)
             (setq conc-name
                   (case (car value)
                         ((nil "")   "") ; (CONC-NAME NIL) or
                                         ; (CONC-NAME "") specified
                         (t (concat (car value) "-")))))
            (t
             (mxdefstr-attr-error attr value))))
         ((:constructor constructor)
          (cond
           ((null value)                  ; (CONSTRUCTOR) specified
            (setq constructor? 'default))
           ((null (cdr value))
            (if (null (car value))        ; (CONSTRUCTOR NIL) specified
                (setq constructor? nil)
                (setq constructor? t      ; (CONSTRUCTOR anything)
                      constructor (car value))))
           ((null (cddr value))           ; (CONSTRUCTOR name (arglist))
            (setq constructor? t
                  constructor (car value)
                  boa-constructor t
                  boa-constructor-arglist (cadr value)))
           (t                             ; (CONSTRUCTOR arg1 arg2 ...)
            (mxdefstr-attr-error attr value))))
         ((:copier copier)
          (cond
           ((null value)                  ; (COPIER) specified
            (setq copier? 'default))
           ((not (null (cdr value)))      ; (COPIER arg1 arg2 ...)
            (mxdefstr-attr-error attr value))
           ((null (car value))            ; (COPIER NIL) specified
            (setq copier? nil))
           (t                             ; (COPIER anything)
            (setq copier? t
                  copier (car value)))))
         ((:predicate predicate)
          (cond
           ((null value)                  ; (PREDICATE) specified
            (setq predicate? 'default))
           ((not (null (cdr value)))      ; (PREDICATE arg1 arg2 ...)
            (mxdefstr-attr-error attr value))
           ((null (car value))            ; (PREDICATE NIL) specified
            (setq predicate? nil))
           (t                             ; (PREDICATE anything)
            (setq predicate? t
                  predicate (car value)))))
         ((:eval-when eval-when)
          (cond
           ((null value)                  ; (EVAL-WHEN) specified
            nil)
           ((not (null (cdr value)))      ; (EVAL-WHEN arg1 arg2 ...)
            (mxdefstr-attr-error attr value))
           (t                             ; (EVAL-WHEN anything)
            (setq eval-when (car value)))))
         ((:array array)
          (isetq implementation 'array))  ; (ARRAY anything) specified
         ((:tree tree)
          (isetq implementation 'tree))   ; (TREE anything) specified
         (t
          (warn "Unsupported DEFSTRUCT option, ignored" attr value))))
       ;;;
       ;;; Defaults for CONC-NAME, CONSTRUCTOR, COPIER, etc.
       ;;; if the corresponding keyword attributes not specified.
       ;;;
       (unless conc-name
               (setq conc-name (concat name "-")))
       (when (eq constructor? 'default)
             (setq constructor (concat "MAKE-" name)))
       (when (eq copier? 'default)
             (setq copier (concat "COPY-" name)))
       (when (eq predicate? 'default)
             (setq predicate (concat name "-P")))
       ;;;
       ;;; More checks.
       ;;;

       (and (eq implementation 'tree)
            (not (eql (length slots) 2))
            (zerror
              "DEFSTRUCT TREE implementation requires exactly 2 slots"
                   name))

       ;;;
       ;;; Build information defining the structure and hang it off
       ;;; the property list of the structure name, under the
       ;;; property name DEFSTRUCT-PROPERTIES.
       ;;;
       ;;; The value of DEFSTRUCT-PROPERTIES is an association list
       ;;; something like this:
       ;;;
       ;;; (defstruct foo bar (baz 1) (frob (make-a-frob)))
       ;;;
       ;;; results in FOO having the DEFSTRUCT-PROPERTIES property of:
       ;;;
       ;;; ((conc-name        . "FOO-")
       ;;;  (implementation   . nil)
       ;;;  (constructor      . MAKE-FOO)
       ;;;  (copier           . COPY-FOO)
       ;;;  (predicate        . FOO-P)
       ;;;  (slots            . ((:BAR BAR NIL)
       ;;;                       (:BAZ BAZ 1)
       ;;;                       (:FROB FROB (MAKE-A-FROB))))
       ;;; )
       ;;;
       ;;; etc.
       ;;;

  ;;; DEFSTRUCT-PROPERTIES

  (setf (get name 'defstruct-properties)
        `((conc-name        . ,conc-name)
          (implementation   . ,implementation)
          (constructor      . ,constructor)
          (copier           . ,copier)
          (predicate        . ,predicate)
          (slots            . ,slots)
         ))

  ;;; Remove existing macro properties, which will be reset by
  ;;; the macro definers.

  (let ((macros (remprop name 'defstruct-macros)))
       (when macros
        (warn "Redefining DEFSTRUCT for this type" name)
        (dolist (m macros)
         (remprop m 'macro))))

  (remprop name 'defstruct-constructor-macro)

  ;;; If there is no print-function defined, then set up the
  ;;; default print method.  Note that the print method is
  ;;; used only if the default (structure) type is specified.
  ;;; Otherwise there's no way for the system to know that the
  ;;; object is a "foo" made by MAKE-FOO, so what can you do?

  (setf (get name 'defstruct-print-method)
        #'mxdefstr-default-print-method)

  ;;; Set up the rest of the properties.

  (set-defstruct-property name 'defstruct-documentation  documentation)
;;(set-defstruct-property name 'defstruct-funcall-method <nothing>)
;;(set-defstruct-property name 'defstruct-eval-method    <nothing>)
;;(set-defstruct-property name 'defstruct-print-method   <nothing>)
;;(set-defstruct-property name 'defstruct-typep-method   <nothing>)

 `(progn
   (eval-when ,eval-when
    ,(when constructor?
           (mxdefstr-define-constructor name constructor
                boa-constructor boa-constructor-arglist))
    ,(when copier?
           (mxdefstr-define-copier name copier))
    ,(when predicate?
           (mxdefstr-define-predicate name predicate))
    ,.(do* ((slots slots (cdr slots))
            (index 1 (1+ index))
            z)
           ((null slots) (nreverse z))
           (push (mxdefstr-define-accessor name
                                           conc-name
                                           (car slots)
                                           index)
                 z))
   )
   ,(if (memq 'load eval-when)
        `(eval-when (load) (eval ',original-args))
        '(progn))
   (eval-when (eval) ',name)
))))

(defun mxdefstr-get (sname sprop)
 (cdr (or (assq sprop (get sname 'defstruct-properties))
          (zerror "No DEFSTRUCT properties found" sname))))

(defun mxdefstr-consify (x)
 (cond
  ((atom x) (ncons x))
  (t x)))

;
; Slots are   ((:name name value) (:name name value) ...)
;

(defun mxdefstr-slotify (x)
 (cond
  ((keywordp x)       (list x              (unkeywordify x) nil))
  ((symbolp x)        (list (keywordify x) x                nil))
  ((atom x)
   (zerror "Illegal DEFSTRUCT slot identifier" x))
  ((keywordp (car x)) (list (car x)              (unkeywordify (car x))
                                                 (cadr x)))
  ((symbolp (car x))  (list (keywordify (car x)) (car x) (cadr x)))
  (t
   (zerror "Illegal DEFSTRUCT slot identifier" x))))

(defun mxdefstr-define-constructor (name constructor
                                boa-constructor boa-constructor-arglist)
 (mxdefstr-herald name constructor)
 (setf (get name 'defstruct-constructor-macro) constructor)
 ;
 ; The constructor macro must also be made the value of the
 ; DEFSTRUCT-CONSTRUCTOR-MACRO property, used by the #S reader macro.
 ;
 (let* ((g (gensym))
        (h g)
       )
       (cond
        (boa-constructor
         (catch nil
          (setq boa-constructor-arglist
                (mxdefstr-boa-hack boa-constructor-arglist name))
          (setq h
           `(list . ,(nreverse
                       (mapcan #'(lambda (x) `(',x ,(keywordify x)))
                                  (llvars boa-constructor-arglist))))))
         (when (eq h g)
               (zerror "Error in BOA constructor argument list"
                      name constructor boa-constructor-arglist))
         `(defmacro ,constructor (&rest ,g)
           `((lambda ,',boa-constructor-arglist
                     ,(mxdefstr 'constructor ',name nil ,h))
             . ,,g))
        )
        (t
         `(defmacro ,constructor (&rest ,g)
           (mxdefstr 'constructor ',name nil ,h))))))

(defun mxdefstr-define-copier (name copier)
 (mxdefstr-herald name copier)
 (let ((g1 (gensym)) (g2 (gensym)))
      `(defmacro ,copier (,g1 &rest ,g2)
        (mxdefstr 'copier ',name ,g1 ,g2))))

(defun mxdefstr-constructor (sname sparm sargs)
 (mxdefstr-constructor-or-copier 'constructor sname sparm sargs))

(defun mxdefstr-copier (sname sparm sargs)
 (mxdefstr-constructor-or-copier 'copier sname sparm sargs))

(defun mxdefstr-constructor-or-copier (kind name sparm sargs
  &aux (maker           (mxdefstr-get name kind))
       (slots           (mxdefstr-get name 'slots))
       (implementation  (mxdefstr-get name 'implementation))
       (used-slots      nil)
       (letbinds        nil)
  )

 (do ((x sargs (cddr x))
      (z nil)
      (slot)
      (slotsym)
     )
     ((null x))
     (unless (cdr x)
             (zerror "Odd number of arguments" maker))
     (setq slot (or (assq (keywordify (car x)) slots)
                    (zerror "Undefined slot name" maker (car x))))
     ;
     ; For structure-implementation constructors, skip initializations
     ; to NIL for efficiency.
     ;
     (cond
      ((and (eq kind 'constructor)
            (null implementation)
            (null (cadr x)))
       (push (cons (car slot) nil) used-slots))
      (t
       (setq slotsym (gensym))
       (push (cons (car slot) slotsym) used-slots)
       (push (list slotsym (cadr x)) letbinds)))
 )

 (setq letbinds (nreverse letbinds))

 `(let ,letbinds

   ,(case implementation
     (array
      ;;;
      ;;; Constructor:
      ;;;
      ;;; (make-foo :bar "1" :baz "2")
      ;;; -->
      ;;; (let ((bar "1") (baz "2"))
      ;;;      (fillarray (array nil t 3)
      ;;;                 (list 'foo bar baz)))
      ;;;
      ;;; Copier:
      ;;;
      ;;; (copy-foo old-foo :bar "1" :baz "2")
      ;;; -->
      ;;; (let ((bar "1") (baz "2"))
      ;;;      (let ((g00001 (array nil t 3)))
      ;;;           (fillarray g00001 old-foo)
      ;;;           (arraycall t g00001 1 "1")
      ;;;           (arraycall t g00001 2 "2")
      ;;;           g00001))
      ;;;
      (case kind
       (constructor
        `(fillarray
          (array nil t ,(1+ (length slots)))
          (list ',name . ,(loop for x in slots
                            with temp
                            if (setq temp (assq (car x) used-slots))
                            collect (cdr temp)
                            else
                            collect (caddr x)))))
       (copier
        (let ((g (gensym)))
         `(let ((,g (array nil t ,(1+ (length slots)))))
               (fillarray ,g ,sparm)
               ,.(do ((x slots (cdr x))
                      (y 1 (1+ y))
                      (z nil)
                      (temp)
                     )
                     ((null x) (nreverse z))
                     ;;; Skip unspecified slots.
                     (when (setq temp (assq (caar x) used-slots))
                           (push `(arraycall t ,g ,y ,(cdr temp)) z))
                 )
               ,g)))
       (t nil)))

     (tree
      ;;;
      ;;; Constructor:
      ;;;
      ;;; (make-foo :bar 1 :baz 2)
      ;;; -->
      ;;; (let ((bar 1) (baz 2))
      ;;;      (cons bar baz))
      ;;;
      ;;; Copier:
      ;;;
      ;;; (copy-foo oldfoo)
      ;;; -->
      ;;; (cons (zcar oldfoo) (cdr oldfoo))
      ;;;
      ;;; (copy-foo oldfoo :bar 1 :baz 2)
      ;;; -->
      ;;; (cons 1 2)
      ;;;
      (case kind
       (constructor
        `(cons . ,(loop for x in slots
                        with temp
                        if (setq temp (assq (car x) used-slots))
                        collect (cdr temp)
                        else
                        collect (caddr x))))
       (copier
        (let* ((g nil)
               (code
               `(cons . ,(do ((x slots (cdr x))
                              (y 1 (1+ y))
                              (z nil)
                              (temp)
                             )
                             ((null x) (nreverse z))
                             (push
                              (if (setq temp (assq (caar x) used-slots))
                               (cdr temp)
                               `(,(mxdefstr-tree-access-function name y)
                                 ,(or g (setq g (gensym)))))
                              z)))))
              (if g `(let ((,g ,sparm)) ,code) code)))

       (t nil)))

     (otherwise
      ;;;
      ;;; Constructor:
      ;;;
      ;;; (make-foo :bar 1 :baz 2)
      ;;; -->
      ;;; (let ((bar 1) (baz 2))
      ;;;      (let ((g00001 (mkstruct 3 'foo)))
      ;;;            (vset g00001 1 bar)
      ;;;            (vset g00001 2 baz)
      ;;;            g00001))
      ;;;
      ;;;
      ;;; Copier:
      ;;;
      ;;; (copy-foo old-foo :bar 1 :baz 2)
      ;;; -->
      ;;; (let ((bar 1) (baz 2))
      ;;;      (let ((g00001 (vcopy old-foo)))
      ;;;            (vset g00001 1 bar)
      ;;;            (vset g00001 2 baz)
      ;;;            g00001))
      ;;;
      (case kind
            (constructor
             (let ((g (gensym)))
               `(let ((,g (mkstruct ,(1+ (length slots)) ',name)))
                     ,.(do ((x slots (cdr x))
                            (y 1 (1+ y))
                            (z nil)
                            (val)
                            (temp)
                           )
                           ((null x) (nreverse z))
                           (setq val
                            (if (setq temp (assq (caar x) used-slots))
                                (cdr temp)
                                (caddar x)))
                           ;;; Skip vsets to NIL: MKSTRUCT puts NIL in.
                           (unless (null val)
                                   (push `(vset ,g ,y ,val) z))
                       )
                       ,g)))
            (copier
             (let ((g (gensym)))
               `(let ((,g (vcopy ,sparm)))
                     ,.(do ((x slots (cdr x))
                            (y 1 (1+ y))
                            (z nil)
                            (temp)
                           )
                           ((null x) (nreverse z))
                           ;;; Skip unspecified slots.
                           (when (setq temp (assq (caar x) used-slots))
                                 (push `(vset ,g ,y ,(cdr temp)) z))
                       )
                       ,g)))
            (t nil))))))


(defun mxdefstr-define-accessor (name conc-name slot index)
 (let ((accessor (concat conc-name (cadr slot)))
       (g (gensym)))
      (mxdefstr-herald name accessor)
      `(defmacro ,accessor (,g)
        (mxdefstr 'accessor ',name ',index ,g))))

(defun mxdefstr-accessor (name index sarg)
 (let ((implementation (mxdefstr-get name 'implementation)))
  (case implementation

   (array
    `(arraycall t ,sarg ,index))

   (tree
    `(,(mxdefstr-tree-access-function name index) ,sarg))

   (t
    `(vref ,sarg ,index)))))


(defun mxdefstr-tree-access-function (name i)
 (case i
       (1 'zcar)
       (2 'cdr)
       (t (zerror "Invalid index for DEFSTRUCT tree accessor" name i))))

(defun mxdefstr-define-predicate (name predicate)
 (let ((g (gensym)))
      (mxdefstr-herald name predicate)
      `(defmacro ,predicate (,g)
        (mxdefstr 'predicate ',name nil ,g))))

(defun mxdefstr-predicate (name ignore sarg)
 (let ((implementation (mxdefstr-get name 'implementation)))
  (case implementation

   (array
    (let ((y (gensym)))
         `(let ((,y ,sarg))
               (and (arrayp ,y)
                    (eql (array-\#-dims ,y) 1)
                    (not (zerop (array-dimension-n 1 ,y)))
                    (eq (arraycall t ,y 0) ',name)))))

   (tree
    `(consp ,sarg))

   (t
;;;;`(typep ,sarg ',name) ; Sorry, may have to do it this way to
;;;;;;;;;;;;;;;;;;;;;;;;;;; support INCLUDE option some day.
    (let ((y (gensym)))
         `(let ((y ,sarg))
               (and (structp y) (eq (vref y 0) ',name))))
))))


(defun mxdefstr-herald (name x)
 (if (memq x (get name 'defstruct-macros))
     (zerror "Duplicate DEFSTRUCT definition generated" x)
     (push x (get name 'defstruct-macros)))
 (when (< (msglevel) 1)
  (cterpri)
  (princ "DEFSTRUCT: Defining macro ")
  (princ x)
  (terpri)
 )
)

(declare (special *print-escape* *print-level* *print-length*))

(defmacro low-level-print (a &key stream escape level)
;;;
;`(write ,a :stream ,stream :escape ,escape :level ,level)
;;;
 (let ((ga (gensym))
       (gs (gensym))
      )
      `(let (
             (,ga ,a)
             (,gs ,stream)
             (*print-level* ,level)
            )
            (declare (special *print-level*))
            (if ,escape
                (prin1 ,ga ,gs)
                (princ ,ga ,gs)))))

(defun mxdefstr-default-print-method
 (a                     ; The object to be printed.
  &optional
  (f nil)               ; The file to print it on.
;                         Should really default to *standard-output*.
  (d 0)                 ; The current print depth.
  (s *print-escape*)    ; Slashification?
  &aux
  (level *print-level*)
 )
 (princ "#S" f)
 (low-level-print (mxdefstr-default-print-structure-list a)
                  :stream f
                  :escape s
                  :level (if level (- (1+ level) d)))
 a
)

(defun mxdefstr-default-print-structure-list (a)
 (let* ((name (vref a 0))
        (slots (mxdefstr-get name 'slots))
       )
       (cons name (do ((slot slots (cdr slot))
                       (i 1 (1+ i))
                       (z nil)
                      )
                      ((null slot) (nreverse z))
                      (push (caar slot) z)
                      (push (vref a i) z)))))

(defun mxdefstr-attr-error (attr value)
 (zerror "Too many operands specified for this attribute"
        (cons attr value)))

(eval-when ()
#.(defvar lambda-list-keywords
          '(&optional &rest &body &aux &key &allow-other-keys))
)

(defun mxdefstr-boa-hack (bvl name)
 (prog (z mode c c1 c2 c3 c3?)
  loop
       (when (atom bvl)
             (when bvl
                   (mxdefstr-get-initializer bvl name)) ; Check validity
             (return (nreconc z bvl)))
       (setq c (zcar bvl))    ; An argument spec from the lambda-list.
       (cond
        ((llkeywdp c)       ; If it's a lambda list keyword
         (setq mode
               (car (or (memq c '#.lambda-list-keywords)
                        (zerror "Unrecognized lambda list keyword" c))))
         (push mode z)
         (setq bvl (cdr bvl))
         (go loop)
        )
        (t
         (case mode
               ((nil)          (go required-arg))
               ((&optional)    (go optional-arg))
               ((&rest &body)  (go rest-arg))
               ((&aux)         (go aux-arg))
               ((&key)         (go key-arg))
               (t (zerror "Lambda list args following keyword" mode)))
        )
       )

 required-arg

       (push (mxdefstr-boa-hack c name) z)
       (setq bvl (cdr bvl))
       (go loop)

 optional-arg

       (cond
        ((atom c)
         (setq c1 c
               c2 (mxdefstr-get-initializer c1 name)
               c3? nil
               c3 nil))
        ((null (cdr c))
         (setq c1 (car c)
               c2 (mxdefstr-get-initializer c1 name)
               c3? nil
               c3 nil))
        (t
         (setq c1 (car c)
               c2 (cadr c)
               c3? (cddr c)
               c3 (caddr c))))
       (if c3?
           (setq c `(,(mxdefstr-boa-hack c1 name)
                     ,c2
                     ,(mxdefstr-boa-hack c3 name)
                    ))
           (setq c `(,(mxdefstr-boa-hack c1 name)
                     ,c2
                    ))
       )
       (push c z)
       (setq bvl (cdr bvl))
       (go loop)

 aux-arg

       (cond
        ((atom c)
         (setq c1 c
        ;;;;;; c2 (mxdefstr-get-initializer c1 name)
               c2 nil))
        ((null (cdr c))
         (setq c1 (car c)
        ;;;;;; c2 (mxdefstr-get-initializer c1 name)
               c2 nil))
        (t
         (setq c1 (car c)
               c2 (cadr c))))
       (push `(,(mxdefstr-boa-hack c1 name) ,c2) z)
       (setq bvl (cdr bvl))
       (go loop)

 rest-arg

       (push (mxdefstr-boa-hack c name) z)
       (setq bvl (cdr bvl))
       (go loop)

 key-arg

 ;
 ; Format of a &key entry:
 ;
 ; var
 ; (var)
 ; (var initform)
 ; (var initform suppliedp)
 ; ((:var var))
 ; ((:var var) initform)
 ; ((:var var) initform suppliedp)
 ;

       (let (
             (var)
             (variable)
             (keyword)
             (initform)
             (suppliedp)
             (suppliedp?)
            )
            (cond
             ((atom c)
              (setq variable c
                    keyword (keywordify variable)
                    initform (mxdefstr-get-initializer variable name)
                    suppliedp? nil
                    suppliedp nil))
             ((atom (setq var (car c)))
              (setq variable var
                    keyword (keywordify variable)
                    initform (mxdefstr-get-initializer variable name)
                    suppliedp? nil
                    suppliedp (caddr c)))
             ((or (null (cdr var))
                  (cddr var))
              (zerror "Invalid &KEY keyword syntax" c))
             (t
              (setq variable (cadr var)
                    keyword (car var)
                    initform (if (cdr c)
                              (cadr c)
                              (mxdefstr-get-initializer variable name))
                    suppliedp? (cddr c)
                    suppliedp (caddr c)))
            )
            (push `((,keyword ,(mxdefstr-boa-hack variable name))
                    ,initform
                    ,.(if suppliedp?
                          (list (mxdefstr-boa-hack suppliedp name))
                          nil))
                   z)
       )
       (setq bvl (cdr bvl))
       (go loop)

 ))

(defun mxdefstr-get-initializer (key name)
 (unless (atom key)
         (zerror "Destructuring not permitted in this BOA argument slot"
                name key))
 (loop for slot in (mxdefstr-get name 'slots)
       when (eq (cadr slot) key)
       return (caddr slot)
       finally (zerror "Argument does not match any slot name" name key)
 ))
