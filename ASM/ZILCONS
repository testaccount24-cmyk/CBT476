         TITLE 'ZILCONS (ZIL 1.3) - CONS PLUS GARBAGE COLLECTOR'
***********************************************************************
*                                                                     *
* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *
*                     All rights reserved.                            *
*                                                                     *
***********************************************************************
*                                                                     *
* Change activity:                                                    *
*                                                                     *
* 02/10/90 - SEB1525 - Fixed bug when lots of memory asked for.       *
*                                                                     *
***********************************************************************
*                                                                     *
* THIS SOURCE MODULE CONTAINS CONDITIONAL ASSEMBLY CODE WHICH         *
* UTILIZES THE IBM SYSTEM/370 VECTOR FACILITY FOR ENHANCED            *
* PERFORMANCE.  SUCH CODE IS ACTIVATED VIA INVOCATION OF THE          *
* ASSEMBLER WITH THE FOLLOWING SPECIFIED:                             *
*                                                                     *
* 'SYSPARM(VECTOR)'                                                   *
*                                                                     *
***********************************************************************
         TITLE 'ZILCONS (ZIL 1.3) - INTERNAL MACROS'
         MACRO
&SYM     MARK  &REG
.*
.* THIS MACRO SETS THE GARBAGE COLLECTION MARK ON IN THE CELL POINTED
.* TO BY THE SPECIFIED REGISTER.
.*
&SYM     OI    3(&REG),B'00000001'  SET GARBAGE COLLECTION MARK
         MEND
         EJECT
         MACRO
&SYM     MARK2 &REG
.*
.* THIS MACRO SETS THE TEMPORARY COLLECTION MARK ON IN THE CELL POINTED
.* TO BY THE SPECIFIED REGISTER.  THIS IS USED IN THE POINTER-REVERSAL
.* ALGORITHM TO PREVENT DOUBLE SCANNING OF CIRCULAR AND STRANGE LISTS.
.*
&SYM     OI    3(&REG),B'00000010'  SET TEMP COLLECTION MARK
         MEND
         EJECT
         MACRO
&SYM     UNMK  &REG
.*
.* THIS MACRO SETS THE GARBAGE COLLECTION MARKS OFF IN THE CELL POINTED
.* TO BY THE SPECIFIED REGISTER.
.*
&SYM     NI    3(&REG),B'11111100'  SET GARBAGE COLLECTION MARKS OFF
         MEND
         EJECT
         MACRO
&SYM     IFMK1 &REG,&YES=,&NO=
.*
.* THIS MACRO TESTS ONE GARBAGE COLLECTION MARK IN THE CELL POINTED
.* TO BY THE SPECIFIED REGISTER.
.* IT IS USED ONLY IN THE POINTER-REVERSAL ALGORITHM WHEN CLIMBING
.* BACK UP A CHAIN OF REVERSED POINTERS.
.*
&SYM     TM    3(&REG),B'00000001'  TEST GARBAGE COLLECTION MARK
         AIF   ('&YES' EQ '').NOYES
         BO    &YES                 IF MARKED, BRANCH TO LABEL
         MEXIT
.NOYES   ANOP
         BZ    &NO                  IF NOT MARKED, BRANCH TO LABEL
         MEND
         EJECT
         MACRO
&SYM     IFMK  &REG,&YES=,&NO=
.*
.* THIS MACRO TESTS TWO GARBAGE COLLECTION MARKS IN THE CELL POINTED
.* TO BY THE SPECIFIED REGISTER.
.*
&SYM     TM    3(&REG),B'00000011'  TEST GARBAGE COLLECTION MARKS
         AIF   ('&YES' EQ '').NOYES
         BNZ   &YES                 IF MARKED, BRANCH TO LABEL
         MEXIT
.NOYES   ANOP
         BZ    &NO                  IF NOT MARKED, BRANCH TO LABEL
         MEND
         EJECT
         MACRO
&SYM     GCDR  &VALREG,&CONSREG
.*
.* THIS MACRO LOADS THE FIRST SPECIFIED REGISTER WITH THE CONTENTS OF
.* THE "CDR" FIELD OF THE SECOND SPECIFIED REGISTER.
.*
&SYM     L     &VALREG,##CDR(,&CONSREG)     (SETQ REG1 (CDR REG2))
         MEND
         EJECT
         MACRO
&SYM     GCAR  &VALREG,&CONSREG
.*
.* THIS MACRO LOADS THE FIRST SPECIFIED REGISTER WITH THE CONTENTS OF
.* THE "CAR" FIELD OF THE SECOND SPECIFIED REGISTER.
.*
.* NOTE THAT THIS IS NOT A SIMPLE LOAD OPERATION.  THE "CAR" FIELD
.* MAY HAVE HAD GARBAGE COLLECTION MARKS SET IN IT, AND THEREFORE
.* WE MUST "AND" OUT THE MARKS TO PRESERVE A VALID ADDRESS.
.*
&SYM     L     &VALREG,##CAR(,&CONSREG)     (SETQ REG1 (CAR REG2))
         N     &VALREG,=X'FFFFFFFC'         REMOVE GC MARK IF ANY
         MEND
         MACRO
&SYM     RCDR  &CONSREG,&VALREG
.*
.* THIS MACRO DOES A "RPLACD" OPERATION.  THE CONTENTS OF THE SECOND
.* SPECIFIED REGISTER ARE STORED INTO THE "CDR" FIELD OF THE CELL
.* POINTED TO BY THE FIRST SPECIFIED REGISTER.
.*
&SYM     ST    &VALREG,##CDR(,&CONSREG)      (RPLACD REG1 REG2)
         MEND
         EJECT
         MACRO
&SYM     RCAR  &CONSREG,&VALREG
.*
.* THIS MACRO DOES A "RPLACA" OPERATION.  THE CONTENTS OF THE SECOND
.* SPECIFIED REGISTER ARE STORED INTO THE "CAR" FIELD OF THE CELL
.* POINTED TO BY THE FIRST SPECIFIED REGISTER.
.*
.* NOTE THAT THIS IS NOT A SIMPLE STORE OPERATION.  THE "CAR" FIELD
.* MAY HAVE HAD GARBAGE COLLECTION MARKS SET IN IT, AND THEREFORE
.* WE MUST SET THE FIELD IN SUCH A WAY THAT THESE MARKS ARE PRESERVED.
.*
.* NOTE USE OF REGISTER 0 AS A WORK REGISTER.
.*
&SYM     LA    #0,3
         N     #0,##CAR(,&CONSREG)   GET GC MARKS INTO REG
         OR    #0,&VALREG            COMBINE WITH ARGUMENT REG
         ST    #0,##CAR(,&CONSREG)   (RPLACA REG1 REG2)
         MEND
         EJECT
         MACRO
&SYM     RCHK  &REG,&LBL
.*
.* THIS MACRO IMPLEMENTS A "RANGE CHECK" TO SEE IF THE CELL POINTED
.* TO BY THE SPECIFIED REGISTER LIES WITHIN CONS SPACE (THE FREE LIST).
.* IF IT DOES NOT (MEANING THAT IT MAY NOT BE MARKED), A BRANCH TO
.* THE SPECIFIED LABEL IS DONE.  THE LABEL MAY BE A PARENTHESIZED
.* REGISTER NUMBER, IN WHICH CASE A BRANCH TO THE ADDRESS IN THE
.* REGISTER IS EFFECTED.
.*
.* 11/84 - CHECKING IS NOW DONE TO VERIFY THAT THE REGISTER
.* REFERENCES A CELL ON A DOUBLEWORD BOUNDARY.  THE READ FUNCTION
.* PUTS SUCH NON-ALIGNED QUANTITIES ON THE STACK.
.* THIS IS IMPORTANT IF THE ARCHITECTURE LEAVES OPEN THE RISK
.* OF NUMERIC QUANTITIES WHICH MAY FALL INTO THE CONS SPACE RANGE.
.*
.* 07/85 - THAT CHECKING HAS BEEN TAKEN OUT, SINCE WE CAN'T
.* GUARANTEE A SIMILAR CONSISTENCY FOR POINTERS INTO VECTOR/STRING
.* SPACE.  INSTEAD, ALL ZIL CODE MUST PROMISE NOT TO PUT VALUES ON
.* THE STACK THAT ARE EITHER ABSOLUTE NUMERIC VALUES OR POINTERS
.* INTO ONE OF THE GCABLE SPACES THAT DON'T POINT TO THE BEGINNING
.* OF AN OBJECT.  THE ONLY CULPRIT WAS "READ", AND WE FIXED HIM.
.*
.* IN ANY CASE, THIS MACRO NOW GENERATES A BAL TO THE ROUTINE THAT
.* DOES THE CHECKING FOR BOTH SPACES, AND DOES A RELOCATION PLUS
.* FORWARDING IF THE OBJECT ACTUALLY IS IN VECTOR/STRING SPACE.
.*
         AIF   ('&REG' EQ '#0' OR '&REG' EQ '0').SKIPLR
         LR    #0,&REG               GET OBJECT TO BE TESTED
.SKIPLR  ANOP
         #BAS  #14,RCHECK            CALL RANGE CHECKER
         AIF   ('&LBL'(1,1) EQ '(').BREG
         B     &LBL                  BRANCH WHEN NOT IN CONS SPACE
         AGO   .MEND
.BREG    ANOP
         BR    &LBL(1)               BRANCH WHEN NOT IN CONS SPACE
         NOPR  0                     FILLER
.MEND    MEND
         EJECT
         MACRO
&SYM     MARKOBJ &OBJECT
.*
.* THIS MACRO INVOKES THE GC MARKING ROUTINE ON A SINGLE OBJECT WHOSE
.* POINTER IS CONTAINED IN THE COMMON AREA.  THIS RESULTS IN ALL THE
.* LISP OBJECTS POINTED TO BY THAT OBJECT BEING MARKED.
.*
         LA    #15,&OBJECT         POINT TO COMMON AREA OBJECT
         L     #1,0(,#15)          GET ADDRESS OF IT
         #BAS  #14,MARKLIST        INVOKE MAIN GC ROUTINE ON IT
         MEND
         TITLE 'ZILCONS - ZIL 1.3 CONS PROCESSOR AND GARBAGE COLLECTOR'
         GBLB  &ZILXA,&ZILVF
         #ZSYS
ZILCONS  CSECT ,
         USING CONS,#15
         USING ZLCOMMON,#13
         SPACE
***********************************************************************
*
* CONS TAKES TWO ARGUMENTS.  NO STACK SPACE IS REQUIRED.
*
* REG 1 CONTAINS THE CAR-TO-BE, REG 2 THE CDR-TO-BE.
*
* REG 15 RETURNS WITH THE NEWLY ALLOCATED CELL.  IF NO CELLS ARE
* AVAILABLE A GARBAGE COLLECTION IS DONE, EXCEPT WHEN CONS IS BEING
* CALLED BY ZILINIT TO PERFORM INITIALIZATION FUNCTIONS - IN THIS
* CASE REG 15 IS SET TO ZERO TO INDICATE NOT ENOUGH CELLS AVAILABLE
* FOR INITIALIZATION.
*
* THE FREE LIST IS ACCESSED SEQUENTIALLY UNTIL A GARBAGE COLLECTION
* IS DONE, AT WHICH POINT IT IS CONVERTED TO A CHAINED STRUCTURE AND
* THE ENTRY POINT FOR CONS (STORED IN COMMON) IS ALTERED TO POINT TO
* THE CODE WHICH ACCESSES THE NEW STRUCTURE.
*
* BE CAREFUL WITH REG 15!!! IT IS THE BASE REGISTER AS WELL AS RETURN.
*
* NOTE THAT REG 12 AT ENTRY IS THE BASE REGISTER FOR THE FUNCTION
* THAT INVOKED CONS.  THIS IS USED BY THE GARBAGE COLLECTOR TO
* VERIFY THE CURRENT STACK POINTER ENVIRONMENT.
*
***********************************************************************
         EJECT
         #ZEQU
         EJECT
         #ZCOM
         EJECT
         #ZHDR
         EJECT
ZILCONS  CSECT ,
         SPACE
***********************************************************************
*
* VIRGIN ENTRY POINT - NO GARBAGE COLLECTIONS HAVE OCCURRED
*
***********************************************************************
         SPACE
CONS     DS    0H
         CR    #9,#10              IF END OF FREE LIST
         BNL   GARBCOLL-CONS(,#15) THEN DO GARBAGE COLLECTION
         LR    #15,#9              ALLOCATE CURRENT CELL IN FREE LIST
         LA    #9,8(,#9)           ELSE GET NEXT SEQUENTIAL LIST
         STM   #1,#2,##CAR(#15)    STORE CAR AND CDR IN NEW CELL
         BR    #14                 RETURN TO CALLER
         SPACE 2
***********************************************************************
*
* ENTRY POINT AFTER GARBAGE COLLECTION HAS ORDERED THE FREE LIST
*
***********************************************************************
         SPACE
GCCONS   DS    0H
         LTR   #9,#9               IF FREE LIST IS EXHAUSTED
         BZ    GARBCOLL-GCCONS(,#15) THEN DO GARBAGE COLLECTION
         LR    #15,#9              ALLOCATE CURRENT CELL IN FREE LIST
         L     #9,##CDR(,#9)       GET NEXT CELL IN FREE LIST
         STM   #1,#2,##CAR(#15)    STORE CAR AND CDR IN NEW CELL
         BR    #14                 RETURN TO CALLER
         EJECT
***********************************************************************
*
* GARBAGE COLLECTION REQUIRED - NO MORE FREE CELLS
*
***********************************************************************
         SPACE
GARBCOLL DS    0H                  GARBAGE COLLECTION
         XR    #15,#15             PRELIMINARILY SET RETURN TO ZEROES
         TM    ZLCGCFLG,ZLCGCINT   IF CONS CALLED BY ZILINIT
         BOR   #14                 THEN RETURN WITH VALUE OF ZEROES
*                                   TO INDICATE INITIALIZATION FAILURE
         BALR  #15,0               ELSE BOOTSTRAP ADDRESSABILITY
         USING GCBASE,#15
GCBASE   EQU   *
         STM   #0,#14,ZSAVREGS     SAVE ALL REGISTERS BUT USELESS #15
         LR    #12,#15             SET NEW BASE REGISTER
         DROP  #15
         USING GCBASE,#12
         SPACE
***********************************************************************
*
* THE ALGORITHM USED HERE IS BASICALLY FLOYD'S MARK-AND-SWEEP
* NON-RECURSIVE POINTER-CLOBBERING TECHNIQUE AS ILLUSTRATED IN
* "LISP" (FIRST EDITION), BY WINSTON AND HORN, PAGE 117.
*
* SOME MODIFICATION HAD TO BE MADE TO SUPPORT THE COLLECTING OF
* PROPERTY LISTS OF ATOMS, AS WELL AS CLOSURES.  THIS IS DONE
* BASICALLY BY TREATING SYMBOLS AND CLOSURES AS EQUIVALENT TO CONSES
* OF SOME NON-LIST ENTITY (WHICH IS THE PRINT NAME OR COMPILED CODE
* OBJECT) WITH A PROPERTY LIST OR ALIST, SO THAT THE SYMBOL OR
* CLOSURE GETS TO PARTICIPATE IN THE COLLECTION AS IF IT WERE A LIST.
*
* NOTE THAT IN-LINE LISTS MAY NOT PARTICIPATE IN THE COLLECTION
* PROCESS.  THIS MEANS THAT IF AN IN-LINE LIST WAS MODIFIED AT RUN
* TIME, THE OBJECTS IN CONS SPACE THAT ARE REFERENCED ONLY BY IN-LINE
* STRUCTURES WILL NOT BE COLLECTED!  THIS CAN CAUSE EGREGIOUS FAILURES
* AND IT IS THEREFORE STRESSED THAT IN-LINE LISTS, CREATED BY COMPILING
* THE CONSTRUCT '(FORM FORM FORM ...), SHOULD NOT BE USED IF THERE IS
* ANY CHANCE THAT THEY MIGHT BE MODIFIED DURING EXECUTION OF THE CODE.
*
* AN EXCEPTION TO THIS IS THAT IN-LINE ATOMS DO PARTICIPATE IN THE
* GARBAGE COLLECTION PROCESS, SINCE THEIR PROPERTY LISTS MUST BE
* COLLECTED.  SINCE ALL IN-LINE ATOMS ARE INTERNED ON THE OBLIST, IT
* IS SUFFICIENT TO GO THROUGH THE OBLIST AND PROCESS ALL ATOMS
* THEREON TO EFFECT THIS.  THE PRINT NAMES AND OTHER PIECES OF ATOMS
* THAT RESIDE IN COMPILED CODE CANNOT BE COLLECTED; HOWEVER, SINCE
* THESE GENERALLY DO NOT POINT TO OTHER LISP OBJECTS, THIS NORMALLY
* PRESENTS NO PROBLEM UNLESS YOU DO "ILLEGAL" THINGS TO ATOMS.
*
* THE ALGORITHM ALSO HAD TO BE SLIGHTLY MODIFIED TO HANDLE LISTS WITH
* ELEMENTS THAT POINT TO THEMSELVES (AN UNUSUAL CASE, ADMITTEDLY).
* TO DO THIS, WE HAD TO GO BACK TO THE USE OF TWO MARKING BITS.  NOTE
* THAT IT IS NOT NECESSARY TO UNDO BOTH OF THE MARKING BITS, SINCE
* THE SWEEP PHASE WILL RESET BOTH OF THEM.
*
* THE MARKING BITS ARE THE TWO LOW-ORDER BITS OF THE CAR CELL, WHICH
* ARE ALWAYS AVAILABLE SINCE ALL POINTERS ARE GUARANTEED TO BE AT
* LEAST ON A FULLWORD BOUNDARY, MAKING THE ADDRESSES CONTAINED
* THEREIN END IN TWO ZERO BITS.
*
* OBJECTS IN VECTOR/STRING SPACE ARE TREATED SPECIALLY (THEY ARE
* HANDLED AS NON-POINTERS IN THE MAIN MARKING ALGORITHM) BY THE
* COMPONENT OF THE GC WHICH DOES RELOCATION AND FORWARDING.  THE
* FINAL PHASE OF THE GC (BEFORE THE SWEEP) IS THE COLLECTION OF
* OBJECTS IN VECTOR/STRING SPACE THAT POINT TO OTHER OBJECTS, AND
* SWAPPING OF THE OLD AND NEW SPACES.
*
* SPECIAL THANKS TO GEORGE J. CARRETTE OF NIL AND LMI FAME FOR HIS
* TECHNICAL ASSISTANCE AND ENCOURAGEMENT WRT THE RELOCATING GC.
*
***********************************************************************
         SPACE
***********************************************************************
*
* REGISTER USAGE IN THIS ROUTINE IS AS FOLLOWS:
*
* #0  - WORK REGISTER
* #1  - TO PASS OBJECTS TO INTERNAL GC SUBROUTINES
* #2  - WORK REGISTER
* #3  - LOWER BOUND OF CONS SPACE
* #4  - UPPER BOUND OF CONS SPACE
* #5  - THE "N" VARIABLE FROM FLOYD'S ALGORITHM AS IN WINSTON & HORN
* #6  - THE "P" VARIABLE FROM FLOYD'S ALGORITHM AS IN WINSTON & HORN
* #7  - THE "Q" VARIABLE FROM FLOYD'S ALGORITHM AS IN WINSTON & HORN
* #8  - THE ATOM T, AS IN THE REAL WORLD
* #9  - USED TO REBUILD THE FREE LIST
* #10 - THE ATOM NIL, AS IN THE REAL WORLD
* #11 - POSSIBLY BUT NOT NECESSARILY USED FOR STACK PROCESSING
* #12 - LOCAL BASE REGISTER FOR THIS ROUTINE
* #13 - THE COMMON AREA, AS IN THE REAL WORLD
* #14 - BRANCH AND LINK REGISTER FOR GC SUBROUTINES
* #15 - POINTER TO PLACES TO STORE RELOCATED-OBJECT POINTERS
*
***********************************************************************
         SPACE
***********************************************************************
*                                                                     *
* SEQUENCE OF PROCESSING IS AS FOLLOWS:                               *
*                                                                     *
* (1) GC THE READER MACRO CHAIN.  NOTE THAT NO OTHER LISP OBJECTS     *
*     MAY POINT TO READER MACRO CELLS, SINCE THEY DO NOT HAVE         *
*     STANDARD TYPE CONFIGURATIONS INSIDE THEM.                       *
*                                                                     *
* (2) GC GLOBAL OBJECTS POINTED TO BY THE COMMON AREA.  THESE INCLUDE *
*     * THE OBLIST AND ALL ATOMS THEREON, INCLUDING THEIR PLISTS.     *
*     * THE ALISTS AND THE OBJECTS TO WHICH THEY POINT.               *
*     * THE GENSYM PREFIX, IF ONE IS IN USE.                          *
*                                                                     *
* (2.5) GC THE OBJECTS POINTED TO BY THE CELLS OF THE T AND NIL       *
*       SYMBOLS.                                                      *
*                                                                     *
* (3) GC THE INLINE COMPILED CODE OBJECTS POINTED TO BY THE HEADERS   *
*     OF THE LOADED COMPILED CODE MODULES REFERENCED BY THE COMMON    *
*     "MASTER VECTOR" OF INLINE COMPILED CODE HEADERS.                *
*                                                                     *
* (4) GC THE ATOMS REFERENCED BY THE FILE BLOCK CHAINS.               *
*                                                                     *
* (5) GC OVER ALL VALID THINGS POINTED TO BY THE CURRENT STACK.       *
*     HOPEFULLY REGISTER 0 AT ENTRY TO CONS POINTED TO THE CURRENT    *
*     STACK OFFSET.  IF NOT, WE'LL TRY TO APPROXIMATE IT.             *
*                                                                     *
* (6) GC THE THINGS POINTED TO BY REGISTERS 1 AND 2 AT ENTRY TO CONS  *
*     (WHICH WE WERE TRYING TO USE IN THE FIRST PLACE).               *
*                                                                     *
* (7) THEN, GO OVER THE RELOCATED (NEW) VECTOR/STRING SPACE,          *
*     COLLECTING EVEN MORE OBJECTS.  WHEN THIS IS FINISHED,           *
*     SWAP THE OLD AND NEW VECTOR/STRING SPACES, FOR ALL OBJECTS      *
*     THEREIN WILL HAVE BEEN RELOCATED.                               *
*                                                                     *
* (8) GO THROUGH THE OBLIST HASH ARRAY AND RELOCATE ALL THE NONZERO   *
*     SYMBOL POINTERS THEREIN.  SINCE ALL OF SYMBOLS HAVE ALREADY     *
*     BEEN COLLECTED (WHEN THE OBLIST ITSELF WAS COLLECTED), WE KNOW  *
*     THEY'VE ALL BEEN FORWARDED, SO JUST LOAD THE FORWARDING PTRS.   *
*                                                                     *
* (9) WHEN ALL IS DONE, GO THROUGH THE FREE LIST AND CHAIN ALL THE    *
*     UNMARKED CELLS INTO A LINKED LIST.  THIS WILL BE THE NEW CONS   *
*     FREE LIST.  CHANGE THE ENTRY POINT OF CONS TO REFLECT THE NEW   *
*     FREE LIST ACCESS TECHNIQUE.                                     *
*                                                                     *
*(10) IF STILL NO FREE CELLS ARE AVAILABLE, THERE IS NO HOPE. ERROR.  *
*                                                                     *
***********************************************************************
         EJECT
*
* LET THE USER KNOW WHAT'S GOING ON
*
         TM    ZLCGCFLG,ZLCGCMSG   IF MESSAGES ARE TO BE SHOWN,
         BZ    AFTMSG1             THEN...
         L     #3,ZSAVED12         GET BASE REG OF FUN THAT CALLED US
         CLC   0(3,#3),=X'47F0F0'  CHECK VALID LISP CODE
         BNE   DUNNO               CAN'T VERIFY REG 0 IF WRONG CODE
         MVI   ZIL1100B,C' '       CLEAR FUNCTION NAME TO BLANKS
         MVC   ZIL1100B+1(L'ZIL1100B-1),ZIL1100B
         XR    #15,#15             CLEAR INSERT REGISTER
         IC    #15,4(,#3)          GET LENGTH OF MODULE IDENTIFIER
         SH    #15,=H'16'          REDUCE BY LENGTH OF DATE/TIME INFO
         BNP   DUNNO               IF NO NAME, SKIP
         CH    #15,=Y(L'ZIL1100B)  NOT BLOODY LIKELY, BUT JUST IN CASE
         BNH   *+8                  LIMIT TO (NAMELEN) CHARACTERS
         LA    #15,L'ZIL1100B
         BCTR  #15,0               REDUCE FOR EXECUTE
         EX    #15,MVCNAME         MOVE FUNCTION NAME TO MESSAGE
         LA    #2,ZIL1100B+1(#15)  POINT PAST FUNCTION NAME
         B     SET1100
MVCNAME  MVC   ZIL1100B(0),5(#3)   EXECUTED: MOVE FUNCTION NAME TO MSG
ZIL1100U DC    C'SOMEWHERE IN ZIL'
DUNNO    DS    0H
         MVC   ZIL1100B(L'ZIL1100U),ZIL1100U
         LA    #2,ZIL1100B+L'ZIL1100U
SET1100  DS    0H
         MVI   0(#2),C'.'          MOVE IN A PERIOD
         LA    #0,1(,#2)           POINT TO END OF MESSAGE
         LA    #1,ZIL1100A         POINT TO BEGINNING OF MESSAGE
         SR    #0,#1               GET LENGTH OF MESSAGE
         #TPUT *,(1),(0)           SAY GARBAGE COLLECTION IN PROGRESS
AFTMSG1  DS    0H
*
* RECORD CURRENT CPU TIME
*
         STIMER TASK,BINTVL=DUMS   DO DUMMY TO FORCE OS TIMER UPDATE
         L     #2,X'224'           GET ADDRESS OF ASCB
         MVC   GCTIME1,X'40'(#2)   GET JOB STEP ELAPSED TIME (ASCBEJST)
*
* SET BOUNDS OF CONS SPACE FOR RANGE CHECKING
*
         L     #3,ZLCGCACP         Address of bottom of active cons sp
         LR    #4,#10              Address of top of active cons space
         AIF   (NOT &ZILXA).NOSER1
*
* Pre-load virtual pages of spaces to be collected.
*
* Note: We specify an ECB to get asynchronous processing, but we
*       don't actually wait for the page loading to complete.
*       Why should we?  (maybe we should...?)
*
         XC    PGSERECB,PGSERECB   Clear ECB
         PGSER R,LOAD,A=(#3),EA=(#4),ECB=PGSERECB
*                                  Load CONS pages and page with NIL
         XC    PGSERVSA,PGSERVSA   Preset page address to zero
         L     #1,ZLCVSADR         Bottom of active V/S space
         L     #15,ZLCVSNXT        Pointer past last used object
         BCTR  #15,0               Adjust to last byte in used area
         LA    #0,4095(,#1)
         CR    #15,#0              Skip unless at least 4k bytes in use
         BNH   NOVSPGLD
         ST    #1,PGSERVSA         Save addresses for subsequent
         ST    #15,PGSERVSE         page release operation
         XC    PGSERECB,PGSERECB   Clear ECB
         PGSER R,LOAD,A=(1),EA=(15),ECB=PGSERECB
*                                  Load vector/string space pages
NOVSPGLD DS    0H
.NOSER1  ANOP
*
* SET VECTOR/STRING SPACE POINTER
*
         L     #1,ZLCVSOTH         GET POINTER TO "NEW" V/S SPACE
         ST    #1,VSPTR            THIS IS WHERE WE'LL RELOCATE TO.
*
* START NON-INTERRUPTIBLE PART OF CODE
*
         OI    ZLCIFLGS,ZLCISMC    SET NON-INTERRUPTIBLE PROCESS
*
* MARK ALL CELLS ON THE READER MACRO CHAIN.
*
         LA    #15,ZLCRMCHN        @ HEADER OF READER MACRO CHAIN
         L     #2,0(,#15)          GET HEADER OF READER MACRO CHAIN
GCRMLOOP DS    0H                  NOTE #15 -> WHAT'S POINTING.
         LTR   #2,#2               UNTIL END OF CHAIN
         BZ    GCENDRM             (WHETHER ZEROES OR NIL)
         CR    #2,#10
         BE    GCENDRM
         LA    #2,0(,#2)           POINT TO OBJECT, CLEARING HIGH BYTE
         RCHK  #2,GCRMNEXT         CHECK RANGE
         MARK  #2                  MARK IT
GCRMNEXT DS    0H
         LR    #15,#2              SAVE POINTER TO THIS ELEMENT
         GCDR  #2,#15              GET NEXT ELEMENT IN CHAIN
         LA    #15,##CDR(,#15)     POINT TO WHAT'S POINTING
         B     GCRMLOOP            AND CONTINUE.
GCENDRM  DS    0H
*
* MARK OBJECTS POINTED TO BY THE COMMON AREA.
*
         MARKOBJ ZLCOBLST          MARK THE OBLIST
         MARKOBJ ZLCSALST          MARK THE SPECIAL ALIST
         MARKOBJ ZLCFALST          MARK THE FLUID ALIST
         MARKOBJ ZLCGSPRE          MARK THE GENSYM PREFIX IF ANY
*
* GO OVER THE T AND NIL SYMBOLS AND MARK THEIR CONTENTS.
*
         LA    #2,##VECDAT(,#8)    POINT TO FIRST CELL OF T
         LA    #0,##SYMLEN(,#8)    POINT TO END OF T
         ST    #0,ENDVEC           SAVE IT
TLOOP    DS    0H
         C     #2,ENDVEC           LOOP OVER CELLS OF T
         BNL   TEND
         LA    #15,0(,#2)          POINT TO CELL
         L     #1,0(,#15)          LOAD CELL
         #BAS  #14,MARKLIST        MARK IT
         LA    #2,4(,#2)           BUMP TO NEXT CELL
         B     TLOOP
TEND     DS    0H
         LA    #2,##VECDAT(,#10)   POINT TO FIRST CELL OF NIL
         LA    #0,##SYMLEN(,#10)   POINT TO END OF NIL
         ST    #0,ENDVEC           SAVE IT
NILLOOP  DS    0H
         C     #2,ENDVEC           LOOP OVER CELLS OF NIL
         BNL   NILEND
         LA    #15,0(,#2)          POINT TO CELL
         L     #1,0(,#15)          LOAD CELL
         #BAS  #14,MARKLIST        MARK IT
         LA    #2,4(,#2)           BUMP TO NEXT CELL
         B     NILLOOP
NILEND   DS    0H
*
* MARK ALL INLINE COMPILED CODE OBJECTS.  NOTE THAT OBJECTS WHICH ARE
* PHYSICALLY IN INLINE COMPILED CODE ARE NOT MARKED, BUT ANY OBJECTS
* IN A COLLECTIBLE SPACE TO WHICH THEY POINT DO GET MARKED.  THESE
* ARE CREATED (PRIMARILY) IN TWO WAYS:
* (1) INTERNMENT OF SYMBOLS
* (2) BASHING OF CONSTANTS
*
* Note: If GC is invoked while ZILSINT is calling ZILINTN, there are a
*       pair of pointers to inline-code-pointers-set-so-far-while-
*       processing-this-compiled-function that we must check, because
*       no inline-code-vector has yet been built for them.
*
         ICM   #2,15,ZLCSIN1       Get pointer to ZILSINT temp stuff
         BZ    SINEND              If none, skip
SINLOOP  DS    0H
         C     #2,ZLCSIN2          Loop until end of these pointers
         BNL   SINEND
         LA    #15,0(,#2)          Point to pointer
         L     #1,0(,#15)          Load pointer
         #BAS  #14,MARKLIST        Call main GC routine on it
         LA    #2,4(,#2)           Bump to next pointer
         B     SINLOOP             Continue
SINEND   DS    0H
*
* OK, now process all the inline code vectors.
*
         L     #2,ZLCICPA          GET ADDRESS OF "MASTER VECTOR"
         L     #0,ZLCICPU          GET LENGTH OF USED PORTION
         AR    #0,#2               COMPUTE POINTER TO END OF USED
         ST    #0,ENDICP           SAVE IT
ICPLOOP  DS    0H
         C     #2,ENDICP           LOOP UNTIL END OF "MASTER VECTOR"
         BNL   ICPEND
         ST    #2,SAVEICP          SAVE WHERE WE ARE IN "MASTER VECTOR"
         L     #1,0(,#2)           GET COMPILED CODE HEADER POINTER
         ST    #1,SAVEHDR          SAVE IT
         USING ZLHEADER,#1
         ICM   #2,15,ZLHATOMA      GET POINTER TO INLINE ATOMS VECTOR
         BZ    ILAEND              IF NONE, SKIP
         LA    #2,0(,#2)           CLEAR HIGH ORDER BIT
         L     #0,ZLHATOME         GET POINTER TO END THEREOF
         ST    #0,ILEND            SAVE IT
ILALOOP  DS    0H
         C     #2,ILEND            LOOP UNTIL END OF INLINE ATOMS
         BNL   ILAEND
         LA    #15,0(,#2)          POINT TO POINTER
         L     #1,0(,#15)          LOAD POINTER
         #BAS  #14,MARKLIST        CALL MAIN GC ROUTINE ON IT
         LA    #2,4(,#2)           BUMP TO NEXT INLINE ATOM
         B     ILALOOP             CONTINUE
ILAEND   DS    0H
         L     #1,SAVEHDR          RELOAD HEADER PTR FOR ADDR'BILITY
         ICM   #2,15,ZLHLISTA      GET POINTER TO INLINE LISTS VECTOR
         BZ    ILLEND              IF NONE, SKIP
         LA    #2,0(,#2)           CLEAR HIGH ORDER BIT
         L     #0,ZLHLISTE         GET POINTER TO END THEREOF
         ST    #0,ILEND            SAVE IT
ILLLOOP  DS    0H
         C     #2,ILEND            LOOP UNTIL END OF INLINE LISTS
         BNL   ILLEND
         LA    #15,0(,#2)          POINT TO POINTER
         L     #1,0(,#15)          LOAD POINTER
         #BAS  #14,MARKLIST        CALL MAIN GC ROUTINE ON IT
         LA    #2,4(,#2)           BUMP TO NEXT INLINE LIST
         B     ILLLOOP             CONTINUE
ILLEND   DS    0H
         L     #2,SAVEICP          GET "MASTER VECTOR" PLACEHOLDER
         LA    #2,4(,#2)           BUMP TO NEXT ENTRY THEREIN
         B     ICPLOOP             CONTINUE LOOPING THRU IT
         DROP  #1
         SPACE 1
* Constants used by this loop are here for locality of reference.
         SPACE 1
ENDICP   DS    A                   PTR TO END OF USED "MASTER VECTOR"
SAVEICP  DS    A                   "MASTER VECTOR" PLACEHOLDER
SAVEHDR  DS    A                   COMPILED CODE HEADER POINTER
ILEND    DS    A                   PTR TO END OF STUFF BEING SCANNED
         SPACE 1
ICPEND   DS    0H                  FINISHED COLLECTING ALL INLINE STUFF
*
* MARK ATOMS CONTAINED IN FILE BLOCK POINTERS.
*
         L     #2,ZLCIFBAD         GET ADDRESS OF 1ST INPUT FILE BLOCK
IFLOOP   DS    0H
         LTR   #2,#2               LOOP UNTIL NO MORE FILE BLOCKS
         BZ    IFEND
         LA    #15,ZLFATOM-ZLFILBLK(,#2) POINT TO POINTER TO FILE ATOM
         L     #1,0(,#15)          GET POINTER TO FILE ATOM
         #BAS  #14,MARKLIST        INVOKE MAIN GC ROUTINE ON IT
         L     #2,ZLFCHAIN-ZLFILBLK(,#2) GET POINTER TO NEXT FILE BLOCK
         B     IFLOOP              CONTINUE
IFEND    DS    0H
         L     #2,ZLCOFBAD         GET ADDRESS OF 1ST OUTPUT FILE BLOCK
OFLOOP   DS    0H
         LTR   #2,#2               LOOP UNTIL NO MORE FILE BLOCKS
         BZ    OFEND
         LA    #15,ZLFATOM-ZLFILBLK(,#2) POINT TO POINTER TO FILE ATOM
         L     #1,0(,#15)          GET POINTER TO FILE ATOM
         #BAS  #14,MARKLIST        INVOKE MAIN GC ROUTINE ON IT
         L     #2,ZLFCHAIN-ZLFILBLK(,#2) GET POINTER TO NEXT FILE BLOCK
         B     OFLOOP              CONTINUE
OFEND    DS    0H
*
* LOOP OVER ALL STACK LOCATIONS.
*
         L     #11,ZLCPDADR        POINT TO BOTTOM OF PUSH DOWN STACK
         L     #0,ZSAVED0          GET REG 0 AT ENTRY TO CONS
         TM    ZLCGCFLG,ZLCGCBLD   IF WE WERE TOLD TO RELY ON #0
         BO    REG0OK              THEN WE HAVE TO ASSUME REG0 IS OK.
         L     #1,ZSAVED12         GET BASE REG OF FUN THAT CALLED US
         CLC   0(3,#1),=X'47F0F0'  CHECK VALID LISP CODE
         BNE   GCERR               CAN'T VERIFY REG 0 IF WRONG CODE
         XR    #2,#2
         IC    #2,3(,#1)           GET B2D2 OF INITIAL BRANCH INSTR.
         AR    #1,#2               POINT TO NEXT EXECUTABLE INSTR.
         CLC   0(2,#1),=X'4100'    CHECK VALID (EXPECTED) LISP CODE
         BNE   MAYBLEX             IF NOT WHAT IS EXPECTED, MAYBE LEXPR
         LH    #2,2(,#1)           GET B2D2 OF STACK SIZE LA INSTR.
         SLA   #2,20               SHIFT OUT BASE REG AND
         SRA   #2,20               ISOLATE THE MAXIMUM STACK SIZE
         L     #1,ZSAVED11         GET STACK PTR AT ENTRY TO CONS
         AR    #2,#1               ADD TO GET MAX STACK ADDRESS
         CR    #0,#1               IF REG 0 LESS THAN CURRENT STACK PTR
         BL    BADREG0             THEN CAN'T USE IT
         CR    #0,#2               IF REG 0 GREATER THAN MAX STACK PTR
         BH    BADREG0             THEN CAN'T USE IT
         B     REG0OK              OTHERWISE USE REG 0 AS TOP OF STACK
MAYBLEX  DS    0H                  MAYBE IT'S A LEXPR...
         CLC   0(L'LCODE,#1),LCODE SEE IF IT'S COMPILED LEXPR PROLOGUE
         BNE   GCERR               IF NOT, CAN'T VERIFY #0, WRONG CODE
         LH    #2,L'LCODE(,#1)     GET B2D2 OF STACK SIZE LA INSTR.
         SLA   #2,20               SHIFT OUT BASE REG AND
         SRA   #2,20               ISOLATE THE MAXIMUM STACK SIZE
         SH    #2,=H'4'            ADJUST IT
         L     #1,ZSAVED11         ELSE GET STACK PTR AT ENTRY TO CONS
         AR    #2,#1               ADD TO GET MAX STACK ADDRESS
         CR    #0,#1               IF REG 0 LESS THAN CURRENT STACK PTR
         BL    BADREG0             THEN CAN'T USE IT
         CR    #0,#2               IF REG 0 GREATER THAN MAX STACK PTR
******** BH    BADREG0             THEN CAN'T USE IT
         BNH   REG0OK              OTHERWISE USE REG 0 AS TOP OF STACK
BADREG0  DS    0H
***********************************************************************
*        TM    ZLCGCFLG,ZLCGCMSG   IF MESSAGES ARE TO BE SHOWN,
*        BZ    AFTMSG0              AND MSGLEVEL IS < 1, THEN...
*        #TPUT 0,ZIL1103             TELL USER REG 0 NO GOOD
*FTMSG0  DS    0H                  --- naaah, don't bother with this
***********************************************************************
         LR    #11,#2              CONTINUE, USING MAX STACK ADDR
         B     GOSTACK
REG0OK   DS    0H
         LR    #11,#0              PUT INTO A USEABLE REGISTER
GOSTACK  DS    0H
         L     #2,ZLCPDADR         LOAD UP BOTTOM OF STACK AGAIN
GCPDLOOP DS    0H
         CR    #2,#11              UNTIL END OF CURRENT STACK
         BNL   GCENDPD
         LR    #15,#2              POINT TO WHAT'S DOING THE POINTING
         L     #1,0(,#15)          GET ITEM POINTED TO BY STACK
         #BAS  #14,MARKLIST        INVOKE MAIN GC ROUTINE ON IT
NOMKPD   DS    0H
         LA    #2,4(,#2)           BUMP TO NEXT STACK LOCATION
         B     GCPDLOOP            AND CONTINUE.
GCENDPD  DS    0H
*
* NOW PROCESS INPUT PARAMETERS TO CONS.
*
* SINCE THIS IS A CONS-TO-BE, WE DON'T MARK IT AS SUCH, BUT WE
* PROCESS IT AS IF IT IS ALREADY A CONS.
*
         LA    #15,ZSAVED1          POINT TO SAVED REG 1 ON ENTRY
         CLI   ##TYPE(#15),##FLONUM IF IT IS A NUMBER
         BNL   GCVS                 THEN SKIP, NO POINTERS TO MARK
         L     #1,0(,#15)           ELSE GET CAR-TO-BE
         #BAS  #14,MARKLIST         INVOKE MAIN GC ROUTINE ON IT
         LA    #15,ZSAVED2          POINT TO SAVED REG 2 ON ENTRY
         L     #1,0(,#15)           GET CDR-TO-BE
         #BAS  #14,MARKLIST         INVOKE MAIN GC ROUTINE ON IT
******** B     GCVS
         EJECT
GCVS     DS    0H
*
* NOW WE GO THROUGH ALL THE OBJECTS THAT HAVE BEEN RELOCATED (SO FAR)
* FROM THE OLD VECTOR/STRING SPACE TO THE NEW VECTOR/STRING SPACE.
* SINCE THERE MAY BE VECTORS OR OTHER SIMILAR OBJECTS HERE THAT
* POINT TO STILL OTHER OBJECTS, WE HAVE TO GO THROUGH THEM (THEY MAY
* EVEN RELOCATE OTHER VECTOR/STRING SPACE OBJECTS THAT WILL END UP
* PAST THE END OF WHERE WE ARE, SO WE'RE CONSTANTLY CHASING A MOVING
* END-OF-SPACE POINTER).  WHEN WE FINALLY REACH THE END (PANT PANT),
* WE'RE FINISHED, SO SWAP SPACES - THE FIRST ONE NOW WILL LATER BE
* LAST, 'CAUSE THE GARBAGE IT IS COLLECTED.
*
* ZLCVSOTH POINTS TO NEW SPACE (WILL BECOME THE OLD SPACE)
* VSPTR POINTS TO THE END OF RELOCATED NEW SPACE (IT'S VOLATILE)
*
         L     #2,ZLCVSOTH         GET POINTER TO NEW V/S SPACE
GCVSLOOP DS    0H
         C     #2,VSPTR            DO UNTIL NO MORE NEW V/S OBJECTS
         BNL   GCVSEND
         CLI   ##TYPE(#2),##SYMBOL IF OBJECT IS A SYMBOL
         BE    SYMCOLL             THEN GO COLLECT LIKE A VECTOR
         CLI   ##TYPE(#2),##DFLOAT IF OBJECT IS A DOUBLE-FLOAT
         BE    DFCOLL              THEN GO COLLECT LIKE A STRING
         TM    ##TYPE(#2),##ATOM+##VSS IF ATOM AND VSS BITS NOT ON
         BNO   BADVSOBJ            THEN FORWARDED OBJECT OR WORSE ERROR
         TM    ##TYPE(#2),##VEC    IF THIS IS NOT A VECTOR-TYPE OBJECT
         BNO   GCVSSTR             THEN COLLECT AS A STRING ONLY
         B     VECCOLL             ELSE GO COLLECT LIKE A VECTOR
         SPACE 1
SYMCOLL  DS    0H                  COLLECT SYMBOL IN V/S SPACE
*                                  USE SYMBOL LENGTH (IGNORE LEN FLD)
         LA    #0,##SYMLEN(,#2)    PASS ADDRESS OF END OF SYMBOL
         B     VECSCAN             AND COLLECT LIKE A VECTOR
         SPACE 1
DFCOLL   DS    0H                  COLLECT DOUBLE FLOAT IN V/S SPACE
*                                  USE OBJECT LENGTH (IGNORE LEN FLD)
         LA    #2,16(,#2)          BUMP PAST END OF DOUBLE FLOAT
         B     GCVSLOOP            SKIP OVER IT, NO POINTERS TO COLLECT
         SPACE 1
VECCOLL  DS    0H                  COLLECT VECTOR IN V/S SPACE
*
* COLLECT VECTOR OR SYMBOL BY PROCESSING ALL ITEMS POINTED TO THEREIN.
*
         XR    #1,#1               CLEAR INSERT REGISTER
         ICM   #1,7,1(#2)          GET VECTOR LENGTH
         BNZ   *+8                 IF ZERO (YOU NEVER KNOW), THEN
         LA    #1,1                 FORCE POSITIVE LENGTH
         LA    #0,4+3(#1,#2)       LENGTH + 4 FOR PREFIX AND...
         N     #0,=X'FFFFFFFC'      ROUND UP TO FULLWORD BOUNDARY
VECSCAN  DS    0H                  #0 POINTS TO END OF OBJECT
*******  LA    #15,##VECDAT(,#2)   <== this was a bug!!!!  fixed below
         LA    #2,##VECDAT(,#2)    POINT TO START OF VECTOR DATA
         ST    #0,ENDVEC           STORE ADDRESS OF END OF VECTOR
VECLOOP  DS    0H                  LOOP FOR ALL ELEMENTS OF VECTOR
         C     #2,ENDVEC           UNTIL LAST VECTOR SLOT
         BNL   VECEND
         LR    #15,#2              POINT TO POINTER TO LISP OBJECT
         L     #1,0(,#15)          LOAD POINT TO OBJECT
         #BAS  #14,MARKLIST        INVOKE MAIN GC ROUTINE ON IT
         LA    #2,4(,#2)           BUMP TO NEXT VECTOR ELEMENT
         B     VECLOOP             CONTINUE LOOPING
VECEND   EQU   GCVSLOOP            END OF VECTOR, GO TO NEXT STRING
         SPACE 1
GCVSSTR  DS    0H                  GC THIS (RELOCATED) STRING
*                                  (WE DON'T DO NUTHIN WITH IT)
GCVSNXT  DS    0H                  OK, TIME FOR THE NEXT OBJECT
         XR    #1,#1               CLEAR INSERT REGISTER
         ICM   #1,7,1(#2)          GET LENGTH OF THIS OBJECT
         BNZ   GCVSADIT            IF POSITIVE, NO PROBLEM
         LA    #1,1                IF ZERO, ASSUME SOME LENGTH
GCVSADIT DS    0H                  ADD LENGTH TO ADDRESS OF OBJECT
         LA    #2,4+3(#1,#2)       + 4 FOR PREFIX AND...
         N     #2,=X'FFFFFFFC'      ROUND UP TO FULLWORD BOUNDARY
         B     GCVSLOOP            CONTINUE LOOPING
GCVSEND  DS    0H                  FINISHED, NOW SWAP V/S SPACES
         L     #1,VSPTR            END-OF-USED-SPACE POINTER
         ST    #1,ZLCVSNXT         WILL BE @ AVAILABLE SLOT
         L     #1,ZLCVSADR
         L     #2,ZLCVSOTH
         ST    #2,ZLCVSADR         OLD BECOMES NEW
         ST    #1,ZLCVSOTH         AND NEW BECOMES OLD
*
* NOTE THAT WE HAVEN'T CLOBBERED THE OLD (NOW NEW) SPACE, AT LEAST
* THE PART FOLLOWING THE OLD ZLCVSNXT POINTER (ADMITTEDLY, WE DID
* RELEASE THE PAGES OF THE OLD VECTOR/STRING SPACE).  THIS IS VERY
* IMPORTANT, SINCE STRING-BUILDING CODE MAY BE IN THE MIDDLE OF
* SOMETHING THERE AND WE WANT TO LET THEM START OVER AGAIN.  SEE READ.
*
         EJECT
FIXHASH  DS    0H
*                                                                     *
*   GO THROUGH THE OBLIST HASH ARRAY AND RELOCATE ALL THE NONZERO     *
*   SYMBOL POINTERS THEREIN.  SINCE ALL OF SYMBOLS HAVE ALREADY       *
*   BEEN COLLECTED (WHEN THE OBLIST ITSELF WAS COLLECTED), WE KNOW    *
*   THEY'VE ALL BEEN FORWARDED, SO JUST LOAD THE FORWARDING POINTERS. *
*
*----------------------------------------------------------------------
         AIF   (&ZILVF).VFH
*----------------------------------------------------------------------
         L     #2,ZLCOBHSH         Get address of oblist hash array
         L     #0,ZLCOBDIM         Get # of slots in array
         SLA   #0,2                Convert to size of hash array
         AR    #0,#2               Convert to address of end of array
         ST    #0,ENDVEC           Store address of end
FHLOOP   DS    0H                  Loop through hash table entries
         CR    #2,#0               until end of hash array
         BNL   FHEND
         ICM   #15,15,0(#2)        Get symbol pointer from hash array
         BZ    FHCONT              If zero, skip
         TM    ##TYPE(#2),##ATOM   If atom bit on,
         BO    FHERROR             then symbol wasn't forwarded, error
         L     #14,##VECDAT(,#15)  else get forwarding pointer
         ST    #14,0(,#2)          and store back into hash array
FHCONT   LA    #2,4(,#2)           Bump to next hash table entry
         B     FHLOOP              Continue looping
FHEND    DS    0H                  End of hasl table loop
*----------------------------------------------------------------------
         AGO   .VFHEND
*----------------------------------------------------------------------
.VFH     ANOP
*----------------------------------------------------------------------
         SPACE 1
***********************************************************************
*                                                                     *
*                 *** SEB vector code here! ***                       *
*                                                                     *
* This code relocates all the symbol pointers in the oblist hash      *
* array by replacing each nonzero pointer with the contents of        *
* the symbol forwarding pointer.  Currently the VLI (load indirect)   *
* instruction is used to perform the pointer loading.                 *
*                                                                     *
* The method of handling zero entries in the (usually sparse) array   *
* (since VLI doesn't honor the vector mask mode or otherwise have a   *
* means of not processing certain elements) is currently to compare   *
* the vector elements with zero, generating a vector mask, and doing  *
* a LOAD MATCHED that replaces the zero elements in the vector with   *
* a special hack value that, when relocated by VLI, does the "right   *
* thing", i.e. puts a zero back into the vector.  This value is the   *
* address of a field in this module whose ##VECDAT offset has a zero  *
* in it.  (We could do a STORE MATCHED, I suppose, but that might be  *
* slower (???), and besides, we don't want to depend on the data      *
* pointed to by zero being available.)                                *
*                                                                     *
* A better approach might be to build a 65536-bit bit vector, use     *
* VLBIX to create a mask describing nonzero hash array elements, and  *
* use another VLI to load offsets of the nonzero elements.  In other  *
* words, we'd be using a VLI in its intended mode followed by a VLI   *
* in its unintended mode.  But I don't feel like allocating yet       *
* another chunk of storage for a bit vector.                          *
*                                                                     *
* Also:  VLVCU could be used to control the looping through the       *
* vector processing, but we use CR because it might conceivably       *
* be faster (is that why SKH does it that way in the sweep???),       *
* and we don't need the functionality because we know that the        *
* oblist hash array, like the section size, will always be a power    *
* of 2 in length.                                                     *
*                                                                     *
* Note: No validity checking of symbol forwardedness done in this     *
* code.  Hopefully this was adequately checked out while we were      *
* operating with the scalar version of the algorithm!                 *
*                                                                     *
***********************************************************************
         SPACE 1
         L     #2,ZLCOBHSH         Get address of oblist hash array
         L     #0,ZLCOBDIM         Get # of slots in array
         LR    #5,#2               Another copy of address
         SLA   #0,2                Convert to size of hash array
         AR    #0,#2               Convert to address of end of array
         LA    #1,##VECDAT         Constant offset to get forwardg ptrs
         LA    #14,VFHFAKE         Constant fakeout to relocate zero's
         XR    #15,#15             Constant zero
         VSVMM 0                   Set vector mask mode off (for VSRL)
         VLVCA 512                 Set maximum section size
VFHLOOP  DS    0H
         VL    #V0,#2              Load 128 hash array elements
         VCQ   #VE,#15,#V0         Vector mask = 1's for zero elements
         VLMQ  #V0,#14             Replace zeroes with "fake" in vector
         VSRL  #V1,#V0,2           Convert addresses to offsets (/ 4)
         VLI   #V2,#V1,0(#1)       Load symbol forwarding pointers
         VST   #V2,#5              Store 128 ptrs back into hash array
         CR    #2,#0               Loop through hash table entries
         BL    VFHLOOP             until end of hash array
         B     VFHEND              End loop (branch around data)
         SPACE 1
VFHZERO  DC    A(0)                VLI will load a zero from here
VFHFAKE  EQU   VFHZERO-##VECDAT    Fakeout for relocating zero elements
         SPACE 1
VFHEND   DS    0H                  End of hasl table loop
         SPACE 1
*----------------------------------------------------------------------
.VFHEND  ANOP
*----------------------------------------------------------------------
         EJECT
         SPACE 1
         AIF   (NOT &ZILXA).NOSER2
***********************************************************************
*                                                                     *
* Now we can page-release the old vector/string space, or at least as *
* much as we care to.                                                 *
*                                                                     *
***********************************************************************
         SPACE 1
         ICM   #1,15,PGSERVSA      If there was enough old VSS to
         BZ    NOPGREL              pageload, now release it.
         L     #15,PGSERVSE          Get addresses for PGSER
         PGSER R,RELEASE,A=(1),EA=(15) Release old used space
NOPGREL  DS    0H
.NOSER2  ANOP
         EJECT
SWEEP    DS    0H
*
* NOW WE ARE FINISHED WITH THE MARKING PHASE.  NOW BUILD NEW FREE LIST
*
*----------------------------------------------------------------------
         AIF   (&ZILVF).VSWEEP
*----------------------------------------------------------------------
         XR    #5,#5               CLEAR FREE CELL COUNT
         XR    #6,#6               CLEAR FREE LIST POINTER
         LR    #7,#3               GET ADDRESS OF CONS SPACE
SWLOOP   DS    0H
         CR    #7,#4               DO UNTIL END OF CONS SPACE
         BNL   ENDSW
         IFMK  #7,NO=SWFREE        IF THIS CELL IS MARKED, THEN...
         UNMK  #7                  REMOVE MARK
         B     SWINCR              ELSE
SWFREE   DS    0H
         LA    #5,1(,#5)           INCREASE COUNT OF FREE CELLS
         LTR   #6,#6               IF FREE LIST POINTER NOT SET YET
         BNZ   SWFRESET            THEN...
         LR    #9,#7                SET INITIAL FREE CELL POINTER
         B     SWARESET            ELSE...
SWFRESET ST    #7,##CDR(,#6)        SET LINK IN LAST FREE CELL POINTER
SWARESET DS    0H
         L     #0,=X'FF404040'     PUT JUNK IN FIRST HALF 4 DEBUGGING
         XR    #1,#1               SET LINK TO ZERO
         STM   #0,#1,##CAR(#7)     INITIALIZE FREE CELL CONTENTS
         LR    #6,#7               NEW LATEST FREE CELL = THIS ONE
SWINCR   DS    0H
         LA    #7,8(,#7)
         B     SWLOOP
ENDSW    DS    0H
*
* Code to expand dynamically growing CONS space in SCALAR assembly
*
*---------------------------------------------------------------------*
* If the amount of free space remaining is below the threshold        *
* (currently 1/2), then we dynamically expand the cons space by       *
* bringing in another section of allocated-but-not-active cons        *
* space (equal in size to what we already have active) and            *
* chaining it to the existing free list.                              *
*                                                                     *
* At this point, register 3 = ZLCGCACP which is the pointer to the    *
* bottom of the active CONS space.                                    *
*---------------------------------------------------------------------*
         STM   #14,#11,VSAVE       Store registers
         L     #7,ZLCGCACD         Total # of CONS cells in active
         SRL   #7,1                Divide this number by 2
         CR    #5,#7               Compare free # found with 1/2 total
         BH    SCNOMORE            More than half is still free?
         C     #3,ZLCCSADR         Compare with absolute bottom
         BNH   SCNOMORE            Can't expand if it's already max
         SLL   #7,5                8*2*2*(# cells/2) = 2*size in bytes
         LR    #8,#4               Compute address of bottom of new
         SR    #8,#7                active size (top - new length)
         C     #8,ZLCCSADR         If less than total CS allocated
         BNL   SCEXPOK             then
         L     #8,ZLCCSADR          use total allocated
SCEXPOK  ST    #8,ZLCGCACP         Save new active CS pointer
         ST    #8,VSAVE+5*4        Set saved #3 to CONS lower bound
         LR    #7,#4               (don't change live #3, -> old)
         SR    #7,#8               Recompute true length of new active
         SRL   #7,3                 CONS space and convert to number of
         ST    #7,ZLCGCACD           doublewords, and save this value
*
         LR    #7,#3               Get old bottom-of-CONS address
         SR    #7,#8               Subtract new lower bottom-of-CONS
         SRL   #7,3                Divide by 8 to get cnt of new cells
         AR    #5,#7               Add count to existing free count
         LR    #1,#8               Point to first cell in new block
         L     #14,=X'FF404040'    PUT JUNK IN FIRST HALF 4 DEBUGGING
SCFLOOP  DS    0H
         CR    #1,#3               Loop until end of new block
         BNL   SCFEND
         LA    #15,8(,#1)          Get pointer to just-initialized cell
         STM   #14,#15,##CAR(#1)   Initialize free cell contents
         LR    #1,#15              Get next cell to be made free
         B     SCFLOOP             Continue for all cells in block
SCFEND   DS    0H                  #1 points to end of new block
         SH    #1,=H'8'            Bump back to last cell in new block
         XR    #2,#2               Set chain pointer to zero
         ST    #2,##CDR(,#1)        (i.e. will be end of new free list)
         L     #1,ZLCGCACP         Get ptr to new active space again
         LTR   #6,#6               Get pointer to old last free cell
         BZ    SCXNFREE            If there was one, then
         ST    #8,##CDR(,#6)        hook new free list to end of old
         B     SCXAF               else (no free cells in old space)
SCXNFREE ST    #8,VSAVE+11*4        set saved #9 to 1st new free cell
SCXAF    DS    0H                  Now we have one good free list.
         ST    #5,VSAVE+7*4        SET NEW VALUE OF #5 (FREE COUNT)
*
* Not required, but in case we ever use ZLCGCACF...
*
         ST    #5,ZLCGCACF         Save last-uncovered # of free cells
*
* End of code that sets ZLCGCACF
*
         LM    #14,#11,VSAVE       RELOAD SAVED REGS AND UPDATED #5
*              #9 now points to the beginning of the free list.
         B     GCCHECK
*
SCNOMORE ST    #5,VSAVE+7*4        SET NEW VALUE OF #5 (FREE COUNT)
         LM    #14,#11,VSAVE       RELOAD SAVED REGS AND UPDATED #5
         LTR   #5,#5
         BNZ   GCCHECK
         L     #9,ZLCGCEND         NO CELLS FOUND, ZERO REG 9
         B     GCCHECK             Jump out of here
*----------------------------------------------------------------------
         AGO   .ASWEEP
*----------------------------------------------------------------------
.VSWEEP  ANOP  ,
*---------------------------------------------------------------------*
*   VECTOR PROCESSOR OPTION FOR THE GARBAGE COLLECTOR SWEEP PHASE     *
*                                                                     *
*  There are three versions so far of the sweep phase for this        *
*  version of the garbage collector.  Version A is very innefficient  *
*  even though it runs very fast.  It creates a free-list which       *
*  jumps in multiples of 128 words, which results in catastrophic     *
*  degeneration of the cache updating algorithm in the hardware.      *
*  This might be remedied by using 127-word vectors, but the other    *
*  algorithms are cleaner and at least almost as fast.                *
*                                                                     *
*  Vector algorithm B is a precursor to vector algorithm C.           *
*  Algorithm B first does the sweep, and then creates the free-list.  *
*  This requires going through the CONS space twice.  Algorithm C     *
*  improves on this by sweeping only about as far as is necessary     *
*  to create a full vector section of 128 free-cells.  This results   *
*  in a sweep phase speed improvement of about 20%.                   *
*  Another advantage of algorithm C over A is that it leaves the      *
*  free-list in the same form as the scalar version does, which is    *
*  the best, namely, ascending and contiguous when possible.          *
*                                                                     *
*  Algorithm C can be improved on slightly by eliminating the use     *
*  of the bit vector and simply buffering up a dozen or so sections   *
*  of pointers to free cells, and then doing indirect stores          *
*  (creating the free-list).  This may become Version D.              *
*                                                                     *
*  But we drop work on Version D to explore more interesting          *
*  mark and copy, mark and compact, straight copy and update,         *
*  and threaded copying and updating GC possibilities for the         *
*  Vector Facility.                                                   *
*---------------------------------------------------------------------*
         AGO   .VECTORC
         B     VBSTART             ---TEMPORARY---
*
         STM   #14,#7,VSAVE
         SR    #4,#3
         SRL   #4,4
         CL    #4,LASTFREE
         BH    BVA
         LM    #14,#7,VSAVE
         B     VBSTART
BVA      LM    #14,#7,VSAVE
         EJECT
*---------------------------------------------------------------------*
*      VECTOR SWEEP "A" ROUTINE                                       *
*                                                                     *
*  IN THE FOLLOWING DISCUSSION AND CODE COMMENTS, THE NUMBER          *
*  128 REFERS TO THE SECTION SIZE OF A 3090 VECTOR FACILITY WITH      *
*  A SECTION SIZE OF 128.  ACCORDING TO THE IBM SYSTEM/370 VECTOR     *
*  OPERATIONS MANUAL, THE SECTION SIZE MAY VARY DEPENDING ON THE      *
*  MODEL FROM 8 TO 512.  ANY REFERENCE HERE TO A SECTION SIZE OF      *
*  128 CAN BE SUBSTITUTED WITH THE SECTION SIZE OF A PARTICULAR       *
*  MODEL OF THE VECTOR FACILITY.  THE VECTOR SWEEP ALGORITHMS ARE     *
*  DESIGNED TO BE INDEPENDENT OF SECTION SIZE.                        *
*                                                                     *
*  THIS VECTOR SWEEP ALGORITHM IS PERFORMED IN ONE PASS.  MARKED      *
*  CELLS ARE UNMARKED 128 ELEMENTS AT A TIME, THE VECTOR MASK IS      *
*  SET TO INDICATE WHICH CELLS ARE FREE AND CONDITIONAL, VECTOR-      *
*  MASK-CONTROLLED INSTRUCTIONS STORE INTO THE FREE CELLS THE         *
*  ADDRESSES OF THE LAST ENCOUNTERED FREE CELLS.  THEN                *
*  THE ADDRESSES OF THE CURRENT FREE CELLS ARE GENERATED AND          *
*  ARE USED TO UPDATE THE ADDRESSES OF THE "LAST ENCOUNTERED"         *
*  FREE CELLS.  THESE OPERATIONS WILL TYPICALLY CONSTITUTE THE        *
*  MAJORITY OF THE PROCESSING TIME WHEN THERE IS MOSTLY COLLECTIBLE   *
*  MATERIAL.  A SIMPLE EXAMPLE OF THE FORM THE FREE LIST MIGHT TAKE   *
*  IS ILLUSTRATED HERE.                                               *
*                                                                     *
*  A VECTOR SECTION SIZE OF 4 IS ASSUMED FOR ILLUSTRATIVE             *
*  CONVENIENCE.  CELLS MARKED WITH A CAR AND A CDR WERE               *
*  FOUND TO HAVE THEIR GC BITS OF THE CAR SET, INDICATING THAT THEY   *
*  CANNOT BE ADDED TO THE FREE LIST.  THE REST WERE COLLECTED INTO    *
*  A FREE LIST WHICH MAKES "RASTER SCAN" THROUGH MEMORY.  THAT IS,    *
*  FIRST ALL FREE CELLS AT MULTIPLES OF SECTION SIZE ARE LINKED       *
*  TOGETHER FROM TOP TO BOTTOM OF THE CONS SPACE.  THE LAST CELL      *
*  IN THIS CHAIN IS LINKED TO THE HIGHEST FREE CELL WHICH IS AT       *
*  A LOCATION WHICH IS A MULTIPLE OF THE SECTION SIZE + 1.  THE       *
*  LINKED LIST BELOW ILLUSTRATES THIS.  REGISTER 9 IN THIS CASE       *
*  WOULD CONTAIN 296, THE LOCATION OF THE FIRST FREE CELL.  THE       *
*  CONS CELL AT LOCATION 288 IS THE LAST CELL IN THE FREE LIST.       *
*                                                                     *
*  IN THIS EXAMPLE, YOU CAN THINK OF THE VECTOR FACILITY AS SWEEPING  *
*  DOWN ACROSS THESE CELLS THE WAY A HORIZONTAL RULER PULLED DOWN     *
*  THE PAGE WOULD SWEEP OVER THESE CELLS.  THE INDIVIDUAL INCH        *
*  MARKERS ON THE RULER COULD CORRESPOND TO THE VECTOR ELEMENTS.      *
*  EACH ELEMENT IN THE VECTOR PROCESSOR IS RESPONSIBLE FOR            *
*  PROCESSING ONE COLUMN.  HENCE, ONE ROW IS PROCESSED BY THE         *
*  VECTOR FACILITY FOR EVERY PASS THROUGH THE LOOP.                   *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*  REG 9                                                              *
*  +---+                                                              *
*  |296|                                                              *
*  +---+                                                              *
*                                                                     *
*                                                                     *
*  200 204          208 212          216 220          224 228         *
*  +---+---+        +---+---+        +---+---+        +---+---+       *
*  |CAR|CDR|        |   |312|        |CAR|CDR|        |CAR|CDR|       *
*  +---+---+        +---+---+        +---+---+        +---+---+       *
*                                                                     *
*                                                                     *
*                                                                     *
*  232 236          240 244          248 252          256 260         *
*  +---+---+        +---+---+        +---+---+        +---+---+       *
*  |CAR|336|        |CAR|CDR|        |CAR|CDR|        |CAR|CDR|       *
*  +---+---+        +---+---+        +---+---+        +---+---+       *
*                                                                     *
*                                                                     *
*                                                                     *
*  264 268          272 276          280 284          288 292         *
*  +---+---+        +---+---+        +---+---+        +---+---+       *
*  |CAR|CDR|        |   |208|        |CAR|CDR|        |CAR|CDR|       *
*  +---+---+        +---+---+        +---+---+        +---+---+       *
*                                                                     *
*                                                                     *
*                                                                     *
*  296 300          304 308          312 316          320 324         *
*  +---+---+        +---+---+        +---+---+        +---+---+       *
*  |   |232|        |   |272|        |   |352|        |   |  0|       *
*  +---+---+        +---+---+        +---+---+        +---+---+       *
*                                                                     *
*                                                                     *
*                                                                     *
*  328 332          336 340          344 348          352 356         *
*  +---+---+        +---+---+        +---+---+        +---+---+       *
*  |CAR|CDR|        |   |304|        |CAR|CDR|        |   |320|       *
*  +---+---+        +---+---+        +---+---+        +---+---+       *
*                                                                     *
*  THE MAIN LOOP (VA3) IN THE THIS VECTOR ALGORITHM IS RATHER SHORT,  *
*  CONSISTING OF ONLY 6 MAIN VECTOR INSTRUCTIONS AND SOME FASTER      *
*  ONES WHICH DON'T OPERATE OVER VECTOR ELEMENTS.  THIS, COMBINED     *
*  WITH THE FACT THAT THIS ALGORITHM MAKES ONLY ONE PASS (MINIMIZING  *
*  LOAD ON THE CACHE), MAKES IT QUITE FAST.                           *
*                                                                     *
*  MOST OF THE COMPLEXITY OF THE ALGORITHM STEMS FROM                 *
*  THE NEED TO KEEP TRACK OF THE BEGINNING AND END OF EVERY           *
*  FREE LIST (ONE MADE BY EACH ELEMENT AFTER A FULL SWEEP) AND        *
*  LINKING THE ENDS TOGETHER TO MAKE ONE FREE LIST.  SOME OF THE      *
*  SHORTER FREE LISTS MAY HAVE ONLY ONE ELEMENT, OR SOME ELEMENTS MAY *
*  HAVE FAILED TO ENCOUNTER ANY FREE CELLS.  HENCE A LINK MUST BE     *
*  MADE TO JUMP ACROSS SUCH A COLUMN.  THIS IS CONVENIENTLY DONE VIA  *
*  STORE-COMPRESSED VECTOR INSTRUCTIONS (VSTK).                       *
*                                                                     *
* REGISTER USAGE FOR VECTOR SWEEP "A":                                *
*                                                                     *
* #0  - POINTER FOR VNS VECTOR INSSTRUCTION                           *
* #1  - POINTER FOR VC VECTOR INSTRUCTION                             *
* #2  - POINTER FOR VST VECTOR INSTRUCTION                            *
* #3  - POINTER FOR VSTMD VECTOR INSTRUCTION                          *
* #4  - UPPER BOUND OF CONS SPACE                                     *
* #5  - FREE CELL COUNT                                               *
* #6  - CONSTANT 2 = STRIDE OF CONS CELL IN 4-BYTE WORDS              *
* #7  - POINTER FOR VLINT VECTOR INSTRUCTION                          *
* #8  - (SEC SIZE - 1) CELLS LESS THAN TOP OF CONS SPACE              *
*       TO HELP DETECT WHEN THE END OF SECTIONING LOOP OCCURS         *
* #9  - USED TO REBUILD THE FREE LIST                                 *
* #10 - ONE LESS THAN THE SECTION SIZE (127 ON IBM 3090)              *
* #11 - POSSIBLY BUT NOT NECESSARILY USED FOR STACK PROCESSING        *
* #12 - LOCAL BASE REGISTER FOR THIS ROUTINE                          *
* #13 - THE COMMON AREA, AS IN THE REAL WORLD                         *
* #14 - CONSTANT 8 = STRIDE OF CONS CELL BYTES                        *
* #15 -                                                               *
*                                                                     *
* VECTOR REGISTER USAGE                                               *
*                                                                     *
* #V0 - MASKED CARS OF CONS CELLS                                     *
* #V1 - ADDRESSES OF CARS OF CONS CELLS                               *
* #V2 - PATTERN X'FF404040' STORED AS CAR OF FREE LIST CELLS          *
* #V3 - ADDRESS OF LAST FREE CELL FOUND BY VECTOR ELEMENT             *
* #V4 - (NOT USED)                                                    *
* #V5 - ADDRESS OF FIRST FREE CELL FOUND BY VECTOR ELEMENT            *
*---------------------------------------------------------------------*
VASTART  DS    0H
         SPACE 1
*
* ===> SEB1525 - GET WORKAREA
*
         ICM   #1,15,ZLCGCBVA      GET ADDRESS OF GC SWEEP WORK AREA
         BNZ   VAGOTWA             IF ZERO, THEN...
         L     #0,VAWALEN           GET LENGTH OF WORK AREA NEEDED
         ST    #0,ZLCGCBVL          SAVE LENGTH
         #GETMAIN RC,LV=(0),LOC=ANY TRY TO GET IT
         LTR   #15,#15              IF FAILED
         BNZ   GERROR               THEN DISASTER
         ST    #1,ZLCGCBVA          ELSE STORE ADDRESS OF GC WA
VAGOTWA  DS    0H
         SPACE 1
         STM   #14,#7,VSAVE        SAVE REGISTERS DURING VECTOR SWEEP
         VSVMM 0                   VECTOR MASK MODE NOT WANTED
*
         VSTVP #10                 GET SECTION SIZE (= MAX VEC COUNT)
         SRL   #10,16              RIGHT JUSTIFY THE SECTION SIZE
         BCTR  #10,0               WE NEED ONE LESS THAN MULTIPLE OF
         VLVCA 0(#10)              SET VECTOR COUNT TO MAX-1
*
         L     #1,=X'FF404040'     FREE-LIST CAR PATTERN FOR DEBUGGING
         VRCL  B'11111111'         CLEAR ALL VECTOR REGS, ZERO THE VIX
         VLQ   #V2,#1              SPREAD PATTERN TO VECTOR OF CARS
         LR    #0,#3               ADDRESS OF FRST CAR TO LOAD AND MASK
         LR    #1,#3               ADDRESS OF FIRST CAR TO COMPARE
         LR    #2,#3               ADDRESS OF FIRST CAR TO STORE
         XR    #5,#5               CLEAR COUNT OF FREE CELLS
         LA    #6,2                STRIDE TO SAME HALF OF NEXT CONS
         LR    #7,#3               ADDRESS FOR GENERATING VEC OF POINTR
*
         SLL   #10,3               VECTOR COUNT IN EQUIV. CONS BYTES
         LR    #8,#4               GET TOP OF CONS SPACE
         SR    #8,#10              REDUCE BY LENGTH OF ONE SECTION
         SRL   #10,3               RESTORE VECTOR COUNT TO # OF ELEMNTS
*
         L     #9,=X'FFFFFFFC'     AND-MASK FOR CLEARING GC BITS
         LA    #14,8               CONS-CELL-STRIDE IN BYTES
         LA    #15,VMASK           ADDRESS FOR VECTOR MASK
*---------------------------------------------------------------------*
*      PROCESS THE FIRST VECTOR SECTION OF CONS CELLS                 *
*---------------------------------------------------------------------*
         VNS   #V0,#9,#0(#6)       LOAD 128 CDRS & CLEAR GC BITS
         VC    #VE,#V0,#1(#6)      SET MASK BITS AT UNMARKED CELLS
         VST   #V0,#2(#6)          STORE ALL 128 GC-BIT-CLEARED CDRS
         VSTMD #V2,#3              NOT MUCH STORED, BUT UPDATES #3
         VCOVM #5                  UPDATE COUNT OF FREE CELLS
         VLINT #V1,#7(#14)         LOAD ADDRESSES OF THESE 128 CELLS
         VLMR  #V3,#V1             UPDATE ONLY FREED POINTER ELEMENTS
         VLMR  #V5,#V1             UPDATE POINTERS TO FIRST FREE CELLS
         BO    VA3GO               FREE CELL FOUND IN ALL ELEMENTS
         VCVM                      CONVERT BITS OF FOUND TO NOT FOUND
         VSTVM #15                 STORE BIT MASK OF NOT FOUND FREE
         CLR   #0,#4               COMPARE WITH END OF CONS SPACE
         BNL   VAEND               ALL CONS CELLS PROCESSED
*---------------------------------------------------------------------*
*      CONTINUE CLEARING GC BITS AND FINDING FIRST FREE CELLS         *
*---------------------------------------------------------------------*
VA2LOOP  LA    #15,VMASK           ADDRESS FOR VECTOR MASK
         VNS   #V0,#9,#0(#6)       LOAD 128 CDRS & CLEAR GC BITS
         VC    #VE,#V0,#1(#6)      SET MASK BITS AT UNMARKED CELLS
         VST   #V0,#2(#6)          STORE ALL 128 GC-BIT-CLEARED CDRS
         VSTMD #V2,#3              STORE PATTERN, UPDATE POINTERS LATER
         VCOVM #5                  UPDATE COUNT OF FREE CELLS
         VLINT #V1,#7(#14)         LOAD ADDRESSES OF THESE 128 CELLS
         VLMR  #V3,#V1             UPDATE ONLY FREED POINTER ELEMENTS
         VNVM  #15                 AND FREE-FOUND WITH NOT-FOUND
         LA    #15,VMASK           REINITIALIZE FOR VECTOR MASK
         VLMR  #V5,#V3             UPDATE POINTERS TO FIRST FREE CELLS
         VXVM  #15                 EXCLUSIVE OR SAVE-FREE WITH NO-FOUND
         LA    #15,VMASK           REINITIALIZE FOR VECTOR MASK
         VTVM                      TEST VECTOR BIT MASK
         BZ    VA3GO               FREE CELLS FOUND IN ALL ELEMENTS
         VSTVM #15                 STORE NEW MASK OF NOT-FOUND FREE
         CLR   #0,#4               COMPARE WITH END OF CONS SPACE
         BL    VA2LOOP             MORE CONS CELLS LEFT, CONTINUE
*---------------------------------------------------------------------*
*      TERMINATE WITH AN INCOMPLETE SECTION SET OF FREE CELLS AND     *
*      LINK TOGETHER AN INCOMPLETE SET OF FREE LISTS                  *
*---------------------------------------------------------------------*
         VCVM                      MAKE MASK "FOUND FREE CELLS"
* ===> SEB1525
         L     #1,ZLCGCBVA         POINT TO "VTEMP" WORK AREA
         VSTK  #V3,#1              STORE ALL FIRST FREE-CELL ADDRESSES
*
* ===> SEB1525 - MAYBE YOU CAN LR #2,#1 BEFORE VSTK, THEN L #9,0(,#2)?
*
         L     #1,ZLCGCBVA         POINT TO "VTEMP" WORK AREA
         L     #9,0(,#1)           SAVE ADDRESS OF FIRST FREE CELL
*
* ===> SEB1525 CHANGED THE XC - YOU CAN CHANGE IT BACK IF YOU WANT
*
******** XC    0(4,#1),0(#1)       LAST ONE FREE-CELL WILL BE 0
         XR    #2,#2               CLEAR TO FOR COUNT-ALL-ONES
         ST    #2,0(,#1)           LAST ONE FREE-CELL WILL BE 0
         VCOVM #2                  COUNT LISTS WITH FREE CELLS
         BZ    VABZERO9            NO FREE CELLS FOUND
*
* ===> SEB1525 ASSUMES #1 STILL POINTS TO "VTEMP" HERE.  IS THIS TRUE?
*
         LA    #1,4(,#1)           OFFSET 1 WORD FOR ELEMENT-SHIFT
         VLVCA 0(#2)
         VL    #V3,#1
* ===> SEB1525
         L     #1,ZLCGCBVA
         VLVCA 512
         VSTK  #V5,#1
* ===> SEB1525
         L     #1,ZLCGCBVA
         VLVCA 0(#2)
         VL    #V5,#1
         VSRL  #V5,#V5,3
         VSTID #V2,#V5,0
         B     VARETURN
*---------------------------------------------------------------------*
*  CLEAR GC BITS AND LINK FREE CELLS IN ALL ELEMENTS OF SECTION       *
*  IN MOST CASES, MOST OF THE TIME IS SPENT IN THIS LOOP              *
*---------------------------------------------------------------------*
VA3GO    CLR   #0,#4               ---THIS PATH HARD TO TEST---
         BH    VAEND
*
VA3LOOP  VNS   #V0,#9,#0(#6)       LOAD 128 CDRS & CLEAR GC BITS
         VC    #VE,#V0,#1(#6)      SET MASK BITS AT UNMARKED CELLS
         VST   #V0,#2(#6)          STORE ALL 128 GC-BIT-CLEARED CDRS
         VSTMD #V2,#3              STORE PATTERN & POINTER TO LAST FREE
         VCOVM #5                  UPDATE COUNT OF FREE CELLS
         VLINT #V1,#7(#14)         LOAD ADDRESSES OF THESE 128 CELLS
         VLMR  #V3,#V1             UPDATE ONLY FREED POINTER ELEMENTS
         CLR   #0,#4
         BL    VA3LOOP
*---------------------------------------------------------------------*
*  TERMINATION - LINK TOGETHER ALL THE FREE LISTS                     *
*---------------------------------------------------------------------*
VAEND    DS    0H
* ===> SEB1525
         L     #1,ZLCGCBVA
         VST   #V3,#1
*
* ===> SEB1525 - MAYBE YOU CAN LR #2,#1 BEFORE VST, THEN L #9,0(,#2)?
*
         L     #1,ZLCGCBVA
         L     #9,0(,#1)           SAVE POINTER TO FIRST FREE CELL
         XC    0(4,#1),0(#1)       LAST FREE CELL MUST HAVE CDR=0
* ===> SEB1525
         LA    #1,4(,#1)           OFFSET 1 WORD FOR ELEMENT-SHIFT
         VL    #V3,#1
         VSRL  #V5,#V5,3
         VSTID #V2,#V5,0
         B     VARETURN
*
.VECTORB ANOP
         EJECT
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
* REGISTER USAGE FOR VECTOR SWEEP "B":                                *
*                                                                     *
* #0  - POINTER FOR VNS VECTOR INSTRUCTION                            *
* #1  - POINTER FOR VC VECTOR INSTRUCTION                             *
* #2  - POINTER FOR VST VECTOR INSTRUCTION                            *
* #3  - LOWER BOUND OF CONS SPACE                                     *
* #4  - UPPER BOUND OF CONS SPACE                                     *
* #5  - FREE CELL COUNT                                               *
* #6  - CONSTANT 2 = STRIDE OF CONS CELL IN 4-BYTE WORDS              *
* #7  - TEMPORARY                                                     *
* #8  - ADDRESS OF BIT VECTOR                                         *
* #9  - FFFFFFFC MASK, POINTER TO FREE LIST                           *
* #10 - NIL (NOT USED HERE)                                           *
* #11 - POSSIBLY BUT NOT NECESSARILY USED FOR STACK PROCESSING        *
* #12 - LOCAL BASE REGISTER FOR THIS ROUTINE                          *
* #13 - THE COMMON AREA, AS IN THE REAL WORLD                         *
* #14 - INDEX FOR VLBIX VECTOR INSTRUCTION                            *
* #15 - BITVECTOR STORE POINTER, COUNT FOR VLBIX VECTOR INSTRUCTION   *
*                                                                     *
* VECTOR REGISTER USAGE                                               *
*                                                                     *
* #V0 - MASKED CARS OF CONS CELLS                                     *
* #V1 - FREE CELL ELEMENT COUNTS * 8                                  *
* #V2 - PATTERN X'FF404040' STORED AS CAR OF FREE LIST CELLS          *
* #V3 - ADDRESS OF LAST FREE CELL FOUND BY VECTOR ELEMENT             *
*---------------------------------------------------------------------*
VBSTART  DS    0H
         ICM   #1,15,ZLCGCBVA      GET ADDRESS OF GC SWEEP WORK AREA
         BNZ   VBGOTWA             IF ZERO, THEN...
*---------------------------------------------------------------------*
* COMPUTE SIZE OF BIT VECTOR NEEDED.  THIS IS ONE BIT PER CONS CELL,  *
* WHERE EACH CONS CELL IS A DOUBLEWORD.  THUS, THE TOTAL NUMBER OF    *
* BYTES IN CONS SPACE, DIVIDED BY 8 TO GET # OF DOUBLEWORDS, AND      *
* DIVIDED AGAIN BY 8 TO GET # OF BYTES TO HOLD THAT MANY BITS,        *
* GIVES THE REQUIRED LENGTH OF THE BIT VECTOR IN BYTES.               *
*---------------------------------------------------------------------*
         VSTVP ZLCGCBVL             Store vector parameters
         LA    #1,1                 An extra double-word for tie
         AH    #1,ZLCGCBVL          Add the section sizen size
         SLL   #1,3                 Multiply by 8 - bytes for VTEMP
         ST    #1,VTEMPSZ           Stor VTEMP size
         L     #0,ZLCNFREE          get size of CONS space in dblwrds
*                                   the same as # of bits in bitvector
         SRL   #0,3                 Convert to # of bytes in bitvector
         ALR   #1,#0                Add for total length required
*
         LA    #0,7(,#1)
         N     #0,=X'FFFFFFF8'      ROUND UPWN TO NEXT DOUBLEWORD
         ST    #0,ZLCGCBVL          SAVE LENGTH
         #GETMAIN RC,LV=(0),LOC=ANY TRY TO GET IT
         LTR   #15,#15              IF FAILED
         BNZ   GERROR               THEN DISASTER
         ST    #1,ZLCGCBVA          ELSE STORE ADDRESS OF GC WA
VBGOTWA  STM   #14,#8,VSAVE        SAVE REGISTERS DURING VECTOR SWEEP
         VSVMM 0                   VECTOR MASK MODE NOT WANTED
         VLVCA 512                 SET VECTOR COUNT TO MAXIMUM
*
         L     #8,ZLCGCBVA         GET ADDRESS OF GC WORK AREA
         AL    #8,VTEMPSZ          POINT TO OFFSET OF LONG BIT-VECTOR
*
         L     #1,=X'FF404040'     FREE-LIST CAR PATTERN FOR DEBUGGING
         VRCL  B'11111111'         CLEAR ALL VECTOR REGS, ZERO THE VIX
         VLQ   #V2,#1              SPREAD PATTERN TO VECTOR OF CARS
         L     #9,=X'FFFFFFFC'     AND-MASK FOR CLEARING GC BITS
         LR    #0,#3               ADDRESS OF FRST CAR TO LOAD AND MASK
         LR    #1,#3               ADDRESS OF FIRST CAR TO COMPARE
         LR    #2,#3               ADDRESS OF FIRST CAR TO STORE
         XR    #5,#5               CLEAR COUNT OF FREE CELLS
         LA    #6,2                STRIDE TO SAME HALF OF NEXT CONS
         LR    #15,#8              GET ADDRESS OF LONG BIT-VECTOR
*
VB1LOOP  VNS   #V0,#9,#0(#6)       LOAD 128 CARS & CLEAR GC BITS
         VC    #VE,#V0,#1(#6)      SET MASK BITS AT UNMARKED CELLS
         VST   #V0,#2(#6)          STORE ALL 128 GC-BIT-CLEARED CARS
         VCOVM #5                  UPDATE COUNT OF FREE CELLS
         CLR   #0,#4               COMPARE WITH END OF CONS SPACE
         VSTVM #15                 STORE BIT MASK OF NOT FOUND FREE
         BL    VB1LOOP             NOT ALL CONS CELLS CLEARED
*
         XR    #14,#14             CLEAR BIT INDEX
         L     #15,ZLCNFREE        Get number of cons cells
         VLBIX #V0,#14,0(#8)       GENERATE OFFSET NUMBERS FOR SET BITS
         VSLL  #V1,#V0,3           ELEMENT OFFSETS X 8 = BYTE OFFSETS
         L     #1,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS
         LR    #9,#1               Save address of first element
         VST   #V1,#1              STORE FREE POINTERS IN TEMP AREA
         L     #9,0(,#9)           LOAD OFFSET TO FIRST FREE CELL
         LA    #9,0(#9,#3)         ADD TO BOTTOM TO GET ACTUAL POINTER
         BO    VB2ONCE             ONLY ONE SECTION OF FREE CELLS
         BZ    VABZERO9            NO FREE CELLS FOUND
*
VB2LOOP  L     #7,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS
         SH    #1,=H'4'            BACK UP ONE POINTER
         LA    #0,4(,#7)           GET SKEWED (BY 1) POINTER OFFSETS
         L     #7,0(,#1)           OFFSET OF FREE CELL TO BE UPDATED
         VAS   #V3,#3,#0           ADD TO BOTTOM TO GET ACTUAL POINTERS
         VSTID #V2,#V0,0(#3)       CREATE A SECTION OF THE FREE LIST
         VLBIX #V0,#14,0(#8)       GEN MORE OFFSET NUMBERS OF SET BITS
         BZ    VB2ZERO             NO 1 bits found
         L     #1,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS
         VSLL  #V1,#V0,3           ELEMENT OFFSETS X 8 = BYTE OFFSETS
         LR    #2,#1               Get pointer to temp free pointers
         VST   #V1,#1              STORE FREE POINTERS IN TEMP AREA
         L     #2,0(,#2)           GET OFFSET TO STORE IN FREE CELL
         LA    #2,0(#2,#3)         CALCULATE ADDRESS TO STORE IN CELL
         ST    #2,##CDR(#7,#3)     STORE INTO LINK FROM PREV VECTOR
         BP    VB2LOOP             (COND CODE FROM VLBIX) ANOTHER SECT
*
VB2ONCE  SH    #1,=H'4'            BACK UP ONE POINTER
         L     #2,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS
         L     #7,0(,#1)           OFFSET OF FREE CELL TO BE UPDATED
         LA    #0,4(,#2)           GET SKEWED (BY 1) POINTER OFFSETS
         VAS   #V3,#3,#0           ADD TO BOTTOM TO GET ACTUAL POINTERS
         VSTID #V2,#V0,0(#3)       CREATE A SECTION OF THE FREE LIST
*
VB2ZERO  XR    #2,#2               GENERATE 0
         ST    #2,##CDR(#7,#3)     STORE 0 IN CDR OF LAST FREE CELL
*
         B     VBRETURN
VABZERO9 L     #9,ZLCGCEND         NO CELLS FOUND, ZERO REG 9
*
VBRETURN DS    0H
VARETURN ST    #5,VSAVE+7*4        SET NEW VALUE OF #5 (FREE COUNT)
         LM    #14,#8,VSAVE        RELOAD SAVED REGS AND UPDATED #5
         AGO   .ASWEEP
*----------------------------------------------------------------------
* VECTOR-C algorithm
*----------------------------------------------------------------------
.VECTORC ANOP
         EJECT
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
* REGISTER USAGE FOR VECTOR SWEEP "C":                                *
*                                                                     *
* #0  - POINTER FOR VNS VECTOR INSTRUCTION                            *
* #1  - POINTER FOR VC VECTOR INSTRUCTION                             *
* #2  - POINTER FOR VST VECTOR INSTRUCTION                            *
* #3  - LOWER BOUND OF CONS SPACE                                     *
* #4  - UPPER BOUND OF CONS SPACE                                     *
* #5  - FREE CELL COUNT                                               *
* #6  - CONSTANT 2 = STRIDE OF CONS CELL IN 4-BYTE WORDS              *
* #7  - TEMPORARY                                                     *
* #8  - ADDRESS OF BIT VECTOR                                         *
* #9  - FFFFFFFC MASK, POINTER TO FREE LIST                           *
* #10 - Count of free cells to reach before VLBIX can go              *
* #11 - Bitvector store pointer                                       *
* #12 - LOCAL BASE REGISTER FOR THIS ROUTINE                          *
* #13 - THE COMMON AREA, AS IN THE REAL WORLD                         *
* #14 - INDEX FOR VLBIX VECTOR INSTRUCTION                            *
* #15 - Count for VLBIX vector instruction                            *
*                                                                     *
* VECTOR REGISTER USAGE                                               *
*                                                                     *
* #V0 - MASKED CARS OF CONS CELLS, also free cell index in VLBIX      *
* #V1 - FREE CELL ELEMENT COUNTS * 8                                  *
* #V2 - PATTERN X'FF404040' STORED AS CAR OF FREE LIST CELLS          *
* #V3 - ADDRESS OF LAST FREE CELL FOUND BY VECTOR ELEMENT             *
*                                                                     *
* COMPUTE SIZE OF BIT VECTOR NEEDED.  THIS IS ONE BIT PER CONS CELL,  *
* WHERE EACH CONS CELL IS A DOUBLEWORD.  THUS, THE TOTAL NUMBER OF    *
* BYTES IN CONS SPACE, DIVIDED BY 8 TO GET # OF DOUBLEWORDS, AND      *
* DIVIDED AGAIN BY 8 TO GET # OF BYTES TO HOLD THAT MANY BITS,        *
* GIVES THE REQUIRED LENGTH OF THE BIT VECTOR IN BYTES.               *
*                                                                     *
* Here are the first 130 words of the GETMAINED area.  All words      *
* starting at #8 pointer (130th word = 129 by zero-based count).      *
* Some of the address pointer storages are indicated below.  The      *
* "@" sign indicates exactly where these storage locations point.     *
*                                                                     *
* +-----+-----+-----+-----+-----+-----+-----//-----+-----+-----+-----+*
* |   0 |   1 |   2 |   3 |   4 |   5 |   6    126 | 127 |blank|bitv>|*
* +-----+-----+-----+-----+-----+-----+-----//-----+-----+-----+-----+*
* @ ZLCGCBVA                                       @ VTEMPTOP  @ #8   *
*       @ VTEMP4                                                      *
*                                                                     *
* In this version of the sweep phase, washing of the cache is         *
* reduced by doing all the work in one pass through the memory.       *
* The innermost loop, VC3LOOP, is performed only as many times        *
* as is needed by the outer loop, VC2LOOP, so that it will have       *
* another 128 free-cells to chain.  When the free cells are sparse,   *
* the inner loop will spin many times for each iteration of the       *
* outer loop with the VLBIX instruction.  In areas where almost all   *
* cells are free, the inner loop will probably execute just once,     *
* such that there is no extra looping in VC3LOOP when compared with   *
* VC2LOOP.  VC3LOOP only spins extra when the outer loop is not       *
* getting enough free cells.                                          *
*---------------------------------------------------------------------*
VCSTART  ICM   #1,15,ZLCGCBVA      GET ADDRESS OF GC SWEEP WORK AREA
         BNZ   VCGOTWA             IF ZERO, THEN...
*
         VSTVP VGCVP                Store vector parameters
         LA    #1,1                 An extra word for tie
         AH    #1,VGCVP             Add the section size in elements
         SLL   #1,2                 Multiply by 4 - bytes for VTEMP
         ST    #1,VTEMPSZ           Stor VTEMP size
         L     #0,ZLCNFREE          get size of CONS space in dblwrds
*                                   the same as # of bits in bitvector
         SRL   #0,3                 Convert to # of bytes in bitvector
         ALR   #1,#0                Add for total length required
*
         LA    #0,7(,#1)
         N     #0,=X'FFFFFFF8'      ROUND UP TO NEXT DOUBLEWORD
         ST    #0,ZLCGCBVL          SAVE LENGTH
         #GETMAIN RC,LV=(0),LOC=ANY TRY TO GET IT
         LTR   #15,#15              IF FAILED
         BNZ   GERROR               THEN DISASTER
         ST    #1,ZLCGCBVA          ELSE STORE ADDRESS OF GC WA
VCGOTWA  STM   #14,#11,VSAVE       SAVE REGISTERS DURING VECTOR SWEEP
*
         VSVMM 0                   VECTOR MASK MODE NOT WANTED
         VLVCA 512                 SET VECTOR COUNT TO MAXIMUM
         L     #8,ZLCGCBVA         GET ADDRESS OF GC WORK AREA
         LA    #7,4(,#8)           generate address for VTEMP4
         AL    #8,VTEMPSZ          Point to address of long bitvector
         ST    #7,VTEMP4           Store address for temporary load
*
         L     #1,=X'FF404040'     FREE-LIST CAR PATTERN FOR DEBUGGING
         VRCL  B'11111111'         CLEAR ALL VECTOR REGS, ZERO THE VIX
         VLQ   #V2,#1              SPREAD PATTERN TO VECTOR OF CARS
         L     #9,=X'FFFFFFFC'     AND-MASK FOR CLEARING GC BITS
         LR    #0,#3               ADDRESS OF FRST CAR TO LOAD AND MASK
         LR    #1,#3               ADDRESS OF FIRST CAR TO COMPARE
         LR    #2,#3               ADDRESS OF FIRST CAR TO STORE
         XR    #5,#5               CLEAR COUNT OF FREE CELLS
         LA    #6,2                STRIDE TO SAME HALF OF NEXT CONS
         LH    #10,VGCVP           First half of VGCVP is section size
         LR    #11,#8              GET ADDRESS OF LONG BIT-VECTOR
*
VC1LOOP  VNS   #V0,#9,#0(#6)       LOAD 128 CARS & CLEAR GC BITS
         VC    #VE,#V0,#1(#6)      SET MASK BITS AT UNMARKED CELLS
         VST   #V0,#2(#6)          STORE ALL 128 GC-BIT-CLEARED CARS
         VCOVM #5                  UPDATE COUNT OF FREE CELLS
         CLR   #0,#4               COMPARE WITH END OF CONS SPACE
         VSTVM #11                 STORE BIT MASK OF NOT FOUND FREE
         BNL   VC1DONE             NOT ALL CONS CELLS CLEARED
         CLR   #5,#10              Not 128 free cells found?
         BL    VC1LOOP             Try to find enough for at least 128
*
VC1DONE  XR    #14,#14             CLEAR BIT INDEX
         L     #15,ZLCGCACD        Get number of cons cells
         VLBIX #V0,#14,0(#8)       GENERATE OFFSET NUMBERS FOR SET BITS
         VSLL  #V1,#V0,3           ELEMENT OFFSETS X 8 = BYTE OFFSETS
         L     #2,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS
         VST   #V1,#2              STORE FREE POINTERS IN TEMP AREA
         L     #6,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS
         L     #6,0(,#6)           LOAD OFFSET TO FIRST FREE CELL
         LA    #6,0(#6,#3)         ADD TO BOTTOM TO GET ACTUAL POINTER
         ST    #6,VSAVE+11*4       Pointer to first free cell ret in #9
         BO    VC2ONCE             ONLY ONE SECTION OF FREE CELLS
         BZ    VCZERO9             NO FREE CELLS FOUND
*
VC2LOOP  L     #7,VTEMP4           LOAD ADDRESS OF TEMP FREE POINTERS
         SH    #2,=H'4'            Back up to pointer to last free cell
         VAS   #V3,#3,#7           ADD TO BOTTOM TO GET ACTUAL POINTERS
         L     #7,0(,#2)           Get offset pointer to last free cell
         VSTID #V2,#V0,0(#3)       CREATE A SECTION OF THE FREE LIST
         AH    #10,VGCVP           Add section size
VC3LOOP  CLR   #0,#4               COMPARE WITH END OF CONS SPACE
         BNL   VC3DONE             NOT ALL CONS CELLS CLEARED
         LA    #6,2                STRIDE TO SAME HALF OF NEXT CONS
         VNS   #V0,#9,#0(#6)       LOAD 128 CARS & CLEAR GC BITS
         LR    #0,#1               Reload same address for VST
         VC    #VE,#V0,#1(#6)      SET MASK BITS AT UNMARKED CELLS
         VST   #V0,#0(#6)          STORE ALL 128 GC-BIT-CLEARED CARS
         VCOVM #5                  UPDATE COUNT OF FREE CELLS
         VSTVM #11                 STORE BIT MASK OF NOT FOUND FREE
         CLR   #5,#10              Not 128 free cells found?
         BL    VC3LOOP             Try to get enough for at least 128
VC3DONE  VLBIX #V0,#14,0(#8)       GEN MORE OFFSET NUMBERS OF SET BITS
         BZ    VC2ZERO             No 1 bits found, vector count=0
         L     #2,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS
         VSLL  #V1,#V0,3           ELEMENT OFFSETS X 8 = BYTE OFFSETS
         VST   #V1,#2              STORE FREE POINTERS IN TEMP AREA
         L     #6,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS
         L     #6,0(,#6)           GET OFFSET TO STORE IN FREE CELL
         LA    #6,0(#6,#3)         CALCULATE ADDRESS TO STORE IN CELL
         ST    #6,##CDR(#7,#3)     STORE INTO LINK FROM PREV VECTOR
         BP    VC2LOOP             (COND CODE FROM VLBIX) ANOTHER SECT
*                               ***BZ could be moved down here?
*
VC2ONCE  L     #7,VTEMP4           LOAD ADDRESS OF TEMP FREE POINTERS
         SH    #2,=H'4'            Back up to pointer to last free cell
         VAS   #V3,#3,#7           ADD TO BOTTOM TO GET ACTUAL POINTERS
         L     #7,0(,#2)           Get offset pointer to last free cell
         VSTID #V2,#V0,0(#3)       CREATE A SECTION OF THE FREE LIST
VC2ZERO  XR    #2,#2               GENERATE 0
         ST    #2,##CDR(#7,#3)     STORE 0 IN CDR OF LAST FREE CELL
         LA    #0,0(#7,#3)         Point to that there last free cell
         ST    #0,LASTFREE         Save pointer thereto
         B     VCEXPCHK
VCZERO9  DS    0H
         XR    #7,#7               Originally no free, so last new=0
         ST    #7,VSAVE+11*4       Set saved #9 to zeroes
         ST    #7,LASTFREE         Pointer to last free cell = null
*---------------------------------------------------------------------*
* If the amount of free space remaining is below the threshold        *
* (currently 1/2), then we dynamically expand the cons space by       *
* bringing in another section of allocated-but-not-active cons        *
* space (equal in size to what we already have active) and            *
* chaining it to the existing free list.                              *
*                                                                     *
* At this point, register 3 = ZLCGCACP which is the pointer to the    *
* bottom of the active CONS space.                                    *
*---------------------------------------------------------------------*
VCEXPCHK L     #7,ZLCGCACD         Total # of CONS cells in active
         SRL   #7,1                Divide this number by 2
         CR    #5,#7               Compare free # found with 1/2 total
         BH    VCNOMORE            More than half is still free?
         C     #3,ZLCCSADR         Compare with absolute bottom
         BNH   VCNOMORE            Can't expand if it's already max
         SLL   #7,5                8*2*2*(# cells/2) = 2*size in bytes
         LR    #8,#4               Compute address of bottom of new
         SR    #8,#7                active size (top - new length)
         C     #8,ZLCCSADR         If less than total CS allocated
         BNL   VCEXPOK             then
         L     #8,ZLCCSADR          use total allocated
VCEXPOK  ST    #8,ZLCGCACP         Save new active CS pointer
         ST    #8,VSAVE+5*4        Set saved #3 to CONS lower bound
         LR    #7,#4               (don't change live #3, -> old)
         SR    #7,#8               Recompute true length of new active
         SRL   #7,3                 CONS space and convert to number of
         ST    #7,ZLCGCACD           doublewords, and save this value
*
         LR    #7,#3               Get old bottom-of-CONS address
         SR    #7,#8               Subtract new lower bottom-of-CONS
         SRL   #7,3                Divide by 8 to get cnt of new cells
         AR    #5,#7               Add count to existing free count
*
         VLVCA 512                 Get section size
         LR    #1,#8               Get address of new active CS block
         LA    #8,8                Set stride for doublewords
         LA    #0,8(,#1)           Set pointer to first indirect value
VCFREE   VLINT #V3,#0(#8)          Load a vector of pointers to cells
         VSTD  #V2,#1              Store CARs (pattern) & CDRs (chain)
         CLR   #1,#3               Loop until we hit previously active
         BL    VCFREE               CS block (i.e. end of new block)
         SH    #1,=H'8'            Bump back to last cell in new block
         XR    #2,#2               Set chain pointer to zero
         ST    #2,##CDR(,#1)        (i.e. will be end of new free list)
         L     #1,ZLCGCACP         Get ptr to new active space again
         ICM   #2,15,LASTFREE      Get pointer to old last free cell
         BZ    VCXNFREE            If there was one, then
         ST    #1,##CDR(,#2)        hook new free list to end of old
         B     VCXAF               else (no free cells in old space)
VCXNFREE ST    #1,VSAVE+11*4        set saved #9 to 1st new free cell
VCXAF    DS    0H                  Now we have one good free list.
         ST    #5,VSAVE+7*4        SET NEW VALUE OF #5 (FREE COUNT)
*
* Not required, but in case we ever use ZLCGCACF...
*
         ST    #5,ZLCGCACF         Save last-uncovered # of free cells
*
* End of code that sets ZLCGCACF
*
         LM    #14,#11,VSAVE       RELOAD SAVED REGS AND UPDATED #5
*              #9 now points to the beginning of the free list.
         B     GCCHECK
*
VCNOMORE ST    #5,VSAVE+7*4        SET NEW VALUE OF #5 (FREE COUNT)
         LM    #14,#11,VSAVE       RELOAD SAVED REGS AND UPDATED #5
         LTR   #5,#5
         BNZ   GCCHECK
         L     #9,ZLCGCEND         NO CELLS FOUND, ZERO REG 9
         B     GCCHECK             Jump out of here
         EJECT
*----------------------------------------------------------------------
.ASWEEP  ANOP  ,
*----------------------------------------------------------------------
*---------------------------------------------------------------------*
*  Optional test code for doing a thorough check on the structure of  *
*  the free-list.  Use for debugging and system testing only.         *
*                                                                     *
* To activate, decomment the code following GCCHECK and comment out   *
* the "GCCCHECK EQU GCDONE" statement.                                *
*                                                                     *
* Currently, we activate this check for scalar code only.             *
*                                                                     *
*---------------------------------------------------------------------*
*----------------------------------------------------------------------
         AIF   (&ZILVF).NOGCCK
         AGO   .NOGCCK             Actually, always bypass the check.
*----------------------------------------------------------------------
         SPACE 1
GCCHECK  DS    0H
         CL    #9,ZLCGCEND         Are we at the end
         BE    GCDONE              OK, the first one is the last.
         STM   #14,#11,VSAVE       More work needed, save registers
         XR    #2,#2               Clear toggle for free-list check
         LA    #6,1                We have one free cell so far
CHKMORE  CLR   #9,#3               Free cell higher than space bottom?
         BL    CHKERR1             No, then error in free list
         CLR   #9,#4               Free cell lower than top of space?
         BNL   CHKERR2             No, then error in free list
         LR    #7,#9               Make extra copy of pointer to cell
         N     #7,=X'00000007'     Leave only the 3 least sig. bits
         BNZ   CHKERR3             They better be zero, or we go to err
         LR    #7,#9               Save pointer to free list cell
         L     #9,##CDR(,#9)       Chain down free list one more
         LTR   #9,#9               Is it the end?
         BZ    CHKEND              If zero, yes it is end of free list
         LA    #6,1(,#6)           Passed most checks, add one to count
         CLR   #6,#5               Is count higher than reported?
         BH    CHKERR4             Count can't be higher, report error
         CLR   #9,#7               This cell higher in mem than last?
         BH    CHKMORE             Good, check next cell in free list
         X     #2,=F'1'            Toggle free-list drop-down flag
         BNZ   CHKMORE             Toggling it set it, right?
         B     CHKERR5             Oops, free list downwards twice!
CHKERR1  LA    #2,1111
         B     CHKERR
CHKERR2  LA    #2,1112
         B     CHKERR
CHKERR3  LA    #2,1113
         B     CHKERR
CHKERR4  LA    #2,1114
         B     CHKERR
CHKERR5  LA    #2,1115
         B     CHKERR
CHKERR6  LA    #2,1116
         B     CHKERR
CHKERR   ST    #2,VSAVE+4*4
         LM    #14,#11,VSAVE
         NI    ZLCIFLGS,255-ZLCISMC
         TM    ZLCIFLGS,ZLCIATTN   If attention interrupt occurred
         BOR   #13                 then go to handle it
         LA    #1,FLERR
         LA    #0,L'FLERR
         TPUT  (1),(0),R
         L     #2,VSAVE+4*4
         ABEND (2),DUMP
         SPACE 1
FLERR    DC    C'ZILCONS VECTOR-C FREE LIST ERROR!!!'
         SPACE 1
CHKEND   CLR   #6,#5
         BNE   CHKERR6
         LM    #14,#11,VSAVE
         B     GCDONE
*----------------------------------------------------------------------
         AGO   .ENDGCCK
*----------------------------------------------------------------------
*----------------------------------------------------------------------
.NOGCCK  ANOP
*----------------------------------------------------------------------
GCCHECK  EQU   GCDONE              No free list checking done.
*----------------------------------------------------------------------
.ENDGCCK ANOP
*----------------------------------------------------------------------
         EJECT
GCDONE   DS    0H                  GARBAGE COLLECTION COMPLETE
         OI    ZLCGCFLG,ZLCGCDNE   SAY A GARBAGE COLLECTION WAS DONE
*
* CHANGE ENTRY POINT OF CONS TO REFER TO POST-COLLECTION ROUTINE
*
         XR    #0,#0               SET NEW END-OF-FREE-LIST POINTER
         ST    #0,ZLCGCEND         TO ZERO
         L     #15,=A(GCCONS)      LOAD POST-GARB-COLL ENTRY POINT
         ST    #15,ZLCCONS         UPDATE CONS POINTER IN COMMON
*
* RECORD CURRENT CPU TIME
*
         STIMER TASK,BINTVL=DUMS   DO DUMMY TO FORCE OS TIMER UPDATE
         L     #2,X'224'           GET ADDRESS OF ASCB
         MVC   GCTIME2,X'40'(#2)   GET JOB STEP ELAPSED TIME (ASCBEJST)
*
* UPDATE TOTAL GC TIME SO FAR FROM RECORDED CPU TIMES
*
         LM    #2,#3,GCTIME1       GET ELAPSED TIME AT START OF GC
         SRDL  #2,12               CONVERT FROM MICROSECONDS
         D     #2,=F'1000'         TO THOUSANDTHS OF A SECOND
         LR    #0,#3               GET RESULT INTO REGISTER
         LM    #2,#3,GCTIME2       GET ELAPSED TIME AT END OF GC
         SRDL  #2,12               CONVERT FROM MICROSECONDS
         D     #2,=F'1000'         TO THOUSANDTHS OF A SECOND
         LR    #1,#3               GET RESULT INTO REGISTER
         SR    #1,#0               SUBTRACT TO GET CPU TIME FOR THIS GC
         A     #1,ZLCGCTIM         ADD TO TOTAL GC TIME SO FAR
         ST    #1,ZLCGCTIM         UPDATE TOTAL GC TIME SO FAR
*
* END NON-INTERRUPTIBLE PART OF CODE
*
         NI    ZLCIFLGS,255-ZLCISMC    INTERRUPTIBLE NOW
         TM    ZLCIFLGS,ZLCIATTN   If attention interrupt occurred
         BOR   #13                 then go to handle it
*
* TELL USER HOW MANY FREE CELLS ARE NOW AVAILABLE
*
         LTR   #5,#5               IF NO FREE CELLS FOUND
         BZ    GCFULL              THEN SIGNAL ERROR
         SPACE 1
******** #TPUT 1,ZIL1102 ***********
         SPACE 1
         TM    ZLCGCFLG,ZLCGCMSG   IF MESSAGES ARE NOT TO BE SHOWN,
         BZ    AFTMSG2             THEN SKIP THIS SECTION
         SPACE 1
         MVC   ZIL1102(L'ZIL1102A),ZIL1102A   FIRST PART OF MESSAGE
         CVD   #5,ZLCDBL                      NUMBER OF FREE CELLS
         UNPK  ZIL1102+L'ZIL1102A(10),ZLCDBL  INTO MESSAGE AREA
         OI    ZIL1102+L'ZIL1102A+9,X'F0'
         LA    #1,ZIL1102+L'ZIL1102A  POINT TO CONVERTED # AREA
         LA    #2,9                INITIALIZE DECREMENT REGISTER
LOOP1102 DS    0H                  SEARCH FOR FIRST NONZERO
         CLI   0(#1),C'0'
         BNE   END1102
         LA    #1,1(,#1)
         BCT   #2,LOOP1102
END1102  DS    0H                  #2 = NUMBER LENGTH - 1
         EX    #2,MVC1102          LEFT JUSTIFY THE NUMBER IN PLACE
         LA    #3,ZIL1102+L'ZIL1102A+1(#2)  POINT PAST END OF NUMBER
         MVI   0(#3),C'/'          MOVE IN A SLASH
         L     #0,ZLCGCACD         GET NUMBER OF ACTIVE DOUBLEWORDS
         CVD   #0,ZLCDBL
         UNPK  1(10,#3),ZLCDBL
         OI    10(#3),X'F0'
         LA    #1,1(,#3)           POINT TO CONVERTED # AREA
         LA    #2,9                INITIALIZE DECREMENT REGISTER
LOOQ1102 DS    0H                  SEARCH FOR FIRST NONZERO
         CLI   0(#1),C'0'
         BNE   ENE1102
         LA    #1,1(,#1)
         BCT   #2,LOOQ1102
ENE1102  DS    0H                  #2 = NUMBER LENGTH - 1
         EX    #2,MVD1102          LEFT JUSTIFY THE NUMBER IN PLACE
         LA    #1,2(#3,#2)         POINT PAST END OF NUMBER
         MVC   0(L'ZIL1102B,#1),ZIL1102B    MOVE IN REST OF MESSAGE
         LA    #15,L'ZIL1102B(,#1)  POINT TO NEXT SEGMENT OF MESSAGE
         LR    #1,#15
         L     #2,ZLCVSADR         ADDRESS OF START OF V/S SPACE...
         A     #2,ZLCVSLEN         PLUS LENGTH OF V/S SPACE...
         S     #2,ZLCVSNXT         MINUS ADDRESS OF AVAILABLE SLOT...
         CVD   #2,ZLCDBL           GIVES LENGTH OF AVAILABLE V/S SPACE
         UNPK  0(10,#1),ZLCDBL     CONVERT TO DISPLAY
         OI    9(#1),X'F0'
         LA    #2,9                INITIALIZE DECREMENT REGISTER
LP1102C  CLI   0(#1),C'0'          SEARCH FOR FIRST NONZERO
         BNE   END1102C
         LA    #1,1(,#1)
         BCT   #2,LP1102C
END1102C DS    0H                  #2 = NUMBER LENGTH - 1
         EX    #2,MVC1102C         LEFT JUSTIFY THE NUMBER IN PLACE
         LA    #1,1(#15,#2)        POINT PAST END OF NUMBER
         MVC   0(L'ZIL1102C,#1),ZIL1102C  MOVE IN REST OF MESSAGE
         LA    #0,L'ZIL1102C(,#1)  GET TOTAL LENGTH OF MESSAGE
         LA    #1,ZIL1102           BY SUBTRACTING END OF MESSAGE
         SR    #0,#1                 FROM BEGINNING OF MESSAGE
         #TPUT *,(1),(0)              ISSUE THE MESSAGE
AFTMSG2  DS    0H
         SPACE 1
*
* RELOAD PARAMETER REGISTERS
*
         LM    #0,#8,ZSAVED0       DON'T RESTORE REGISTER 15
         LM    #10,#14,ZSAVED10    DON'T RESTORE REGISTER 9
         L     #15,ZLCCONS         GET ADDRESS OF NEW CONS ROUTINE
         BR    #15                 START OVER
         SPACE 2
MVC1102  MVC   ZIL1102+L'ZIL1102A(0),0(#1)  EXECUTED
MVD1102  MVC   1(*-*,#3),0(#1)              EXECUTED
MVC1102C MVC   0(*-*,#15),0(#1)             EXECUTED
         SPACE 2
*
* GARBAGE COLLECTION SEVERE ERROR - CANNOT RECOVER
*
GCERR    DS    0H
         #TPUT ZIL1104
         ABEND 1104,DUMP
         SPACE
*
* GARBAGE COLLECTION FOUND NO FREE CELLS - CANNOT RECOVER
*
GCFULL   DS    0H                  NO MORE FREE CELLS
*        #TPUT ZIL1101
*        ABEND 1101,DUMP
         XR    #9,#9               SET NEXT-CONS-CELL POINTER TO
*                                   "NO MORE CONS CELLS" VALUE
         #ZERR ZIL1101             DON'T ABEND; SIGNAL AN ERROR
         SPACE
*
* INVALID OBJECT FOUND IN VECTOR/STRING SPACE
*
BADVSOBJ DS    0H
         #TPUT ZIL1107
         ABEND 1107,DUMP
         EJECT
*
* NON-FORWARDED SYMBOL POINTER FOUND IN OBLIST HASH ARRAY
*
FHERROR  DS    0H
         #TPUT ZIL1110
         ABEND 1110,DUMP
         EJECT
         AIF   (NOT &ZILVF).NOGERR
*
* UNABLE TO GETMAIN GC WORK AREA
*
GERROR   DS    0H
         #TPUT ZIL1109
         ABEND 1109,DUMP
.NOGERR  ANOP
         EJECT
MARKLIST DS    0H
         SPACE
***********************************************************************
*                                                                     *
* THIS IS THE MAIN ROUTINE TO GO THROUGH A LISP OBJECT AND MARK ALL   *
* PARTS OF IT.  FOR THE PURPOSES OF THIS ROUTINE A SYMBOL IS TREATED  *
* AS A LIST WHOSE CAR IS A STRING (I.E. THE PRINT NAME) AND WHOSE CDR *
* IS A LIST, NAMELY THE PROPERTY LIST.  SIMILARLY, A CLOSURE IS       *
* TREATED AS A LIST WHOSE CAR IS A SPECIAL OBJECT (ACTUALLY A PIECE   *
* OF COMPILED CODE) AND WHOSE CDR IS A LIST, NAMELY THE ALIST.  NOTE  *
* THAT IN CASES WHERE THE PROPERTY LIST POINTER IS ZEROES, OR WHERE   *
* THE ALIST POINTER IS ZEROES (I.E. SUBR NOT A CLOSURE), THIS WILL    *
* FAIL THE "IN-CONS-SPACE-RANGE" TEST AND STILL WORK WITHIN THE LOGIC *
* OF THIS ROUTINE.  NOTE ALSO THAT OTHER TYPES OF CONSED ATOMS (I.E.  *
* FIXNUMS AND FLONUMS) ARE NOT CONSIDERED LISTS IN THIS FASHION;      *
* INSTEAD, THEY ARE SPECIALLY COLLECTED (THEY CONSIST OF 1 CONS WHICH *
* IS INDIVIDUALLY MARKED), SO NO PROBLEM THERE.                       *
*                                                                     *
* ON ENTRY REGISTER 1 POINTS TO THE OBJECT TO BE COLLECTED.           *
*          REGISTER 15 POINTS TO THE CELL TO BE UPDATED IF THAT CELL  *
*          POINTS TO AN OBJECT WHICH IS RELOCATED.                    *
*                                                                     *
***********************************************************************
         SPACE
N        EQU   #5                  SEE WINSTON & HORN 2ND ED. P. 148
P        EQU   #6                  SEE WINSTON & HORN 2ND ED. P. 148
Q        EQU   #7                  SEE WINSTON & HORN 2ND ED. P. 148
         SPACE 1
*
* INITIAL CHECK FOR NULL MOVED UP TO EXPEDITE DEGENERATE-CASE HANDLING
*
         CR    #1,#10              IF (NULL P)
         BER   #14                 THEN RETURN, NOTHING TO DO
         SPACE 1
         ST    #14,MARKSAVE        SAVE RETURN ADDRESS
         LR    P,#1                INIT P = ENTRY VALUE
         LR    N,#10               INIT N = NIL
         LR    Q,#10               INIT Q = NIL
         LA    #0,0(,P)            CLEAR HIGH ORDER BYTE OF P
         RCHK  #0,MARKRET          IF NOT IN CONS SPACE, SKIP COLLECT
         CLI   ##TYPE(P),##FLONUM  IF P IS A NUMBER
         BL    ISALIST             THEN...
         MARK  P                    IT'S A NUMERIC ATOM - MARK IT
         B     MARKRET              AND RETURN DOING NO MORE.
ISALIST  DS    0H                  ELSE INVOKE LIST MARKING ALGORITHM
         SPACE
LOOPCAR  DS    0H                  TRACK DOWN CAR.
         SPACE
* NOTE THIS IS THE ONLY POINT WHERE IT IS NECESSARY TO TURN ON THE
* SECONDARY MARKING BIT.  THIS INDICATES THAT THIS CELL, WHILE NOT
* YET OFFICIALLY MARKED, IS NOW PARTICIPATING IN THE COLLECTION
* PROCESS AND SHOULD NOT BE PROCESSED IF ENCOUNTERED WHILE GOING
* THROUGH THIS OR ANOTHER LIST LOOKING FOR COLLECTIBLE CONS CELLS.
         SPACE
         MARK2 P                                    SET TEMP GC MARK
         CLI   ##TYPE(P),##ATOM    IF NOT A SYMBOL OR A LIST
         BH    LOOPCDR             THEN CONTENTS OF CAR CELL NOT VALID
         GCAR  Q,P                 (SETQ Q (CAR P))
         LR    #15,P                                POINT TO POINTER
         LA    #0,0(,Q)                             CLEAR TYPE BITS
         CR    #0,#10              IF (NULL Q)
         BE    LOOPCDR                              THEN DO NOTHING
         RCHK  #0,LOOPCDR          IF NOT IN CONS SPACE, DO NOTHING
         IFMK  Q,YES=LOOPCDR       IF (MARKEDP Q)   THEN DO NOTHING
         CLI   ##TYPE(Q),##FLONUM  IF Q IS A NUMBER
         BL    REVCAR              THEN...
         MARK  Q                    IT'S A NUMERIC ATOM - MARK IT
         B     LOOPCDR              AND DO NOTHING (AS IF NULL).
REVCAR   DS    0H                  ELSE...
         RCAR  P,N                 (RPLACA P N)     REVERSE POINTER.
         LR    N,P                 (SETQ N P)
         LR    P,Q                 (SETQ P Q)
         B     LOOPCAR             (GO LOOPCAR)     CONTINUE DOWN CAR.
         SPACE
LOOPCDR  DS    0H                  TRACK DOWN CDR.
         SPACE
         MARK  P                   (MARKIT P)
         GCDR  Q,P                 (SETQ Q (CDR P)) TRACK DOWN CDR.
         LA    #15,##CDR(,P)                        POINT TO POINTER
         LA    #0,0(,Q)                             CLEAR TYPE BITS
         CR    #0,#10              IF (NULL Q)
         BE    LOOPCONS                             THEN DO NOTHING.
         RCHK  #0,LOOPCONS         IF NOT IN CONS SPACE, DO NOTHING
         IFMK  Q,YES=LOOPCONS      IF (MARKEDP Q)   THEN DO NOTHING
         CLI   ##TYPE(Q),##FLONUM  IF Q IS A NUMBER
         BL    REVCDR              THEN...
         MARK  Q                    IT'S A NUMERIC ATOM - MARK IT
         B     LOOPCONS             AND DO NOTHING (AS IF NULL).
REVCDR   DS    0H                  ELSE...
         RCDR  P,N                 (RPLACD P N)     REVERSE POINTER.
         LR    N,P                 (SETQ N P)
         LR    P,Q                 (SETQ P Q)
         B     LOOPCAR             (GO LOOPCAR)
         SPACE
LOOPCONS DS    0H
         SPACE
         LA    #0,0(,N)                             CLEAR TYPE BITS
         CR    #0,#10              IF (NULL N)      FINISHED MARKING?
         BE    MARKRET             THEN (RETURN)    THEN END. ELSE...
         LR    Q,N                 (SETQ Q N)       WAS CAR OF THIS
         IFMK1 Q,NO=REVCON         IF (MARKEDP Q)    DONE? IF SO...
         GCDR  N,Q                 (SETQ N (CDR Q)) UNDO
         RCDR  Q,P                 (RPLACD Q P)      POINTER
         LR    P,Q                 (SETQ P Q)         REVERSAL.
         B     LOOPCONS            (GO LOOPCONS)    CONTINUE UPWARDS.
REVCON   DS    0H                                   ELSE...
         MARK  Q                   (MARKIT Q)
         GCAR  N,Q                 (SETQ N (CAR Q)) UNDO
         RCAR  Q,P                 (RPLACA Q P)      POINTER
         LR    P,Q                 (SETQ P Q)         REVERSAL.
         B     LOOPCDR             (GO LOOPCDR)     STILL GOTTA DO CDR.
         SPACE 1
MARKRET  DS    0H
         L     #14,MARKSAVE        RESTORE RETURN ADDRESS
         BR    #14                 RETURN
         EJECT
RCHECK   DS    0H
*
* THIS ROUTINE CHECKS THE OBJECT PASSED IN #0 TO SEE IF IT IS IN
* CONS SPACE, AND RETURNS TO +0 IF IT ISN'T.  IF IT IS IN CONS
* SPACE, IT IS TO BE COLLECTED, AND THIS ROUTINE RETURNS +4.
*
* ONE THING, THOUGH: IF THE THING IS IN VECTOR/STRING SPACE, IT
* IS PULLED THROUGH THE RELOCATING/FORWARDING GC BEFORE WE RETURN
* SAYING THAT IT AIN'T IN CONS SPACE.  IN THIS WAY THINGS IN V/S
* SPACE GET GC'D WITHOUT MARKLIST KNOWING OR CARING.
*
* REGISTER 14 IS THE RETURN ADDRESS.
* REGISTER 15 POINTS TO THE POINTER TO BE UPDATED IF RELOCATION.
*
         CR    #0,#3               IF LT LOWER BOUND OF CONS SPACE
         BL    RTRYVS              THEN NOT IN CONS SPACE
         CR    #0,#4               IF GE UPPER BOUND OF CONS SPACE
         BNL   RTRYVS              THEN NOT IN CONS SPACE
         B     4(,#14)             ELSE IN CONS SPACE, RETURN SO.
RTRYVS   DS    0H                  NOT IN CONS SPACE, TRY V/S SPACE
         S     #0,ZLCVSADR         SEE IF LESS THAN V/S SPACE ADDRESS
         BMR   #14                 IF SO, IN NO SPACE, RETURN SO
         C     #0,ZLCVSLEN         SEE IF WITHIN USED V/S SPACE
         BNLR  #14                 IF NOT, IN NO SPACE, RETURN SO
* IT'S IN VECTOR/STRING SPACE - COLLECT IT.
         STM   #1,#4,VSSAVE        SAVE REGISTERS USED HERE
         LR    #2,#0
         A     #2,ZLCVSADR         POINT TO THE OBJECT AGAIN
         TM    ##TYPE(#2),##ATOM   IF OBJECT HAS ALREADY BEEN RELOCATED
         BO    RNOTREL             THEN...
*                                   STORE FORWARDED PTR INTO PLACE
         LA    #0,3                 UPDATE POINTER WITH FORWARDED ONE:
         N     #0,0(,#15)            GET POSSIBLE GC MARKS INTO REG
         O     #0,##VECDAT(,#2)      COMBINE WITH POINTER VALUE
         ST    #0,0(,#15)           STORE BACK IN WITH GC MARKS INTACT
*
         L     #2,VSSAVE+4          RESTORE THE ONLY CLOBBERED REGISTER
         BR    #14                  RETURN
RNOTREL  DS    0H                  ELSE OBJECT NOT REFERENCED YET...
         LA    #1,##SYMLEN         Get length of a symbol
*                                  (in case it is a symbol.  If it
*                                  isn't a symbol, then at least we've
*                                  cleared the high-order byte, which
*                                  is good for loading the length)
         CLI   ##TYPE(#2),##SYMBOL If this is a symbol,
         BE    RGOTLEN             then we have the length.  Else...
         LA    #1,16               length would be 16 if double float
         CLI   ##TYPE(#2),##DFLOAT If this is a double float,
         BE    RGOTLEN             then we have the length.  Else...
*                                  Not a symbol - a VEC-type obj
         ICM   #1,7,1(#2)          GET LENGTH OF DATA OF THIS OBJECT
         BNZ   RADDIT              IF POSITIVE, NO PROBLEM
         LA    #1,1                IF ZERO, ASSUME SOME LENGTH
RADDIT   LA    #1,4+3(,#1)         ADD 4 FOR PREFIX AND...
         N     #1,=X'FFFFFFFC'     ROUND UP TO FULLWORD
RGOTLEN  DS    0H
         LR    #3,#1               THIS GIVES LENGTH TO MOVE
*                                  STORE RELOCATED PTR INTO PLACE
         LA    #0,3                UPDATE POINTER WITH RELOCATED ONE:
         N     #0,0(,#15)           GET POSSIBLE GC MARKS INTO REG
         O     #0,VSPTR             COMBINE WITH POINTER VALUE
         ST    #0,0(,#15)           STORE BACK IN WITH GC MARKS INTACT
*
         L     #0,VSPTR            PLACE TO MOVE IT TO IN NEW SPACE
         LR    #15,#2              SAVE ADDRESS OF OLD OBJECT
         LR    #4,#0               SAVE ADDRESS OF NEW OBJECT
         MVCL  #0,#2               MOVE FROM OLD SPACE TO NEW SPACE
*
* CODE ADDED TO CHECK IF VSPTR SHOULD GO PAST END OF VSSPACE AREA
*
         L     #1,ZLCVSOTH
         A     #1,ZLCVSLEN         GET ADDRESS OF END OF NEW SPACE
         CR    #0,#1               IF WE PASSED IT
         BH    ABEND0C3            THEN SOMETHING'S WRONG.
*
* END CODE ADDED TO CHECK IF VSPTR SHOULD GO PAST END OF VSSPACE AREA
*
         ST    #0,VSPTR            UPDATE NEW VSSPACE SLOT
         NI    ##TYPE(#15),255-##ATOM INDICATE OBJECT FORWARDED
         ST    #4,##VECDAT(,#15)   SET OBJECT'S FORWARDING POINTER
         LM    #1,#4,VSSAVE        RESTORE REGISTERS
         BR    #14                 RETURN
         SPACE 1
ABEND0C3 EX    0,*                 FORCE 0C3 ABEND IF WE REALLY BLEW IT
         EJECT
*
* DATA AREAS USED BY THE GC
*
VSPTR    DS    A                   @ AVAILABLE SLOT IN NEW V/S SPACE
VSSAVE   DS    4A                  REGISTER SAVE AREA
MARKSAVE DS    A                   REGISTER SAVE AREA
ENDVEC   DS    A                   @ END OF VECTOR BEING PROCESSED
         SPACE 1
ZSAVREGS DS    15A
*
* THE FOLLOWING EQUATES ARE USED TO RELOAD PASSED REGISTER VALUES.
*
ZSAVED0  EQU   ZSAVREGS+0
ZSAVED1  EQU   ZSAVREGS+4
ZSAVED2  EQU   ZSAVREGS+8
ZSAVED3  EQU   ZSAVREGS+12
ZSAVED4  EQU   ZSAVREGS+16
ZSAVED5  EQU   ZSAVREGS+20
ZSAVED6  EQU   ZSAVREGS+24
ZSAVED7  EQU   ZSAVREGS+28
ZSAVED8  EQU   ZSAVREGS+32
ZSAVED9  EQU   ZSAVREGS+36
ZSAVED10 EQU   ZSAVREGS+40
ZSAVED11 EQU   ZSAVREGS+44
ZSAVED12 EQU   ZSAVREGS+48
ZSAVED13 EQU   ZSAVREGS+52
ZSAVED14 EQU   ZSAVREGS+56
         EJECT
LCODE1   DS    0A
         SPACE 1
***********************************************************************
*                                                                     *
*  THE CODE THAT FOLLOWS IS USED TO COMPARE WITH LEXPR HEADER CODE.   *
*  SEE ZCGBEGIN.  IF THIS CODE IS CHANGED IN ZCGBEGIN IT MUST ALSO    *
*  BE CHANGED HERE.                                                   *
*                                                                     *
***********************************************************************
         SPACE 1
         L     #2,0(,#1)           GET POINTER TO LEXPR ARG ON STACK
         L     #2,##CDR(,#2)       GET FIXNUM VALUE THEREOF
         SLA   #2,2                MULTIPLY IT BY 4 TO GET STACK LENGTH
         LA    #0,*-*(#2,#1)       HALF OF THE EXPECTED LA INSTRUCTION
         ORG   *-2                 THROW AWAY THE OTHER HALF
LCODE    EQU   LCODE1,*-LCODE1     LENGTH OF THIS CODE
         SPACE 1
GCTIME1  DS    D                   CPU TIME AT START OF GC
GCTIME2  DS    D                   CPU TIME AT END OF GC
DUMS     DC    D'0'                TIME INTERVAL FOR DUMMY STIMER
VMASK    DS    8D
VSAVE    DS    8D                  SAVE AREA FOR REG 14 THROUGH 8
TESTTEMP DS    1D
LASTFREE DS    1F
FREE1ST  DS    1F
         AIF   (NOT &ZILVF).NOVDS
VTEMPSZ  DS    1F                  Size of vector of free pointers + 8
VGCVP    DS    1F                  Vector section size & partial sum #
VTEMP4   DS    1F
VTEMPTOP DS    1F
.NOVDS   ANOP
         AIF   (NOT &ZILXA).NOPDS
PGSERECB DS    F                   ECB for PGSER requests
PGSERVSA DS    F                   Address of VS pages to be released
PGSERVSE DS    F                   Address of end of above
.NOPDS   ANOP
         EJECT
         LTORG
         EJECT
         AIF   (&ZILVF).VEC1100
ZIL1100A DC    C'ZIL1100 SCALAR GARBAGE COLLECTION INVOKED FROM '
         AGO   .AFT1100
.VEC1100 ANOP  ,
ZIL1100A DC    C'ZIL1100 GARBAGE COLLECTION (VECTOR-C) INVOKED FROM '
.AFT1100 ANOP  ,
ZIL1100B DC    CL64' '
         DS    C                   FILLER
ZIL1101  DC    C'ZIL1101 GARBAGE COLLECTION FAILED. NO MORE CONS CELLS X
               AVAILABLE.'
ZIL1102A DC    C'ZIL1102 GARBAGE COLLECTED, '
ZIL1102B DC    C' CONS CELLS AND '
ZIL1102C DC    C' VSS BYTES FREE.'
ZIL1102  DS    CL(L'ZIL1102A+11+L'ZIL1102B+11+L'ZIL1102C)
ZIL1104  DC    C'ZIL1104 SEVERE ERROR, GARBAGE COLLECTION CANNOT CONTINX
               UE.'
ZIL1107  DC    C'ZIL1107 INVALID OBJECT IN VECTOR/STRING SPACE, GARBAGEX
                COLLECTION TERMINATED.'
         AIF   (NOT &ZILVF).NO1109
ZIL1109  DC    C'ZIL1109 NOT ENOUGH MEMORY FOR VECTOR SWEEP WORK AREA, X
               GARBAGE COLLECTION TERMINATED.'
.NO1109  ANOP
ZIL1110  DC    C'ZIL1110 NON-FORWARDED SYMBOL IN OBLIST HASH ARRAY, GARX
               BAGE COLLECTION TERMINATED.'
         SPACE 1
***********************************************************************
*                                                                     *
* Obsolete (at least no longer used) messages                         *
*                                                                     *
***********************************************************************
         SPACE 1
*ZIL1103 DC    C'ZIL1103 REGISTER 0 NOT SET ON ENTRY TO CONS FOR GARBAGX
               E COLLECTION.'
*ZIL1105 DC    C'ZIL1105 OBJECT ON OBLIST NOT A SYMBOL, GARBAGE COLLECTX
               ION TERMINATED.'
*ZIL1108 DC    C'ZIL1108 SYMBOL PRINT NAME IS NOT A STRING, GARBAGE COLX
               LECTION TERMINATED.'
         END
