***********************************************************************
*                                                                     *
* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *
*                     All rights reserved.                            *
*                                                                     *
***********************************************************************
         MACRO
&NAME    INSYS
&NAME    OI    ZLCIFLGS,ZLCISYS    Indicate non-ZIL code running
         MEND
         MACRO
&NAME    OUTSYS
&NAME    NI    ZLCIFLGS,255-ZLCISYS Indicate non-ZIL code running
         TM    ZLCIFLGS,ZLCIATTN    If attention interrupt occurred
         BOR   #13                  then go to handle it
         MEND
         TITLE 'TSO - BUILT-IN ZIL 1.3 SUBROUTINE'
***********************************************************************
* TSO TAKES AN &REST ARG - LIST OF ATOMS TO BE CONCATENATED INTO A    *
* SINGLE CHARACTER STRING, WHICH IS THEN EXECUTED AS A TSO COMMAND.   *
*  SPECIFICATION OF AN ATOM OR OF A LIST CONTAINING NESTED LISTS IS   *
*  ERRONEOUS AND WILL BE FLAGGED AS AN ERROR.                         *
*                                                                     *
* TSO RETURNS A FIXNUM CONTAINING THE RETURN CODE AS RETURNED BY      *
* THE TSO COMMAND INVOKED.                                            *
*                                                                     *
* THIS ROUTINE IS NOT RECURSIVE AND USES NO EXTRA STACK SPACE.        *
***********************************************************************
*                                                                     *
* ZILADMP IS CALLED TO DUMP EACH ATOM IN THE LIST INTO OUR WORK AREA. *
*                                                                     *
***********************************************************************
*                                                                     *
* 01/27/88 - CHANGED TO INVOKE TSO COMMAND ITSELF RATHER THAN USING   *
*            THE DRAPER "XCLIST" UTILITY.                             *
*                                                                     *
* 05/02/89 - TSO/E Version 2 support.                                 *
*                                                                     *
***********************************************************************
         GBLB  &ZILXA,&ZILTSO
         #ZSYS ,
         SPACE
TSO      #ZBEG MINARGS=0,MAXARGS=0,RESTARG=T,NAME='TSO'
         #ZPDS 16                  DEFINE STACK SIZE
         #ZSAV ,                   SAVE REGISTERS
         SPACE
         L     #6,0(,#11)          GET &REST ARGUMENT
         LA    #5,4                INIT LENGTH REQUIRED SO FAR TO 4
*                                  (for command buffer prefix)
LOOP     DS    0H
         CR    #6,#10              IF END OF LIST OR NULL LIST
         BE    NOMORE              THEN END LOOP
         L     #2,##CAR(,#6)       GET ATOM (ARG 1 TO TSO)
         TM    ##TYPE(#2),##ATOM   IF IT'S NOT AN ATOM
         BZ    BADLIST             THEN ERROR
         TM    ##TYPE(#2),##VEC    IF IT'S SOME KIND OF VECTOR
         BO    BADLIST             THEN ERROR
         L     #15,ZLCADMP         GET ADDRESS OF ZILADMP
         LR    #1,#10              SET #1 FOR ZILADMP
         #BASR #14,#15             CALL ZILADMP TO DUMP ATOM
         LR    #7,#1               SAVE ADDRESS OF DUMPED ATOM
         LTR   #4,#0               GET LENGTH OF DUMPED ATOM
         BNP   AFTMOVE             IF ZERO LENGTH, SKIP THIS ONE
         AR    #0,#5               GET DUMPED-ATOM LENGTH PLUS TOTAL
         C     #0,ZLCWALEN         IF EXCEEDS CURRENT WORKAREA LENGTH
         BNH   LENOK               THEN...
*
* (1) GETMAIN A NEW WORKAREA WHOSE SIZE IS >= #0.
* (2) COPY CONTENTS OF OLD WORKAREA TO THE NEW WORKAREA, LENGTH = #5.
* (3) FREEMAIN THE OLD WORKAREA.
*
* #0 = TOTAL LENGTH NEEDED SO FAR, INCLUDING DUMPED-BUT-NOT-ADDED-YET
* #1 = NOT IN USE
* #2 = NOT IN USE, WILL CONTAIN NEW WORK AREA LENGTH
* #3 = NOT IN USE, WILL CONTAIN NEW WORK AREA ADDRESS
* #4 = LENGTH OF DUMPED ATOM TEXT THAT WE WANT TO ADD ON
* #5 = TOTAL LENGTH DUMPED SO FAR, NOT INCLUDING THIS STUFF
* #6 = ADDRESS OF THE SUBLIST CURRENTLY BEING PROCESSED
* #7 = ADDRESS OF DUMPED ATOM TEXT THAT WE WANT TO ADD ON
*
         LR    #2,#0                SAVE LENGTH TO BE NEEDED
         LA    #2,7(,#2)            GET A LARGER WORK AREA
         N     #2,=X'FFFFFFF8'      ROUNDED UP TO MULTIPLE OF 8
         LR    #0,#2                SAVE THE NEW WORK AREA LENGTH
         #GETMAIN RC,LV=(0),LOC=BELOW GET A NEW WORK AREA
         LTR   #15,#15              IF GETMAIN FAILED
         BNZ   ERROR3               THEN ERROR - NOT ENOUGH STORAGE
         LR    #3,#1                SAVE NEW WORKAREA ADDRESS
         ICM   #14,15,ZLCWA         #14 = ADDRESS OF OLD AREA
         BZ    NOFREE               IF NONE, THEN SKIP MOVE & FREE
         LR    #0,#3                #0 = ADDRESS OF NEW AREA
         LR    #1,#5                #1 = LENGTH OF DUMPED TEXT
         LR    #15,#5               #15 = LENGTH OF DUMPED TEXT
         MVCL  #0,#14               COPY DATA FROM OLD AREA TO NEW AREA
         L     #1,ZLCWA             GET CURRENT WORK AREA ADDRESS
         L     #0,ZLCWALEN          GET CURRENT WORK AREA LENGTH
         FREEMAIN R,LV=(0),A=(1)    FREE THE OLD WORK AREA
NOFREE   DS    0H
         ST    #3,ZLCWA             SET NEW ZIL WORKAREA ADDRESS
         ST    #2,ZLCWALEN          SET NEW ZIL WORKAREA LENGTH
         SPACE 1
LENOK    DS    0H                  OTHERWISE - STILL ROOM
         L     #0,ZLCWA            WORKAREA ADDRESS + WORK AREA LENGTH
         AR    #0,#5               POINTS TO WHERE TO MOVE DUMPED ATOM
         LR    #1,#4               SOURCE LENGTH = DUMPED ATOM LENGTH
         LR    #15,#4              TARGET LENGTH = DUMPED ATOM LENGTH
         LR    #14,#7              SOURCE ADDRESS = WHERE DUMPED ATOM
         MVCL  #0,#14              MOVE DUMPED ATOM TO WORK AREA
         AR    #5,#4               INCREMENT TOTAL LENGTH SO FAR
AFTMOVE  DS    0H
         L     #6,##CDR(,#6)       GET REST OF LIST
         B     LOOP                CONTINUE.
NOMORE   DS    0H                  LIST HAS BEEN PROCESSED
*
* CHECK THAT THE ARGUMENT IS NOT LONGER THAN 32K.
*
         L     #1,ZLCWA            GET ADDRESS OF COMMAND WORK AREA
         CH    #5,=H'32767'        IF BUFFER LENGTH TOO LONG FOR TSO
         BH    TOOLONG             THEN ERROR
         SPACE
* To solve problem of single % picking up residual byte afterwards,
* we blank the byte following the end of the active buffer.
         SPACE
         C     #5,ZLCWALEN         Do only if active length is less
         BNL   NONONONO             than length of buffer.
         LA    #15,0(#5,#1)        Point to end of buffer
         MVI   0(#15),C' '         Blank it out to fix "%" problem
NONONONO DS    0H
         SPACE
         SLL   #5,16               ELSE SHIFT INTO LEFT HALF OF WORD
         ST    #5,0(,#1)           STORE COMMAND BUFFER PREFIX
         LR    #5,#1               Load command buffer pointer
         SPACE
         LA    #3,4095(,#12)       Set up second base register
         USING TSO+4095,#3
         SPACE
***********************************************************************
*                                                                     *
* REGISTER USAGE:                                                     *
*                                                                     *
*   #3  -->  SECOND BASE REGISTER                                     *
*   #4  -->  ECT (ENVIRONMENT CONTROL TABLE)                          *
*   #5  -->  CBUF (COMMAND BUFFER)                                    *
*   #6  -->  (AVAILABLE)                                              *
*   #7  -->  ADDRESS OF OUR INPUT STACK                               *
*                                                                     *
* NOTE: REGISTER USAGE IN EXIT ROUTINES MAY DEVIATE FROM THE ABOVE.   *
*                                                                     *
***********************************************************************
*
* BUILD CPPL FROM SYSTEM CONTROL BLOCKS
*
         USING PSA,0
         L     #15,PSATOLD          GET TCB ADDRESS
         USING TCB,#15
         L     #15,TCBJSCB          GET JSCB ADDRESS
         USING IEZJSCB,#15
         L     #15,JSCBACT          GET ADDRESS OF ACTIVE JSCB
         L     #15,JSCBPSCB         GET ADDRESS OF PSCB
         LTR   #15,#15             IF THERE'S NO PSCB
         BZ    NOTSO               THEN TSO NOT ACTIVE
         ST    #15,CPPLPSCB         SAVE PSCB ADDRESS
         USING PSCB,#15
         MVC   CPPLUPT,PSCBUPT      SAVE UPT ADDRESS
         L     #15,PSCBRLGB         GET ADDRESS OF RELOGON BUFFER
         USING RLGB,#15
         L     #4,RLGBECT           GET ADDRESS OF ECT
         ST    #4,CPPLECT          ADDRESS ENVIRONMENT CONTROL TABLE
         USING ECT,#4
         SPACE 2
*
* Locate the LWA (logon work area) to find the addresses of the TSO
* tables that define which TSO commands can be accessed and how.
*
         XR    #0,#0               Clear the list of...
         ST    #0,ZTE2ADDR          TSO commands that run authorized
         L     #15,PSAAOLD         Get ASCB address
         USING ASCB,#15
         L     #15,ASCBASXB        Get ASXB address
         USING ASXB,#15
         ICM   #2,15,ASXBLWA       Get LWA address
         BZ    NOTTSOE             If none, probably not TSO/E
         USING LWA,#2
         ICM   #15,15,LWAPECT      Get LWA's ECT address
         BZ    NOTTSOE             If none, probably not TSO/E
         C     #15,CPPLECT         Check that ECT addresses match
         BE    ECTSOK
         #ERR  2,                                                      X
               'The ECT addresses in the LWA (logon work area) and the X
               RLGB (relogon buffer) do not match.  TSO is using the ECX
               T address from the RLGB.'
ECTSOK   DS    0H
         L     #15,LWATE2          Get address of IKJEFTE2
         ST    #15,ZTE2ADDR        (TSO commands that run authorized)
NOTTSOE  DS    0H
         EJECT
***********************************************************************
* INITIALIZE WORK AREAS                                               *
***********************************************************************
         SPACE
         L     #14,CPPLUPT
         L     #15,CPPLECT
         LA    #0,ZTECB
         STM   #14,#0,IOPLUPT      SET UP IKJPUTL PARAMETER LIST
         LA    #1,ZTCSFLG
         LA    #2,CSOA
         STM   #14,#2,CSPL         SET UP IKJSCAN PARAMETER LIST
         L     #1,CPPLPSCB
         LA    #2,DAPB2C
         STM   #14,#2,DAPLUPT      SET UP IKJDAIR PARAMETER LIST
         LA    #0,X'2C'            DAIR ENTRY CODE TO MARK NOT IN USE
         SLL   #0,16               SHIFT INTO LEFT HALF FOR DAIR CB
         STCM  #0,15,DA2CCD        AND PUT ZEROES INTO FLAG FIELD
         MVI   DA2CDDN,C' '        CLEAR DDNAME TO BLANKS
         MVC   DA2CDDN+1(7),DA2CDDN
         MVC   ZTBLDL(4),=Y(1,12)  INITIALIZE BLDL LIST FOR CMDCHK
         LA    #0,1
         LA    #1,ZTMSGHDR
         XR    #2,#2
         STM   #0,#2,ZTMSGOLD      INITIALIZE PUTLINE WORK AREA
         LA    #1,ZTPGHDR
         STM   #0,#1,ZTPGOLD       INITIALIZE PUTGET MODE MSG AREA
         LA    #1,ZTPGOLD
         ST    #1,PGPB+4           STORE ADDR OF O.L.D. IN PARM BLOCK
         LA    #1,ZTMSGOLD
         ST    #1,PTPBOPUT         STORE ADDR OF O.L.D. IN PARM BLOCK
         LA    #0,ZTCMDECB
         LA    #1,ZTATNECB
         STM   #0,#1,ZTECBLST      INITIALIZE ECB LIST
         OI    ZTECBLST+4,X'80'
*** NOTE: #2 CONTAINS ZEROES FROM ABOVE INSTRUCTIONS.
         ST    #2,DA2CTCB          TCB ADDRESS TO MARK DSE'S NOT IN USE
         ST    #2,ZTRETCD          INITIALIZE RETURN CODE TO ZERO
         MVI   ZTCSFLG,0           PREPARE TO SYNTAX CHECK COMMAND
         MVI   ZTSTATUS,ZTNORMAL   Initialize command status
         L     #2,ECTIOWA          GET ADDRESS OF ORIGINAL INPUT STACK
         ST    #2,ZTSVIOA          SAVE INPUT STACK IN OUR WORK AREA
         MVC   ZTCMDS,ECTPCMD      SAVE ORIGINAL PRIMARY & SUBCOMMAND
*
* Use LINKLIST DCB with BLDL to find system stuff only
* (not stuff in a task library)
*
         L     #15,16              Get CVT address
         L     #0,CVTLINK-CVT(,#15) Get address of LINKLIST DCB
         ST    #0,LINKDCB          Save it
         SPACE 2
***********************************************************************
* SET UP ESTAE (ABEND) AND STAX (ATTENTION) EXIT ROUTINES.            *
***********************************************************************
         SPACE
         LA    #14,STAEEXIT
         ESTAE (#14),PARAM=(#12),MF=(E,ZTESTAE)
         LTR   #15,#15             IF ESTAE FAILED,
         BZ    ESTAEOK             THEN
         LA    #1,=C'ESTAE'         BLOW UP
         LA    #0,5
         B     ERROR
ESTAEOK  OI    ZTFLAGS,ZTESTON     ELSE INDICATE ESTAE IS ACTIVE
         SPACE
         L     #14,=A(STAXEXIT)
         STAX  (#14),USADDR=(#12),REPLACE=NO,MF=(E,ZTSTAX)
         CH    #15,=H'4'           IF STAX FAILED,
         BNH   STAXOK              THEN
         LA    #1,=C'STAX'          BLOW UP
         LA    #0,4
         B     ERROR
STAXOK   OI    ZTFLAGS,ZTSTXON     ELSE INDICATE STAX IS ACTIVE
         EJECT
***********************************************************************
* Determine which version of TSO/Extensions is active.                *
* Reference: TSO/Extensions Version 2 Programming Services (SC28-1875 *
*            Chapter 2. Considerations for Using TSO/E Services       *
*            Determining the Version and Release of TSO/E Installed   *
***********************************************************************
         SPACE 1
         MVI   ZTTSOE,C'0'         Initialize TSO/E version to (none)
         L     #15,X'10'           Get address of CVT
         L     #15,CVTTVT-CVT(,#15) Get address of TSVT
         LTR   #15,#15             If there is none,
         BZ    TSOEV0              then don't change it
         USING TSVT,#15            Else set it...
         MVC   ZTTSOE,TSVTLVER     C'1' = version 1, C'2' = version 2
         SPACE 1
TSOEV0   DS    0H
         SPACE 1
***********************************************************************
* PREPARE TO INVOKE COMMANDS BY SAVING THE CURRENT INPUT STACK AND    *
* INITIALIZING IT TO A TERMINAL ELEMENT (A LA ISPF).                  *
***********************************************************************
         SPACE
         CLI   ZTTSOE,C'2'         If TSO/E Version 2 or later,
         BNL   INITSTK2            then do it the TSO/E Version 2 way
*                                  else do it the TSO/E Version 1 way
         OI    ZTFLAGS,ZTSTKMOD    INDICATE INPUT STACK ADDR ALTERED
         XR    #0,#0               MAKE A ZERO
         ST    #0,ECTIOWA          CLEAR INPUT STACK ADDRESS
         ST    #0,ZTECB            CLEAR ECB FOR STACK
*
* SET UP A TERMINAL ELEMENT AS THE BOTTOM ELEMENT OF NEW INPUT STACK
*
         INSYS
         STACK PARM=STKINIT,MF=(E,IOPL)
         OUTSYS
         LTR   #15,#15             IF STACK FAILED,
         BZ    STACKOK             THEN...
         L     #2,ZTSVIOA           GET SAVED INPUT STACK ADDRESS
         ST    #2,ECTIOWA           RESTORE ORIGINAL INPUT STACK
         NI    ZTFLAGS,255-ZTSTKMOD INDICATE INPUT STACK ADDR RESTORED
         LA    #1,=C'STACK DATASET=*' BLOW UP
         LA    #0,15
         B     ERROR
         SPACE
STACKOK  DS    0H
         SPACE
***********************************************************************
* IN ORDER TO INSURE THAT COMMANDS INVOKED VIA TSO FUNCTION IN THE    *
* BACKGROUND, WE CAUSE OUR STACK TO HAVE THE SAME BOTTOM ELEMENT AS   *
* THE ORIGINAL STACK.  THIS WOULD JUST BE THE TERMINAL IN THE         *
* FOREGROUND, BUT IT WILL BE THE SYSTSPRT DATASET IN THE BACKGROUND.  *
* NOTE THAT WE CAN'T DO THIS "LEGALLY" BY USING THE STACK MACRO TO    *
* SET UP SYSTSPRT AS THE BOTTOM ELEMENT, SINCE THAT WOULD CAUSE IT    *
* TO BE REOPENED FOR OUTPUT AND PREVIOUS TSO OUTPUT WOULD BE LOST.    *
***********************************************************************
         SPACE
         L     #2,ZTSVIOA          Get address of original input stack
         L     #7,ECTIOWA          GET ADDRESS OF OUR NEW INPUT STACK
         L     #14,4(,#7)          GET ADDRESS OF OUR BOTTOM ELEMENT
         L     #15,4(,#2)          GET ADDRESS OF THEIR BOTTOM ELEMENT
         MVC   0(4,#14),0(#15)     MOVE THEIR ELEMENT TO OUR ELEMENT
         B     AINITSTK            Else...
         SPACE 1
INITSTK2 DS    0H                  Set input stack for TSO/E Version 2
*
***********************************************************************
* Make a new input stack by issuing STACK ENVIRON=CREATE, which makes *
* a new ECT and a new IOWA.  We don't use the new ECT, but we do use  *
* the new IOWA, altering the current ECT to point to it.              *
***********************************************************************
*
         XC    ZTECB,ZTECB         Clear ECB
         INSYS
         STACK PARM=STKECREA,MF=(E,IOPL) Stack ENVIRON=CREATE
         OUTSYS
         LTR   #15,#15             If STACK failed,
         BZ    ENVCREOK            then blow up
         LA    #1,=C'STACK ENVIRON=CREATE'
         LA    #0,20
         B     ERROR
ENVCREOK DS    0H                  STACK created new ECT...
*
***********************************************************************
* IN ORDER TO INSURE THAT COMMANDS INVOKED VIA XCLIST FUNCTION IN THE *
* BACKGROUND, WE CAUSE OUR STACK TO HAVE THE SAME BOTTOM ELEMENT AS   *
* THE ORIGINAL STACK.  THIS WOULD JUST BE THE TERMINAL IN THE         *
* FOREGROUND, BUT IT WILL BE THE SYSTSPRT DATASET IN THE BACKGROUND.  *
***********************************************************************
*
         OI    ZTFLAGS,ZTSTKMOD    Indicate input stack addr altered
         L     #15,STKECREA+STPBECTA-STPB Get address of new ECT
         ST    #15,ZTNEWECT               Save it
         MVC   ECTIOWA(4),ECTIOWA-ECT(#15) Copy IOWA pointer to ours
*
* Put a barrier element on the stack.
*
         XC    ZTECB,ZTECB         Clear ECB
         INSYS
         STACK PARM=STKBARR,MF=(E,IOPL) STACK BARRIER=*
         OUTSYS
         LTR   #15,#15             IF STACK UNSUCCESSFUL,
         BZ    BARRIERD            THEN TERMINATE OUR PROCESSING.
         LA    #1,=C'STACK BARRIER=*'
         LA    #0,15
         B     ERROR
BARRIERD DS    0H
*
* Use PUTGET SUBSTACK=YES in conjunction with the barrier.
*
         MVC   PGPB(PGPBSUBL),PGPBSUB Set up PUTGET SUBSTACK=YES form
         LA    #1,ZTPGOLD
         ST    #1,PGPB+4           STORE ADDR OF O.L.D. IN PARM BLOCK
         SPACE 1
AINITSTK DS    0H                  ECT ready with new stack
         SPACE
***********************************************************************
* THE COMMAND BUFFER PASSED TO US IS SCANNED AS A TSO COMMAND, THE    *
* FIRST OPERAND IS CHECKED TO SEE IF IT IS A VALID TSO COMMAND OR     *
* CLIST, AND IF SO, IT IS THEN INVOKED.                               *
***********************************************************************
         SPACE
         ST    #5,CPPLCBUF         SET CPPL COMMAND BUFFER ADDRESS
         MVC   ZTOFFSET,2(#5)      SAVE POSSIBLE CLIST NAME OFFSET
         LR    #1,#5               POINT TO COMMAND BUFFER
         #BAS  #14,SCAN            SCAN NEXT OPERAND IN COMMAND BUFFER
         B     GOSCAN(#15)         BRANCH BASED ON RETURN CODE
GOSCAN   B     SCAN0               RC=0 - VALID COMMAND NAME
         B     RETURN              RC=4 - NO COMMAND NAME, RETURN NIL
         B     SCAN8               RC=8 - INVALID COMMAND NAME
         LH    #15,ZTSCANRC        RC=12 - SCAN ERROR
         LA    #1,=C'SCAN'          IN WHICH CASE, BLOW UP
         LA    #0,4
         B     ERROR
         SPACE
SCAN8    DS    0H                  COMMAND IS SYNTACTICALLY INVALID
         LA    #1,SYNMSG
         LA    #0,L'SYNMSG
         #BAS  #14,PUTLINE         DISPLAY ERROR MESSAGE
         LA    #1,FLUSHALL
         #BAS  #14,FLUSH           AND FLUSH THE INPUT STACK
         B     RETURN
         SPACE
SCAN0    DS    0H                  COMMAND NAME IS SYNTACTICALLY OK
         #BAS  #14,CKCMD           CHECK EXISTENCE OF COMMAND
         TM    ZTFLAGS,ZTSUBER     IF SEVERE ERROR OCCURRED,
         BO    ERROR               THEN GO DISPLAY ERROR MESSAGE
         LTR   #15,#15             IF COMMAND IS NOT SUPPORTED
         BNZ   RETURN              THEN RETURN WITHOUT INVOKING IT
         #BAS  #14,ATTACH          ELSE ATTACH THE COMMAND
         TM    ZTFLAGS,ZTSUBER     IF SEVERE ERROR OCCURRED,
         BO    ERROR               THEN GO DISPLAY ERROR MESSAGE
         B     PROCXC              GO PROCESS ADDITIONAL STACKED CMD'S
         EJECT
RETURN   DS    0H
         SPACE
***********************************************************************
*           *** RETURN TO CALLING PROGRAM ***                         *
*         CLEAR OUR STACK, RESTORE ORIGINAL ONE,                      *
*                 FREE STORAGE AND EXIT                               *
***********************************************************************
         SPACE
         TM    ZTFLAGS,ZTSTKMOD    IF INPUT STACK ADDRESS WAS ALTERED,
         BZ    AFTSTKRS            THEN
         CLI   ZTTSOE,C'2'         If TSO/E Version 2 or later
         BNL   FREESTK2            then unstack the new way
*                                  else unstack the old way
STKCHECK DS    0H                   CHECK CURRENT INPUT STACK
         CLC   0(4,#7),4(#7)        IF TOP ELEMENT NOT = BOTTOM ELEMENT
         BE    STKCLRD              THEN
         LA    #1,FLUSHTOP           CALL STACK TO FLUSH TOP ELEMENT
         #BAS  #14,FLUSH             UNTIL
         B     STKCHECK              ALL STACK ELEMENTS ARE CLEARED.
STKCLRD  DS    0H                  WHEN STACK IS CLEARED...
*
* NOTE THAT WE DON'T PROCESS THE BOTTOM ELEMENT OF OUR STACK VIA STACK!
* IT CANNOT BE DELETED IF IT IS A TERMINAL ELEMENT, AND IF IT IS A
* DATASET ELEMENT WE DEFINITELY DON'T WANT TO CLOSE IT, SO WE JUST
* LET IT DISAPPEAR (UN)NATURALLY.
*
         B     AFTSTKRS
         SPACE 1
FREESTK2 DS    0H                  Unstack the TSO/E Version 2 way...
         XC    ZTECB,ZTECB
         INSYS
         STACK PARM=STKDELB,MF=(E,IOPL) STACK DELETE=BARRIER
         OUTSYS
         LTR   #15,#15
         BZ    AFTSTKDB
         LA    #1,=C'STACK DELETE=BARRIER'
         LA    #0,20
         B     ERROR
         SPACE 1
AFTSTKDB DS    0H
*
***********************************************************************
* Clear things out by issuing STACK ENVIRON=DESTROY.  This SHOULD     *
* have the effect of deleting all the elements from the IOWA that     *
* we have been using.  Then restore the old IOWA pointer to the ECT.  *
***********************************************************************
*
         L     #15,ZTNEWECT               Get address of new ECT
         ST    #15,STKEDEST+STPBECTA-STPB Store into stack parm list
         ST    #15,IOPLECT         Store into IOPL for STACK to see
         XC    ZTECB,ZTECB         Clear ECB
         INSYS
         STACK PARM=STKEDEST,MF=(E,IOPL) Stack ENVIRON=DESTROY
         OUTSYS
         LTR   #15,#15             If STACK failed,
         BZ    ENVDESOK            then blow up
         LA    #1,=C'STACK ENVIRON=DESTROY'
         LA    #0,20
         B     ERROR
ENVDESOK DS    0H                  STACK back to normal, almost...
         MVC   IOPLECT,CPPLECT     Restore our ECT pointer
         SPACE 1
AFTSTKRS DS    0H
         MVC   ECTIOWA(4),ZTSVIOA   RESTORE ORIGINAL INPUT STACK ADDR
         NI    ZTFLAGS,255-ZTSTKMOD INDICATE INPUT STACK RESTORED
         TM    ZTFLAGS,ZTECTMOD    IF ECTPCMD OR ECTSCMD WAS ALTERED,
         BZ    AFTCMDRS            THEN
         MVC   ECTPCMD(16),ZTCMDS   RESTORE ECTPCMD AND ECTSCMD.
AFTCMDRS DS    0H
         TM    ZTFLAGS,ZTSTXON     IF STAX IS ACTIVE
         BNO   OFFSTAX             THEN
         STAX  ,                    CANCEL STAX
OFFSTAX  DS    0H
         TM    ZTFLAGS,ZTESTON     IF ESTAE IS ACTIVE
         BNO   OFFESTAE            THEN
         ESTAE 0                    CANCEL ESTAE
OFFESTAE DS    0H
         SPACE
FINALRET DS    0H
         CLI   ZTSTATUS,ZTABEND    If command terminated abnormally,
         BE    RABEND              then handle abending command
         CLI   ZTSTATUS,ZTATTN     If command interrupted,
         BE    RATTN               then handle attentioned command
RNORMAL  DS    0H                  Else return with last return code
*
* CONVERT THE RETURN CODE FROM THE COMMAND INTO A FIXNUM
*
         L     #2,ZTRETCD          Get return code into reg for fixnum
         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS
         #MKAT FIXED               USING CONTENTS OF #15, MAKE FIXNUM
         SPACE 1
         #ZRET ,                   RESTORE REGISTERS AND RETURN
         EJECT
NOTSO    DS    0H                  HERE IF LINK FAILS
         #ERR  PREFIX=NO,                                              X
               'ZIL2121 TSO: Command feature not available, TSO is not X
               active - ',                                             X
               0(#11)              (try to print out list of strings)
         SPACE 1
BADLIST  DS    0H
         #ERR  PREFIX=NO,                                              X
               'ZIL2122 TSO: Cannot convert argument to string - ',    X
               (#2),                                                   X
               X'0D',              carriage return                     X
               '(it''s a list, vector, funarg, or structure).'
         SPACE 1
TOOLONG  DS    0H                  Error - command string too long
         #ERR  PREFIX=NO,                                              X
               'ZIL2120 TSO: Command exceeds maximum length of 32763 - X
               ',                                                      X
               0(#11)              (try to print out list of strings)
         SPACE
RABEND   DS    0H                  Error - command string too long
         #BAS  #14,FAKESTR         Generate string for error message
         #ERR  PREFIX=NO,                                              X
               'ZIL2124 TSO: Requested command was abnormally terminateX
               d - ',(#2)
         SPACE
RATTN    DS    0H                  Error - command string too long
         #BAS  #14,FAKESTR         Generate string for error message
         #ERR  PREFIX=NO,                                              X
               'ZIL2125 TSO: Requested command terminated due to attentX
               ion - ',(#2)
         SPACE
ERROR3   DS    0H                  ERROR - NOT ENOUGH STORAGE
         XR    #0,#0               CLEAR WORK AREA ADDRESS AND LENGTH
         ST    #0,ZLCWA
         ST    #0,ZLCWALEN
         #ERR  PREFIX=NO,                                              X
               'ZIL2123 TSO: Not enough memory to build TSO command - 'X
               ,0(#11)             (try to print out list of strings)
         EJECT
FAKESTR  DS    0H                  Subroutine to fake out a string
*                                  for ZIL error messages
         L     #2,ZLCWA            Get address of original command
         LH    #0,0(,#2)           Get length of command buffer
         SH    #0,=H'4'            Convert to length of command string
         ST    #0,0(,#2)           Turn into ZIL string length
         MVI   0(#2),##STRING      Set string type
         BR    #14
         EJECT
PROCXC   DS    0H
         SPACE
***********************************************************************
*               STACKED COMMAND PROCESSING                            *
*                                                                     *
* FOR THIS ROUTINE, ALL COMMANDS PLACED ON THE INPUT STACK BY THE     *
* CURRENT COMMAND (E.G. A CLIST) ARE EXECUTED FROM THIS INTERFACE.    *
* THE END OF THE CLIST OR STACK ELEMENT IS DETERMINED BY REACHING     *
* THE BOTTOM LEVEL OF THE INPUT STACK.                                *
*                                                                     *
* NOTE: WHEN THE END OF A CLIST IS REACHED, THE PUTGET SERVICE        *
* ROUTINE AUTOMATICALLY GOES TO THE NEXT LOWER ELEMENT ON THE STACK   *
* TO RETRIEVE THE NEXT COMMAND.  NO NOTIFICATION IS RECEIVED BY THE   *
* CALLER OF PUTGET THAT THIS HAS HAPPENED.  TO GET AROUND THIS        *
* PROBLEM, WE ISSUE A PUTGET WITH A BAD MODE MESSAGE SO THAT THE      *
* PUTGET WILL COMPLETE SUCCESSFULLY AS LONG AS IT GETS A COMMAND FROM *
* A CLIST, BUT NOT WHEN IT TRIES TO GET A COMMAND FROM THE TERMINAL   *
* (IT WILL RETURN A CODE OF 24 IN THIS CASE).  (THIS IDEA CAME        *
* ORIGINALLY FROM ISPF MODULE ISPCAT (OR CAT).) WHEN THIS SITUATION   *
* IS DETECTED, THE RETURN CODE FROM PUTGET IS CHECKED; IF THE INPUT   *
* WAS OBTAINED FROM THE TERMINAL BUT NOT FROM THE BOTTOM LEVEL OF     *
* THE INPUT STACK, THE PROBABLE EXPLANATION IS THAT A "TERMIN"        *
* COMMAND PROCEDURE STATEMENT HAS BEEN EXECUTED, SO THE PUTGET IS     *
* REISSUED WITH A GOOD MODE MESSAGE TO PERMIT TERMIN FUNCTIONING.     *
* OTHERWISE WE KNOW THAT THE CLIST HAS COME TO AN END AND WE EXIT.    *
*                                                                     *
* THIS GIVES RISE TO A PROBLEM IN CLISTS THAT CONTAIN TERMIN          *
* STATEMENTS:  IF CONTROL IS RETURNED TO THE CLIST BY THE USER'S      *
* ENTRY OF A TERMIN STRING, AND THE CLIST ISSUES NO MORE TSO COMMANDS *
* BUT DOES SOME CLIST PROCESSING AND TERMINATES, THIS SUBROUTINE HAS  *
* NO WAY OF KNOWING THAT THE COMMAND RETRIEVED FOLLOWING THE TERMIN   *
* STATEMENT CAME FROM OUTSIDE THE CLIST UNTIL IT HAS ALREADY BEEN     *
* RETRIEVED, BY WHICH TIME IT IS TOO LATE TO DO ANYTHING ABOUT IT.    *
* THEREFORE, CLISTS SHOULD CONTAIN AT LEAST ONE COMMAND (A NULL       *
* COMMAND IS SUFFICIENT) FOLLOWING RETURN FROM A TERMIN STATEMENT.    *
* (ISPF AVOIDS THIS PROBLEM BY REFUSING TO SUPPORT TERMIN ENTIRELY.)  *
*                                                                     *
***********************************************************************
         SPACE
***********************************************************************
* RETRIEVE COMMANDS USING PUTGET, SCAN THEM AND ATTACH THE COMMANDS   *
* WHEN VALID.  NOTE THAT STACK FLUSHING MAY CAUSE THE CURRENT STACK   *
* LEVEL TO REVERT TO THE ORIGINAL LEVEL, TERMINATING OUR PROCESSING   *
* OF COMMANDS; THIS IS A NORMAL WAY OF CLIST TERMINATION UNDER TSO.   *
***********************************************************************
         SPACE
         LTR   #1,#5               GET ADDRESS OF PUTGET BUFFER
         BZ    XCGET               IF A PUTGET BUFFER EXISTS,
         C     #1,ZLCWA            AND IT'S NOT OUR OWN WORKAREA,
         BE    XCGET                THEN...
         LA    #0,1                 GET SUBPOOL NUMBER
         SLL   #0,24                SHIFT INTO HIGH-ORDER BYTE
         AH    #0,0(,#5)            ADD IN LENGTH OF PUTGET BUFFER
         FREEMAIN R,LV=(0),A=(1)    FREE THE PUTGET INPUT BUFFER
         XR    #5,#5                CLEAR PUTGET BUFFER POINTER
         SPACE
XCGET    DS    0H
         SPACE
         CLI   ZTTSOE,C'2'         If TSO/E Version 2 or later
         BNL   PROC2               then process commands the new way
*                                  else process commands the old way
         SPACE
***********************************************************************
* AT THIS POINT WE ARE READY TO GET THE NEXT COMMAND, BUT ONLY IF A   *
* NEW ELEMENT HAS BEEN PLACED ON THE INPUT STACK, I.E. THE STACK      *
* LEVEL AT THIS POINT IS NOT THE SAME AS THE BOTTOM ELEMENT.  SUCH    *
* CAN OCCUR IF WE HAVE EXECUTED A CLIST OR IF WE HAVE INVOKED A       *
* COMMAND THAT STACKS OTHER COMMANDS.  WE KEEP PROCESSING COMMANDS    *
* UNTIL THE STACK LEVEL REACHES THE BOTTOM AGAIN.  NOTE THAT ANY      *
* ERROR ENCOUNTERED DURING A PREVIOUS PASS THROUGH THIS LOOP WILL     *
* HAVE CAUSED US TO ISSUE A STACK FLUSH, WHICH WILL RESULT IN         *
* TERMINATION OF NEW STACK ELEMENTS (AND EXIT FROM LOOP) UNLESS THE   *
* ELEMENT IS A CLIST WITH CONTROL MAIN OR CONTROL NOFLUSH ACTIVE.     *
***********************************************************************
         SPACE
         CLC   0(4,#7),4(#7)       IF TOP STK ELEMENT = BOTTOM ELEMENT
         BE    ENDCMDS             THEN END OUR PROCESSING.
         SPACE
***********************************************************************
* RETRIEVE ADDITIONAL COMMANDS FROM INPUT STACK ELEMENT.              *
***********************************************************************
         SPACE
         XC    ZTPGHDR(4),ZTPGHDR  SET UP BAD (NULL) MODE MESSAGE
         #BAS  #14,PUTGET          GET A LINE OF COMMAND INPUT
         TM    ZTFLAGS,ZTSUBER     IF A PUTGET ERROR OCCURRED,
         BO    BADPG               THEN GO TO DISPLAY ERROR MESSAGE
         CH    #15,=H'24'          IF INVALID PARAMETERS ON PUTGET,
         BNE   PUTGETOK            THEN (TERMINAL IS CURRENT ELEMENT)..
         CLC   0(4,#7),4(#7)        IF TOP STK ELEMENT = BOTTOM ELEMENT
         BE    ENDCMDS              THEN END OUR PROCESSING.
         SPACE
***********************************************************************
* ELSE WE ASSUME A TERMIN STATEMENT WAS EXECUTED AND WE ACCEPT INPUT. *
***********************************************************************
         SPACE
         MVC   ZTPGHDR(MODELEN),MODEDATA  SET UP GOOD MODE MESSAGE
         #BAS  #14,PUTGET          GET A LINE OF COMMAND INPUT
         TM    ZTFLAGS,ZTSUBER     IF A PUTGET ERROR OCCURRED,
         BO    BADPG                OR
         CH    #15,=H'24'            INVALID PARAMETERS ON PUTGET,
         BE    BADPG                  THEN REALLY BAD PUTGET, BLOW UP.
         CLC   0(4,#7),4(#7)       ELSE IF TOP ELEMENT = BOTTOM ELEMENT
         BNE   PUTGETOK            THEN (TERMIN ENVIRONMENT NOT VALID)
         LA    #1,TERMMSG           DISPLAY MESSAGE TELLING USER THAT
         LA    #0,L'TERMMSG         THE COMMAND WAS NOT EXECUTED SINCE
         #BAS  #14,PUTLINE          IT WASN'T SUPPOSED TO BE RETRIEVED
         B     ENDCMDS              AND THEN RETURN TO CALLING PGM.
         SPACE 1
PROC2    DS    0H                  Process commands the TSO/E V.2 way
         SPACE 1
***********************************************************************
* At this point we are ready to get the next command, but only if a   *
* new element has been placed on the input stack, I.E. the stack      *
* level at this point is not the barrier element.  Such can occur if  *
* we have executed a CLIST or if we have invoked a command that       *
* stacks other commands.  We keep processing commands until the stack *
* barrier element is reached.  Note that any error encountered during *
* a previous pass through this loop will have caused us to issue a    *
* stack flush, which will result in termination of new stack elements *
* (and exit from loop) unless the element is a CLIST with             *
* CONTROL MAIN or CONTROL NOFLUSH active.                             *
***********************************************************************
* RETRIEVE ADDITIONAL COMMANDS FROM INPUT STACK ELEMENT.              *
***********************************************************************
         SPACE
         MVC   ZTPGHDR(MODELEN),MODEDATA  SET UP GOOD MODE MESSAGE
         #BAS  #14,PUTGET          GET A LINE OF COMMAND INPUT
         TM    ZTFLAGS,ZTSUBER     IF A PUTGET ERROR OCCURRED,
         BO    BADPG               THEN GO TO DISPLAY ERROR MESSAGE
         CH    #15,=H'40'          IF BARRIER HIT,
         BE    ENDCMDS             then no more command
******** B     PUTGETOK            else process command
         SPACE 1
PUTGETOK DS    0H
         CLI   ZTSTATUS,ZTATTN     IF ATTENTION INTERRUPT OCCURRED,
         BNE   PGNOATTN            THEN
         LA    #1,FLUSHTOP          FLUSH THE STACK (EVEN IF
         #BAS  #14,FLUSH             CONTROL NOFLUSH IS ACTIVE)
         B     PROCXC               AND CONTINUE
         SPACE
PGNOATTN DS    0H                  ELSE GO AHEAD AND PROCESS THIS LINE
         ST    #5,CPPLCBUF         SET CPPL COMMAND BUFFER ADDRESS
         XC    ZTOFFSET,ZTOFFSET   SET COMMAND BUFFER OFFSET TO ZERO
         LR    #1,#5               POINT TO THE COMMAND BUFFER
         #BAS  #14,SCAN            SCAN NEXT OPERAND OF THE COMMAND
         B     GOSCANX(#15)        BRANCH BASED ON RETURN CODE
GOSCANX  B     SCANX0              RC=0 - VALID COMMAND NAME
         B     PROCXC              RC=4 - NO COMMAND NAME
         B     SCANX8              RC=8 - INVALID COMMAND NAME
         LH    #15,ZTSCANRC        RC=12 - SCAN ERROR
         LA    #1,=C'SCAN'          IN WHICH CASE, BLOW UP
         LA    #0,4
         B     ERROR
         SPACE
SCANX8   DS    0H                  COMMAND IS SYNTACTICALLY INVALID
         LA    #1,SYNMSG
         LA    #0,L'SYNMSG
         #BAS  #14,PUTLINE         DISPLAY ERROR MESSAGE
         LA    #1,FLUSHALL
         #BAS  #14,FLUSH           AND FLUSH THE INPUT STACK
         B     PROCXC
         SPACE
SCANX0   DS    0H                  COMMAND IS SYNTACTICALLY OK
         #BAS  #14,CKCMD           CHECK VALIDITY OF COMMAND
         LTR   #15,#15             IF COMMAND IS NOT VALID,
         BNZ   PROCXC              THEN CONTINUE WITH THE NEXT ONE
         #BAS  #14,ATTACH          ELSE INVOKE THE COMMAND
         TM    ZTFLAGS,ZTSUBER     IF SUBROUTINE ERROR,
         BO    ERROR               THEN GO TO DISPLAY MESSAGE
         B     PROCXC              ELSE GO TO GET THE NEXT COMMAND
         SPACE 2
BADPG    LA    #1,=C'PUTGET'       FATAL PUTGET ERROR
         LA    #0,6
         B     ERROR
         EJECT
ENDCMDS  DS    0H                  NO MORE COMMANDS TO PROCESS
         XR    #15,#15
         ICM   #15,7,ECTRTCD       PICK UP RETURN CODE FROM ECT
         ST    #15,ZTRETCD         SAVE THE RETURN CODE
         SPACE
***********************************************************************
* AT THIS POINT, TO INSURE CORRECT COMMAND STATISTICAL RECORDING, WE  *
* DO VARIOUS STUFF FOR TSO/MON.  SINCE TSO/MON IS NOT INSTALLED AT    *
* DRAPER, I HAVE OMITTED THIS CODE, BUT MAY ADD SVC109 INTERFACE SOON.*
***********************************************************************
         SPACE
         B     RETURN              RETURN TO CALLING PROGRAM
         EJECT
ERROR    DS    0H                  DISPLAY ERROR MESSAGE AND END
         SPACE
***********************************************************************
* MISCELLANEOUS ERROR DISPLAY.                                        *
* #0 CONTAINS LENGTH OF NAME OF FUNCTION THAT FAILED                  *
* #1 CONTAINS ADDRESS OF NAME OF FUNCTION THAT FAILED                 *
* #15 CONTAINS RETURN CODE FROM FAILED FUNCTION                       *
***********************************************************************
         SPACE
         MVC   ZTMSG(L'ERRMSG1),ERRMSG1  SET UP FIRST PART OF MESSAGE
         LTR   #14,#0              GET LENGTH OF FUNCTION TYPE
         BNP   AFTFUNC             IF NONE, BYPASS
         BCTR  #14,0               ELSE REDUCE LENGTH FOR EXECUTE
         EX    #14,MOVEFUNC        MOVE FUNCTION NAME TO ERROR MESSAGE
AFTFUNC  LA    #1,ZTMSG+L'ERRMSG1+1(#14)  POINT TO NEXT PART OF MESSAGE
         MVC   0(L'ERRMSG2,#1),ERRMSG2    SET UP SECOND PART OF MESSAGE
         CVD   #15,ZTDOUBLE               CONVERT ERROR CODE TO DISPLAY
         UNPK  L'ERRMSG2(2,#1),ZTDOUBLE
         OI    L'ERRMSG2+1(#1),X'F0'
         LA    #0,L'ERRMSG1+L'ERRMSG2+3(#14)  GET LENGTH OF MSG IN #0
         XR    #1,#1               INDICATE MESSAGE ALREADY IN WORKAREA
         #BAS  #14,PUTLINE         DISPLAY THE MESSAGE
         LA    #1,FLUSHALL
         #BAS  #14,FLUSH           FLUSH THE INPUT STACK
         B     RETURN              RETURN TO CALLING PROGRAM
         SPACE
MOVEFUNC MVC   ZTMSG+L'ERRMSG1(0),0(#1)  MOVE FUNCTION TO ERROR MESSAGE
         EJECT
***********************************************************************
* THE SCAN SUBROUTINE INVOKES THE IKJSCAN TSO SERVICE ROUTINE TO      *
* DETERMINE THE NATURE OF THE NEXT OPERAND IN THE TSO COMMAND         *
* BUFFER.  ON ENTRY #1 CONTAINS THE ADDRESS OF THE COMMAND BUFFER TO  *
* BE SCANNED.  ON RETURN THE FIELD ZTCOMMND CONTAINS THE OPERAND,     *
* BLANK PADDED AND JUSTIFIED LEFT, UNLESS THE OPERAND IS MISSING OR   *
* SYNTACTICALLY INVALID.  #15 IS SET TO ZERO IF THE OPERAND IS A      *
* SYNTACTICALLY VALID COMMAND NAME, 4 IF IT IS MISSING, 8 IF IT IS    *
* SYNTACTICALLY INVALID, 12 IF AN ERROR RETURN CODE IS PASSED BACK    *
* FROM IKJSCAN.  IF THE OPERAND WAS PRECEDED BY A PERCENT SIGN (%),   *
* THE FLAG ZTEXEC IS SET ON; OTHERWISE IT IS SET OFF.  IF THERE ARE   *
* NO FURTHER OPERANDS IN THE TSO COMMAND BUFFER FOLLOWING THE         *
* CURRENT ONE, THE ECTNOPD FLAG IN THE ECT IS SET ON.                 *
***********************************************************************
         SPACE
SCAN     DS    0H
         ST    #14,ZTSCAN14        SAVE RETURN REGISTER
         MVI   ZTCOMMND,C' '       SET COMMAND NAME FIELD TO BLANKS
         MVC   ZTCOMMND+1(7),ZTCOMMND
         NI    ZTFLAGS,255-ZTEXEC  ASSUME NOT AN IMPLICIT EXEC FOR NOW
         NI    ECTSWS,255-ECTNOPD  SET ECT NO-OPERANDS BIT OFF
         ST    #1,CSPLCBUF         SET COMMAND BUFFER ADDRESS FROM PARM
         XC    ZTECB,ZTECB         CLEAR ECB
         INSYS
         CALLTSSR EP=IKJSCAN,MF=(E,CSPL)  CALL IKJSCAN TO SCAN BUFFER
         OUTSYS
         STH   #15,ZTSCANRC        SAVE IKJSCAN RETURN CODE
         LTR   #15,#15             IF SCAN FAILED,
         BZ    SCANOK              THEN...
         LA    #15,12               INDICATE SCAN FAILURE
         B     SCANRET              AND RETURN. ELSE...
SCANOK   DS    0H                  CHECK RESULTS OF SCAN
         TM    CSOAFLG,CSOAQM+CSOABAD IF ANY SYNTAX ERROR
         BNZ   SCANBAD             THEN RETURN INDICATING BAD SYNTAX
         TM    CSOAFLG,CSOANOC     IF NO COMMAND NAME WAS FOUND,
         BNO   NOTNOC              THEN...
         OI    ECTSWS,ECTNOPD       INDICATE ECT NO OPERANDS
         LA    #15,4                RETURN INDICATING NOTHING FOUND
         B     SCANRET             ELSE...
NOTNOC   DS    0H                  (AN OPERAND EXISTS)
         LH    #1,CSOALNM          PICK UP LENGTH OF OPERAND
         LTR   #1,#1               IF LENGTH IS ZERO,
         BNP   SCANBAD             THEN...
         L     #15,CSOACNM         GET ADDRESS OF OPERAND
         BCTR  #1,0                REDUCE OPERAND LENGTH FOR EXECUTE
         EX    #1,MOVECMD          MOVE OPERAND TO COMMAND NAME AREA
         XR    #15,#15             INDICATE VALID COMMAND NAME
         TM    CSOAFLG,CSOAEXEC    IF COMMAND PRECEDED BY % SIGN,
         BZ    *+8                 THEN...
         OI    ZTFLAGS,ZTEXEC       INDICATE IMPLICIT EXEC
         TM    CSOAFLG,CSOAVNP     IF THERE ARE NO FURTHER OPERANDS,
         BNO   *+8                 THEN...
         OI    ECTSWS,ECTNOPD       SAY SO IN ECT
         B     SCANRET             RETURN
SCANBAD  DS    0H                  SYNTAX ERROR
         LA    #15,8               RETURN INDICATING BAD SYNTAX
******** B     SCANRET
SCANRET  L     #14,ZTSCAN14        RESTORE RETURN REGISTER
         BR    #14                 RETURN
         SPACE 2
MOVECMD  MVC   ZTCOMMND(0),0(#15)  MOVE COMMAND NAME TO NAME AREA
         SPACE
         LTORG
         EJECT
CKCMD    DS    0H
         SPACE
         ST    #14,ZTCKCM14        SAVE RETURN REGISTER
         NI    ZTFLAGS,255-ZTSUBER TURN OFF ERROR INDICATOR
         NI    ZTFLAGS,255-ZTAUTH  Also assume not APF authorized
         TM    ZTFLAGS,ZTEXEC      IF IMPLICIT %CLIST,
         BO    IMPLICIT            THEN PROCESS AS ONE. ELSE...
         CLC   ZTCOMMND(8),=CL8'ISPEXEC '  IF COMMAND = ISPEXEC
         BE    NGCMD                       THEN REJECT
*
******** BE    PROCESS_ISPEXEC_COMMAND future enhancement...
*
         MVC   ZTMODULE,ZTCOMMND   ELSE SET COMMAND NAME = SAME NAME
         OI    ZTFLAGS,ZTECTMOD    INDICATE ECT HAS BEEN CHANGED
         MVC   ECTPCMD,ZTMODULE    SET UP ECT COMMAND NAME
         MVI   ECTSCMD,C' '        CLEAR ECT SUBCOMMAND NAME TO BLANKS
         MVC   ECTSCMD+1(7),ECTSCMD
         CLC   =C'TIME ',ZTMODULE  IF COMMAND = TIME
         BNE   NOTTIME             THEN
         MVC   ZTMODULE,=CL8'IKJEFT25' SET MODULE NAME = IKJEFT25
         B     TSEVENT                 AND PROCESS WITHOUT SEARCHING
NOTTIME  CLC   =C'CALL ',ZTMODULE  IF COMMAND = CALL
         BNE   NOTCALL             THEN
******** MVC   ZTMODULE,=CL8'ISPCALL ' SET MODULE NAME = ISPCALL
         MVC   ZTMODULE,=CL8'IKJEFG00' SET MODULE NAME = IKJEFG00
         B     TSEVENT                 AND PROCESS WITHOUT SEARCHING
NOTCALL  CLC   =C'TEST ',ZTMODULE  If command = TEST
         BNE   NOTTEST             then
         ICM   #15,15,ZTE2ADDR      If we don't have addr of IKJEFTE2
         BZ    NGCMD                then not TSO/E, can't invoke TEST
         OI    ZTFLAGS,ZTAUTH       Else indicate APF authorization req
         B     TSEVENT              and process without searching.
NOTTEST  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Before searching for the command, search the table of authorized    *
* TSO commands to see if it requires APF authorization.  If it does,  *
* indicate so.  We will still have to search for it.                  *
*                                                                     *
***********************************************************************
         SPACE 1
         ICM   #15,15,ZTE2ADDR     Get address of IKJEFTE2
         BZ    NOTAUTH             If none, not TSO/E, not authorized
         LA    #1,16(,#15)         Point to first entry
E2LOOP   DS    0H                  Loop
         CLI   0(#1),C' '           until blank entry found
         BE    NOTAUTH              at which point it's not authorized
         CLC   0(8,#1),ZTMODULE     but if we found the module name
         BE    NEEDAUTH             then mark it authorized
         LA    #1,8(,#1)            else bump to next entry
         B     E2LOOP               and continue.
NEEDAUTH DS    0H                  Here if module is in E2 table
         OI    ZTFLAGS,ZTAUTH      Indicate APF authorization required
*
* ... we should probably bypass the search - TSO service'll do it NEhow
*
NOTAUTH  DS    0H                  Here if module is not authorized
         SPACE 1
***********************************************************************
* NOTE: AT THIS POINT IT IS POSSIBLE TO INSERT SOME ALTERNATE COMMAND *
* VALIDATION CODE SUCH AS AN ACF2 COMMAND VALIDATION SVC.  HOWEVER,   *
* WE WILL EMULATE THE TMP AND ISPF COMMAND SEARCH CODE INSTEAD.       *
***********************************************************************
         SPACE
         STM   #8,#11,ZLCISAVE     Save ZIL registers
         LM    #0,#1,ZTMODULE      LOAD COMMAND NAME INTO PARM REGS
         STM   #3,#9,32(#13)       SAVE REGISTERS USED BY LPA SEARCH
         L     #3,16               #3 = CVT ADDRESS
         L     #15,X'160'(,#3)     #15 -> LPA DIRECTORY SEARCH ROUTINE
         INSYS
         #BASR #14,#15             CALL LPA DIRECTORY SEARCH
***********************************************************************
* IF THE COMMAND NAME IS FOUND IN THE LPA DIRECTORY, CONTROL RETURNS  *
* TO THE NEXT SEQUENTIAL INSTRUCTION AND #14 IS SET TO ZERO.  IF THE  *
* COMMAND NAME HAS NOT BEEN FOUND, CONTROL RETURNS TO THE INSTRUCTION *
* AT +4 PAST HERE AND #14 IS NONZERO.                                 *
***********************************************************************
         LA    #14,0               IF SUCCESSFUL, SET #14 = 0
         LM    #3,#9,32(#13)       RESTORE REGISTERS USED BY LPA SEARCH
         LM    #8,#11,ZLCISAVE     Restore ZIL registers
         OUTSYS
         LTR   #14,#14             IF COMMAND NAME WAS FOUND,
         BZ    TSEVENT             THEN GO AHEAD AND USE IT. ELSE...
*
* Don't use command in JPA - probably a ZIL subroutine!
*
******** LA    #0,ZTMODULE         SET EPLOC PARAMETER FOR IDENTIFY
******** XR    #1,#1               SET ENTRY ADDRESS PARM FOR IDENTIFY
******** IDENTIFY ENTRY=(1),EPLOC=(0) SEE IF ENTRY NAME IS AROUND
******** CH    #15,=H'8'           IF RC=8, COMMAND IS IN JPA
******** BE    TSEVENT             SO GO USE IT
******** CH    #15,=H'20'          IF RC=20, COMMAND IS IN JPA
******** BE    TSEVENT             SO GO USE IT
         MVC   ZTBLDNAM,ZTMODULE   If none of the above, try BLDL
         L     #0,LINKDCB          Get address of link list DCB
         BLDL  (0),ZTBLDL          Find member in linklist, not ZIL lib
         LTR   #15,#15             SEE IF BLDL SUCCESSFUL
         BZ    TSEVENT             IF BLDL SUCCESSFUL, IT IS A COMMAND
******** BNZ   IMPLICIT            IF BLDL FAILED, IT MUST BE A CLIST
         SPACE
IMPLICIT DS    0H                  LOAD MODULE NOT FOUND, MUST BE CLIST
         MVC   ZTMODULE,=CL8'EXEC' SET COMMAND NAME = "EXEC"
         NI    ZTFLAGS,255-ZTAUTH  Show not APF authorized after all
         LH    #15,ZTOFFSET        PICK UP OFFSET OF CLIST NAME
         LTR   #15,#15             IF ZERO OFFSET, THEN IGNORE
         BNP   AFTBLNKX
         BCTR  #15,0               REDUCE FOR EXECUTE
         BCTR  #15,0               AND FOR MOVE CHARACTERS
         MVI   4(#5),C' '          SET BUFFER PRECEDING CLIST NAME
         EX    #15,MVCBLANK         TO BLANKS
AFTBLNKX XC    2(2,#5),2(#5)       SET COMMAND BUFFER OFFSET = ZERO
         OI    ZTFLAGS,ZTECTMOD    INDICATE ECT HAS BEEN CHANGED
         MVC   ECTPCMD,ZTMODULE    SET UP ECT COMMAND NAME
         MVI   ECTSCMD,C' '        CLEAR ECT SUBCOMMAND NAME TO BLANKS
         MVC   ECTSCMD+1(7),ECTSCMD
         SPACE
TSEVENT  DS    0H                  NOW WE ARE READY TO ISSUE COMMAND
         SPACE
***********************************************************************
* ISSUE TSVENT (SYSEVENT 0) TO TELL SYSTEM ABOUT COMMAND.             *
* NOTE: SVC 109 INTERFACE IS A POSSIBILITY HERE. HOWEVER, EXISTING    *
* TSO MONITORING PRODUCTS USE THE SVC 95 INTERFACE ONLY, EVEN THOUGH  *
* THE SVC 109 INTERFACE IS PARTICULARLY SUITED FOR APPLICATIONS SUCH  *
* AS THIS ROUTINE WHICH CREATE STACKS OF NESTED COMMAND INVOCATIONS.  *
***********************************************************************
         SPACE
         L     #1,ECTPCMD
         L     #15,ECTPCMD+4
         TSEVENT PPMODE            TELL SRM ABOUT THE COMMAND
         XR    #15,#15             INDICATE COMMAND IS OK
         B     CKCMDRET            AND RETURN
         SPACE
NGCMD    DS    0H                  COMMAND NOT VALID (TEST, ISPEXEC)
         MVC   ZTMSG(L'TESTMSG1),TESTMSG1  MOVE BEGINNING OF MESSAGE
         MVC   ZTMSG+L'TESTMSG1(8),ZTCOMMND  MOVE IN COMMAND NAME
         LA    #1,ZTMSG+L'TESTMSG1 POINT TO BEGINNING OF NAME
         LA    #14,8               MAX COUNT FOR NAME LENGTH
NGLOOP   CLI   0(#1),C' '          SCAN FOR FIRST BLANK
         BE    NGBLANK              FOLLOWING COMMAND NAME
         LA    #1,1(,#1)             UNTIL
         BCT   #14,NGLOOP             LENGTH OF NAME EXHAUSTED
NGBLANK  DS    0H
         MVC   0(L'TESTMSG2,#1),TESTMSG2  MOVE END OF MESSAGE
         LA    #0,L'TESTMSG2(,#1)  END OF MESSAGE
         LA    #14,ZTMSG           MINUS BEGINNING OF MESSAGE
         SLR   #0,#14              GIVES LENGTH OF MESSAGE
         XR    #1,#1               INDICATE MESSAGE ALREADY BUILT
         #BAS  #14,PUTLINE         DISPLAY ERROR MESSAGE
         LA    #1,12               SET ECT RETURN CODE TO 12
         STCM  #1,7,ECTRTCD        AS IF COMMAND NOT FOUND
         LA    #1,FLUSHALL
         #BAS  #14,FLUSH           AND FLUSH THE INPUT STACK
         LA    #15,8               INDICATE COMMAND INVALID
CKCMDRET L     #14,ZTCKCM14        RESTORE RETURN REGISTER
         BR    #14                 RETURN
         SPACE
MVCBLANK MVC   5(0,#5),4(#5)       FINISH MOVING BLANKS INTO CMD BUFFER
         SPACE
TESTMSG1 DC    C'ZILTSO02 ZIL TSO DOES NOT SUPPORT THE '
TESTMSG2 DC    C' COMMAND'
         SPACE
         LTORG
         EJECT
ATTACH   DS    0H
         SPACE
***********************************************************************
*                                                                     *
* This subroutine does one of the following:                          *
*                                                                     *
* (1) If the command requires APF authorization, invokes the TSO      *
*     Authorized Service Facility to invoke it.                       *
* (2) Otherwise, attaches the command as a subtask directly.          *
*                                                                     *
***********************************************************************
         SPACE
         ST    #14,ZTATT14         SAVE RETURN REGISTER
         SPACE
         TM    ZTFLAGS,ZTAUTH      If command requires authorization
         BO    ATTTSF              then go invoke TSO service facility
         SPACE
         XC    ZTCMDECB,ZTCMDECB   CLEAR ATTACH ECB
         XC    ZTATNECB,ZTATNECB   CLEAR ATTENTION ECB
         NI    ZTFLAGS,255-ZTSUBER CLEAR ERROR FLAG
         MVI   ZTSTATUS,ZTNORMAL   CLEAR COMMAND STATUS FLAG
         NI    ECTSWS2,255-ECTNOQPR ENABLE "? PROMPT HELP"
         L     #2,LINKDCB          Get address of linklist DCB
         LOAD  EPLOC=ZTMODULE,DCB=(#2) Make sure we load the right one.
         LA    #1,CPPL             POINT TO CPPL
         ATTACH EPLOC=ZTMODULE,SF=(E,ZTATTACH),ECB=ZTCMDECB,           X
               DCB=(#2),                                               X
               ESTAI=(STAIEXIT,(#12))     ATTACH THE COMMAND
         LTR   #15,#15             IF ATTACH FAILED,
         BZ    ATTACHOK            THEN
         LA    #1,=C'ATTACH'        BLOW UP
         LA    #0,6
         OI    ZTFLAGS,ZTSUBER
         B     ATTRET
ATTACHOK DS    0H
         LR    #2,#1               SAVE TCB ADDRESS
         USING TCB,#2
         WAIT  1,ECBLIST=ZTECBLST  WAIT FOR COMPLETION OR ATTENTION
         MVC   ECTRTCD,TCBCMPC     MOVE TCB COMPLETION CODE TO ECT
         MVI   ECTRCDF,0           INIT ECT CP = NOT ABENDED
         ST    #2,DA2CTCB          SAVE TCB ADDRESS FOR DAIR
         XC    ZTECB,ZTECB         CLEAR ECB
         INSYS
         CALLTSSR EP=IKJDAIR,MF=(E,DAPL)  MARK DATA SETS NOT IN USE
         OUTSYS
         ST    #15,ZTDAIRRC        SAVE DAIR RETURN CODE
         OI    ZTFLAGS,ZTDETACH    INDICATE DETACH IN PROGRESS
         LA    #1,DA2CTCB          POINT TO TCB ADDRESS
         DETACH (1),STAE=YES       DETACH THE COMMAND
         NI    ZTFLAGS,255-ZTDETACH INDICATE DETACH NOT IN PROGRESS
         CH    #15,=H'4'           IF DETACH FAILED,
         BNH   DETACHOK
         LA    #1,=C'DETACH'        BLOW UP
         LA    #0,6
         OI    ZTFLAGS,ZTSUBER
         B     ATTRET
         DROP  #2
DETACHOK DS    0H                  NOW, CHECK DAIRRC AFTER DETACH
         DELETE EPLOC=ZTMODULE     Delete what we loaded before.
         ICM   #15,15,ZTDAIRRC     IF DAIR RETURN CODE NOT ZERO,
         BZ    DAIROK              THEN...
         LA    #1,=C'DAIR'          BLOW UP
         LA    #0,4
         OI    ZTFLAGS,ZTSUBER
         B     ATTRET
DAIROK   DS    0H
         SPACE
         CLI   ZTSTATUS,ZTATTN     IF COMMAND TERMINATED BY ATTENTION,
         BE    ATTFLUSH            THEN FLUSH THE INPUT STACK
         CLI   ZTSTATUS,ZTABEND    ELSE IF THE COMMAND ABENDED,
         BNE   ATTRET              THEN
ABFLUSH  OI    ECTRCDF,X'80'        INDICATE CP ABENDED IN ECT
         LA    #1,FLUSHALL          FOR ABEND, DO NORMAL STACK FLUSH
         B     FLUSHCMD             AND FLUSH THE INPUT STACK.
ATTFLUSH LA    #1,FLUSHTOP         FOR ATTN, DO EVEN IF CONTROL=NOFLUSH
FLUSHCMD #BAS  #14,FLUSH           FLUSH THE INPUT STACK
ATTRET   L     #14,ZTATT14         RESTORE RETURN REGISTER
         BR    #14                 RETURN
         SPACE
ATTTSF   DS    0H                  Here if command is APF authorized
         SPACE
         XR    #0,#0               Make a zero
         ST    #0,ZTTSFRC          Initialize TSO command return code
         ST    #0,ZTTSFRS          Initialize TSO command reason code
         ST    #0,ZTTSFAC          Initialize TSO command abend code
         LA    #1,TSFFLAGS         Point to flags
         ST    #1,ZTTSFP1          Store parameter 1
         L     #2,CPPLCBUF         Get address of command buffer
         LA    #1,4(,#2)           Point to command buffer text
         ST    #1,ZTTSFP2          Store parameter 2
         LH    #1,0(,#2)           Get length of command buffer
         SH    #1,=H'4'            Adjust length to length of text
         ST    #1,ZTTSFLEN         Store length
         LA    #1,ZTTSFLEN         Get address of length
         ST    #1,ZTTSFP3          Store parameter 3
         LA    #1,ZTTSFRC          Point to where to store return code
         ST    #1,ZTTSFP4          Store parameter 4
         LA    #1,ZTTSFRS          Point to where to store reason code
         ST    #1,ZTTSFP5          Store parameter 5
         LA    #1,ZTTSFAC          Point to where to store abend code
         ST    #1,ZTTSFP6          Store parameter 6
         OI    ZTTSFP6,X'80'       Set VL bit
         LA    #1,ZTTSFP1          Point to parameter list
         L     #15,X'10'           Get address of CVT
         L     #15,CVTTVT-CVT(,#15) Get address of TSVT
         L     #15,TSVTASF-TSVT(,#15) Get address of IKJEFTSR
         INSYS
         #BASR #14,#15             Call IKJEFTSR
         OUTSYS
         SPACE
* OK, now process all those godawful return codes.  Who designed this!
         SPACE
         B     TSFRC(#15)          Branch depending on return code
TSFRC    B     TSFRC0              0 = OK
         B     TSFRC4              4 = nonzero return code from command
         B     TSFRC8              8 = attention interrupt
         B     TSFRC12             12 = abend
         B     TSFRC16             16 = parm address in protected stg.
         B     TSFRC20             20 = error in parameter list
         B     TSFRC24             24 = unexpected TSO failure
         B     TSFRC28             28 = AMODE 24 but parms are AMODE 31
         SPACE
TSFRC0   EQU   ATTRET              0 = OK
TSFRC4   EQU   ATTRET              4 = nonzero return code from command
         SPACE
TSFRC8   DS    0H                  8 = attention interrupt
         SPACE
         MVI   ZTSTATUS,ZTATTN     INDICATE ATTENTION INTERRUPT
         MVC   ZTMSG(L'ATNMSGID),ATNMSGID   SET UP BEGINNING OF MESSAGE
         MVC   ZTMSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE
         MVC   ZTMSG1+8(L'ATTNMSG),ATTNMSG  SET UP NEXT PART OF MESSAGE
         LA    #0,L'ATNMSGID+8+L'ATTNMSG    GET LENGTH OF ATTENTION MSG
         XR    #1,#1               INDICATE MESSAGE SET UP
         #BAS  #14,PUTLINE         CALL PUTLINE TO DISPLAY THE MESSAGE
         B     ATTFLUSH            Return to flush stack for attn & ret
         SPACE
TSFRC12  DS    0H                  12 = abend
         SPACE
         MVI   ZTSTATUS,ZTABEND    INDICATE COMMAND ABENDED
         MVC   ZTABCODE(3),ZTTSFAC+1 STORE ABEND CODE
         SPACE
***********************************************************************
* DISPLAY "ENDED DUE TO ERROR" MESSAGE                                *
***********************************************************************
         SPACE
         MVC   ZTMSG(L'ABEMSGID),ABEMSGID   SET UP BEGINNING OF MESSAGE
         MVC   ZTMSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE
         MVC   ZTMSG1+8(L'ABEMSG1),ABEMSG1  SET UP NEXT PART OF MESSAGE
         CLC   ZTABCODE,=X'000FFF'          IF CODE GREATER THAN 4095
         BNH   TSFUSRAB                     THEN MUST BE A SYSTEM ABEND
         MVC   ZTMSG2(6),=C'SYSTEM'         SO SAY SO
         MVC   ZTMSG2+6(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE
         UNPK  ZTSYSTEM(3),ZTABCODE(2)      PUT ABEND CODE IN HEX IN
         MVZ   ZTSYSTEM(3),=X'000000'
         TR    ZTSYSTEM(3),=C'0123456789ABCDEF'
         LA    #0,ZTSYSL                    GET LENGTH OF MESSAGE
         B     TSFANYAB                     GO TO DISPLAY IT
TSFUSRAB MVC   ZTMSG2(4),=C'USER'           ELSE SAY IT'S A USER ABEND
         MVC   ZTMSG2+4(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE
         XR    #0,#0
         ICM   #0,7,ZTABCODE                GET NUMERIC USER ABEND CODE
         CVD   #0,ZTDOUBLE                  CONVERT TO DISPLAY
         UNPK  ZTUSER(4),ZTDOUBLE
         OI    ZTUSER+3,X'F0'
         LA    #0,ZTUSERL                   GET LENGTH OF MESSAGE
TSFANYAB DS    0H
         XR    #1,#1               INDICATE MESSAGE SET UP
         #BAS  #14,PUTLINE         CALL PUTLINE TO DISPLAY THE MESSAGE
         B     ABFLUSH
TSFRC16  DS    0H                  16 = parm address in protected stg.
TSFRC20  DS    0H                  20 = error in parameter list
TSFRC24  DS    0H                  24 = unexpected TSO failure
TSFRC28  DS    0H                  28 = AMODE 24 but parms are AMODE 31
         LA    #1,=C'IKJEFTSR'     FATAL TSO SERVICE FACILITY ERROR
         LA    #0,8
         B     ERROR
         SPACE
TSFFLAGS DS    0F                  First parm to IKJEFTSR (flags)
         DC    X'0000'             First 2 bytes must be zeroes
         DC    X'01'               Take a dump in case of ABEND
         DC    X'01'               Invoke as command, not as CLIST
*                                  (so stacked commands are handled
*                                   by us instead of IKJEFTSR)
         EJECT
***********************************************************************
* THIS SUBROUTINE ISSUES A PUTGET MACRO INSTRUCTION TO DISPLAY A MODE *
* MESSAGE (WHERE APPROPRIATE) AND RETRIEVE A COMMAND LINE FROM THE    *
* CURRENT SOURCE OF INPUT.  IF THE PUTGET RETURNS WITH A CODE OF 12   *
* (MEANING THAT A SECOND-LEVEL MESSAGE CHAIN IS AVAILABLE BUT THE     *
* USER IS IN A CLIST AND THE "NOPAUSE" PROFILE OPTION IS ACTIVE), IT  *
* IS RETRIED AFTER SETTING THE BIT IN THE ECT WHICH PURGES            *
* SECOND-LEVEL MESSAGES.  IF IT RETURNS WITH A CODE OF 24 (INVALID    *
* PARAMETERS), CONTROL IS RETURNED WITHOUT AN ERROR INDICATION - THIS *
* IS USED TO DETERMINE IF A CLIST HAS TERMINATED.  THIS "TRICK" WAS   *
* USED IN ISPF MODULE ISPCAT TO DETERMINE THE END OF A CLIST.         *
*                                                                     *
* UPON RETURN, #5 CONTAINS THE ADDRESS OF THE INPUT BUFFER RETURNED   *
* BY PUTGET IF THE RETURN CODE IS 0 OR 4, ELSE #5 CONTAINS ZERO.      *
*                                                                     *
***********************************************************************
         SPACE
PUTGET   DS    0H
         ST    #14,ZTPG14          SAVE RETURN REGISTER
PGRETRY  DS    0H
         MVI   ZTSTATUS,ZTNORMAL   CLEAR COMMAND STATUS FLAG
         XR    #5,#5               SET PUTGET BUFFER ADDRESS TO ZERO
         ST    #5,ZTECB            CLEAR ECB
         INSYS
         PUTGET PARM=PGPB,MF=(E,IOPL)  ISSUE PUTGET
         OUTSYS
         CH    #15,=H'24'          IF RETURN CODE GREATER THAN 24,
         BH    PGERROR              THEN BLOW UP
         B     PGGO(#15)           ELSE PROCESS EACH POSSIBLE R.C.
PGGO     B     PGGOTLN         0 = LINE CAME FROM TERMINAL
         B     PGGOTLN         4 = LINE CAME FROM IN-STORAGE LIST
         B     PUTGET8         8 = ATTENTION INTERRUPTION
         B     PUTGET12       12 = NO LINE DUE TO SECOND-LEVEL MESSAGE
         B     PGERROR        16 = ERROR
         B     PGERROR        20 = ERROR
         B     PGRETURN       24 = BAD MODE MESSAGE - TERMINAL INPUT
         SPACE
PUTGET8  MVI   ZTSTATUS,ZTATTN     RC=8: INDICATE ATTENTION INTERRUPT
         B     PGRETURN              AND RETURN
PUTGET12 TM    ECTMSGF,X'80'       RC=12: IF 2ND-LVL MSGS ALRDY PURGED,
         BO    PGERROR                    THEN UNRECOVERABLE ERROR
         OI    ECTMSGF,X'80'         ELSE PURGE 2ND-LEVEL MESSAGE CHAIN
         B     PGRETRY                AND REISSUE PUTGET
PGERROR  DS    0H                  BAD RETURN CODE?
         CH    #15,=H'40'          If RC = 40 (SUBSTACK found barrier)
         BE    PGRETURN            then return OK, caller will handle
         OI    ZTFLAGS,ZTSUBER     Else bad RC, unrecoverable error
         B     PGRETURN            SO JUST RETURN.
PGGOTLN  L     #5,PGPBIBUF         GET ADDRESS OF PUTGET INPUT BUFFER
PGRETURN L     #14,ZTPG14          RESTORE RETURN REGISTER
         BR    #14                 RETURN
         EJECT
***********************************************************************
* THIS ROUTINE DISPLAYS MESSAGES TO THE TSO USER USING THE TSO        *
* PUTLINE SERVICE ROUTINE.  AT ENTRY #1 CONTAINS THE ADDRESS OF THE   *
* MESSAGE TO BE DISPLAYED, AND #0 CONTAINS THE LENGTH OF THE MESSAGE. *
* IF #1 IS ZERO, THE MESSAGE HAS ALREADY BEEN BUILT IN THE WORKAREA   *
* ZTMSG.  THE MESSAGE IS ASSUMED TO BEGIN WITH A MESSAGE ID UNLESS    *
* THE FIRST CHARACTER IS BLANK, IN WHICH CASE THE INITIAL BLANK IS    *
* STRIPPED OFF BY PUTLINE ANYHOW.                                     *
* NOTE THAT THIS SUBROUTINE ESTABLISHES ITS OWN BASE REGISTER.  THIS  *
* IS BECAUSE THIS SUBROUTINE IS REFERENCED BY INTERCEPT ROUTINES      *
* WHERE THE NORMAL BASE REGISTER IS UNAVAILABLE.                      *
***********************************************************************
         SPACE
PUTLINE  DS    0H
         ST    #14,ZTPUTL14        SAVE RETURN REGISTER
         LTR   #15,#0              LOAD LENGTH VALUE
         BNP   PUTLRET             IF ZERO, DON'T DO ANYTHING
         BCTR  #15,0               ELSE REDUCE LENGTH FOR EXECUTE
         LTR   #1,#1               IF #1 IS ZERO,
         BZ    PUTIT               THEN MESSAGE ALREADY SET UP. ELSE...
         EX    #15,MOVEPUT         MOVE MESSAGE TO WORK AREA
PUTIT    DS    0H
         LA    #15,5(,#15)         RESTORE LENGTH + 4 FOR HEADER
         SLL   #15,16              SHIFT LENGTH INTO LEFT HALF OF HDR
         STCM  #15,15,ZTMSGHDR     PUT ZEROES INTO RIGHT HALF OF HDR
         XC    ZTECB,ZTECB         CLEAR ECB
         INSYS
         PUTLINE PARM=PTPB,MF=(E,IOPL)  ISSUE PUTLINE
         OUTSYS
         LTR   #15,#15             IF PUTLINE OK
         BZ    PUTLRET             THEN RETURN
         CH    #15,=H'8'           ELSE IF ATTENTION INTERRUPT
         BNE   PUTERROR            THEN
         MVI   ZTSTATUS,ZTATTN      INDICATE SO
         B     PUTLRET             ELSE PUTLINE ERROR
PUTERROR LA    #1,BADPUT
         LA    #0,L'BADPUT
         TPUT  (1),(0),R           TELL USER PUTLINE FAILED VIA TPUT
         LA    #1,ZTMSG
         LH    #0,ZTMSGHDR
         SH    #0,=H'4'
         TPUT  (1),(0),R           DISPLAY MESSAGE VIA TPUT
PUTLRET  L     #14,ZTPUTL14        RESTORE RETURN REGISTER
         BR    #14                 RETURN
         SPACE
MOVEPUT  MVC   ZTMSG(0),0(#1)      MOVE MESSAGE TO WORK AREA
BADPUT   DC    C'ZILTSO08: PUTLINE FAILURE, FOLLOWING MESSAGE IS BEING X
               ISSUED VIA TPUT:'
         EJECT
***********************************************************************
* THIS ROUTINE DELETES ELEMENTS FROM THE INPUT STACK.  IT IS USED     *
* WHEN AN ERROR OCCURS THAT WOULD REQUIRE THAT NO MORE COMMANDS IN A  *
* CLIST BE EXECUTED.  IT ALSO CLEARS THE TERMINAL INPUT QUEUE SO THAT *
* ADDITIONAL COMMANDS "STACKED" WITH FIELD MARKS ARE NOT EXECUTED.    *
* ON ENTRY TO THIS SUBROUTINE #1 POINTS TO THE LIST FORM OF THE STACK *
* MACRO INSTRUCTION TO BE EXECUTED.  NORMALLY STACK DELETE=ALL WILL   *
* BE USED; THIS FLUSHES ALL ELEMENTS FROM THE STACK EXCEPT (1) THE    *
* BOTTOM ELEMENT, (2) ANY CLISTS WHICH HAVE CONTROL NOFLUSH OR        *
* CONTROL MAIN ACTIVE.  FOR ATTENTION-PROVOKED FLUSHES, WE USE STACK  *
* DELETE=TOP.  THIS DELETES THE TOP ELEMENT FROM THE STACK UNLESS IT  *
* IS A CLIST WITH CONTROL MAIN ACTIVE.                                *
***********************************************************************
         SPACE
FLUSH    DS    0H
         ST    #14,ZTFLSH14        SAVE RETURN REGISTER
         LR    #2,#1               GET STACK LIST FORM
         TCLEARQ INPUT             CLEAR TERMINAL INPUT QUEUE
         XC    ZTECB,ZTECB         CLEAR ECB
         INSYS
         STACK PARM=(#2),MF=(E,IOPL)  FLUSH THE STACK
         OUTSYS
         LTR   #15,#15             IF STACK FAILED
         BZ    FLUSHRET            THEN SAY SO
         LA    #1,BADSTACK
         LA    #0,L'BADSTACK
         #BAS  #14,PUTLINE
FLUSHRET LA    #14,12              SET RETURN CODE TO 12 WHEN FLUSHING
         ST    #14,ZTRETCD
         L     #14,ZTFLSH14        RESTORE RETURN REGISTER
         BR    #14                 RETURN
         SPACE
BADSTACK DC    C'ZILTSO07 TSO ERROR FLUSHING STACK'
         SPACE
         LTORG
         SPACE
         TITLE 'TSO - STAI EXIT FOR ABENDING COMMANDS'
STAIEXIT DS    0H
         DROP  #3,#12
         USING STAIEXIT,#15
         LA    #10,12              CHECK IF REGISTER 0 = "12"
         CR    #0,#10              IF AN SDWA IS AVAILABLE,
         BE    NOSDWA              THEN...
         L     #12,0(,#1)           #12 -> WORKAREA
         L     #11,4(,#1)           #11 = ABEND COMPLETION CODE
         B     AFTSDWA             ELSE...
NOSDWA   LR    #12,#2               #12 -> WORKAREA
         LR    #11,#1               #11 = ABEND COMPLETION CODE
         XR    #1,#1                Clear SDWA address - ain't none
AFTSDWA  DS    0H
         LA    #3,4095(,#12)
         DROP  #15
         USING TSO,#12
         USING TSO+4095,#3
         ST    #1,ZTSDWA           Save address of SDWA
         ST    #14,ZTSTAI14        SAVE RETURN REGISTER
         L     #4,CPPLECT          ESTABLISH ADDRESSABILITY TO ECT
         TM    ZTFLAGS,ZTDETACH    IF DETACH IN PROGRESS
         BZ    NOT33E               AND
         CLM   #11,7,=X'33E000'      ABEND CODE IS S33E
         BNE   NOT33E                 THEN...
         MVC   ZTMSG(L'ATNMSGID),ATNMSGID   SET UP BEGINNING OF MESSAGE
         MVC   ZTMSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE
         MVC   ZTMSG1+8(L'ATTNMSG),ATTNMSG  SET UP NEXT PART OF MESSAGE
         LA    #15,L'ATNMSGID+8+L'ATTNMSG   GET LENGTH OF ATTENTION MSG
         B     ANYABEND                GO TO DISPLAY THE MESSAGE
NOT33E   DS    0H
         MVI   ZTSTATUS,ZTABEND    INDICATE COMMAND ABENDED
         STCM  #11,7,ZTABCODE      STORE ABEND CODE
         SPACE
***********************************************************************
* DISPLAY "ENDED DUE TO ERROR" MESSAGE                                *
***********************************************************************
         SPACE
         MVC   ZTMSG(L'ABEMSGID),ABEMSGID   SET UP BEGINNING OF MESSAGE
         MVC   ZTMSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE
         MVC   ZTMSG1+8(L'ABEMSG1),ABEMSG1  SET UP NEXT PART OF MESSAGE
         CLC   ZTABCODE,=X'000FFF'          IF CODE GREATER THAN 4095
         BNH   USRABEND                     THEN MUST BE A SYSTEM ABEND
         MVC   ZTMSG2(6),=C'SYSTEM'         SO SAY SO
         MVC   ZTMSG2+6(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE
         UNPK  ZTSYSTEM(3),ZTABCODE(2)      PUT ABEND CODE IN HEX IN
         MVZ   ZTSYSTEM(3),=X'000000'
         TR    ZTSYSTEM(3),=C'0123456789ABCDEF'
         LA    #15,ZTSYSL                   GET LENGTH OF MESSAGE
         B     ANYABEND                     GO TO DISPLAY IT
USRABEND MVC   ZTMSG2(4),=C'USER'           ELSE SAY IT'S A USER ABEND
         MVC   ZTMSG2+4(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE
         XR    #0,#0
         ICM   #0,7,ZTABCODE                GET NUMERIC USER ABEND CODE
         CVD   #0,ZTDOUBLE                  CONVERT TO DISPLAY
         UNPK  ZTUSER(4),ZTDOUBLE
         OI    ZTUSER+3,X'F0'
         LA    #15,ZTUSERL                  GET LENGTH OF MESSAGE
ANYABEND DS    0H
         LA    #15,4(,#15)         ADD 4 TO LENGTH FOR HEADER
         SLL   #15,16              SHIFT LENGTH INTO LEFT HALF OF HDR
         STCM  #15,15,ZTMSGHDR     PUT ZEROES INTO RIGHT HALF OF HDR
         XC    ZTECB,ZTECB         CLEAR ECB
         PUTLINE PARM=PTPB,MF=(E,IOPL)  ISSUE PUTLINE
         LTR   #15,#15             IF PUTLINE OK
         BZ    STAIPTRT            THEN RETURN
         CH    #15,=H'8'           ELSE IF ATTENTION INTERRUPT
         BNE   STAIPTER            THEN
         MVI   ZTSTATUS,ZTATTN      INDICATE SO
         B     STAICONT
STAIPTER LA    #1,BADPUT           ELSE PUTLINE ERROR
         LA    #0,L'BADPUT
         TPUT  (1),(0),R           TELL USER PUTLINE FAILED VIA TPUT
         LA    #1,ZTMSG
         LH    #0,ZTMSGHDR
         SH    #0,=H'4'
         TPUT  (1),(0),R           DISPLAY MESSAGE VIA TPUT
STAIPTRT DS    0H
         SPACE
STAICONT L     #2,ZTSTAI14         Get return register
         LA    #15,16              Set return code in case no SDWA
         ICM   #10,15,ZTSDWA       Get SDWA address
         BZR   #2                  If none, just branch back w/rc=16
         SETRP WKAREA=(#10),RC=16  Let ABEND continue without ESTAI
         BR    #2                  Return to caller
         SPACE
ABEMSGID DC    C'ZILTSO03 '
ABEMSG1  DC    C' ENDED DUE TO ERROR, '
ABEMSG2  DC    C' ABEND CODE '
         SPACE
ATNMSGID DC    C'ZILTSO04 '
ATTNMSG  DC    C' TERMINATED BY ATTENTION INTERRUPTION'
         SPACE
         LTORG
         SPACE
         TITLE 'TSO - STAE EXIT FOR INTERNAL ABEND'
STAEEXIT DS    0H
         DROP  #3,#12
         USING STAEEXIT,#15
         LA    #10,12              CHECK IF REGISTER 0 = "12"
         CR    #0,#10              IF AN SDWA IS AVAILABLE,
         BE    NOSDWAE             THEN...
         L     #12,0(,#1)           #12 -> WORKAREA
         B     AFTSDWAE            ELSE...
NOSDWAE  LR    #12,#2               #12 -> WORKAREA
AFTSDWAE DS    0H
         LA    #3,4095(,#12)
         DROP  #15
         USING TSO,#12
         USING TSO+4095,#3
         L     #4,CPPLECT          ESTABLISH ADDRESSABILITY TO ECT
         MVC   ECTIOWA(4),ZTSVIOA  RESTORE ECT INPUT STACK ADDRESS
         MVC   ECTPCMD(16),ZTCMDS  RESTORE ECT COMMAND/SUBCOMMAND NAMES
         XR    #15,#15             CONTINUE WITH ABNORMAL TERMINATION
         BR    #14                 AND RETURN
         SPACE
         LTORG
         SPACE
         TITLE 'TSO - STAX EXIT FOR ATTENTION INTERRUPT'
STAXEXIT DS    0H
         SPACE
         DROP  #3,#12
         USING STAXEXIT,#15
         L     #12,8(,#1)          GET ADDRESS OF USER PARAMETER LIST
         LA    #3,4095(,#12)
         DROP  #15
         USING TSO,#12
         USING TSO+4095,#3
         LR    #9,#14              SAVE RETURN ADDRESS
         STATUS STOP               MAKE SUBTASK NONDISPATCHABLE
         MVI   ZTSTATUS,ZTATTN     INDICATE ATTENTION OCCURRED
         POST  ZTECB,0             POST SERVICE ROUTINES ECB
         POST  ZTATNECB,0          POST ECB FOR COMMAND ATTACH
         BR    #9                  RETURN TO SYSTEM
         SPACE
         LTORG
         SPACE
         TITLE 'TSO - DATA AREAS'
         SPACE
ZTDOUBLE DS    D                   FOR NUMERIC CONVERSIONS
ZTSCAN14 DS    A                   SAVE AREA FOR SCAN SUBROUTINE
ZTCKCM14 DS    A                   SAVE AREA FOR CKCMD SUBROUTINE
ZTATT14  DS    A                   SAVE AREA FOR ATTACH SUBROUTINE
ZTPUTL14 DS    A                   SAVE AREA FOR PUTLINE SUBROUTINE
ZTPG14   DS    A                   SAVE AREA FOR PUTGET SUBROUTINE
ZTFLSH14 DS    A                   SAVE AREA FOR FLUSH SUBROUTINE
ZTSTAI14 DS    A                   SAVE AREA FOR STAI EXIT ROUTINE
ZTECB    DS    F                   ECB FOR TSO SERVICE ROUTINES
ZTCMDECB DS    F                   ECB FOR ATTACHED COMMANDS
ZTATNECB DS    F                   ECB FOR ATTENTION INTERRUPTIONS
ZTECBLST DS    2A                  ECB LIST
ZTE2ADDR DS    A                   Address of IKJEFTE2
ZTSDWA   DS    A                   Address of SDWA
LINKDCB  DS    A                   Address of SYS1.LINKLIB DCB
         SPACE
CPPL     DS    0F                  COMMAND PROCESSOR PARAMETER LIST
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJCPPL)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *
*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *
***********************************************************************
         SPACE
CPPLCBUF DS    A        PTR TO COMMAND BUFFER
CPPLUPT  DS    A        PTR TO UPT
CPPLPSCB DS    A        PTR TO PSCB
CPPLECT  DS    A        PTR TO ECT
         SPACE 2
IOPL     DS    0F                  I/O SERVICE ROUTINE PARAMETER LIST
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJIOPL)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
         SPACE
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
         SPACE 2
DAPL     DS    0F                  DYNAMIC ALLOCATION PARAMETER LIST
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJDAPL)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *
*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *
*    VIA REGISTER 1
***********************************************************************
         SPACE
DAPLUPT  DS    A        PTR TO UPT
DAPLECT  DS    A        PTR TO ECT
DAPLECB  DS    A        PTR TO CP'S ECB
DAPLPSCB DS    A        PTR TO PSCB
DAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK
         SPACE
DAPB2C   DS    0F                  DAIR PARAMETER LIST FOR CODE 2C
         SPACE
***********************************************************************
* COPIED FROM SYS1.MACLIB(IKJDAP2C) BECAUSE THE MACRO FORCES A DSECT  *
***********************************************************************
* THIS OPERATION CODE ALLOWS FOR RE-USE  OF TIOT ENTRIES              *
* IT IS USED BY THE TMP BEFORE DETACHING A TASK, AND BY ANY  TASK     *
* WHICH ATTACHES SUB-TASKS                                            *
***********************************************************************
         SPACE
DA2CCD   DS    CL2      DAIR ENTRY CODE
DA2CFLG  DS    H        FLAG FIELD
DA2CTCB  DS    A        TCB ADDR OF DSE ENTRIES MARKED NOT IN USE
DA2CDDN  DS    CL8        DDNAME
         SPACE
ZTNEWECT DS    A                   @ of ECT created by ENVIRON=CREATE
ZTRETCD  DS    F                   RETURN CODE FROM COMMAND
ZTDAIRRC DS    F                   RETURN CODE FROM IKJDAIR
ZTSVIOA  DS    F                   SAVE INPUT STACK ADDRESS
ZTSCANRC DS    H                   RETURN CODE FROM IKJSCAN
ZTOFFSET DS    H                   SAVED OFFSET OF POSSIBLE CLIST NAME
ZTCMDS   DS    CL16                SAVED ECT COMMAND AND SUBCOMMAND
ZTCOMMND DS    CL8                 COMMAND NAME FROM SCAN
ZTMODULE DS    CL8                 MODULE NAME FOR COMMAND
ZTBLDL   DS    F                   BLDL LIST FOR COMMAND CHECK
ZTBLDNAM DS    CL8                 MODULE NAME FOR COMMAND
         DS    XL4                 FILLER FOR BLDL
ZTABCODE DS    XL3                 ABEND CODE STORED BY STAI EXIT
ZTFLAGS  DS    X                   FLAGS
ZTEXEC   EQU   B'10000000'          1 = IMPLICIT EXEC COMMAND (%)
ZTSTKMOD EQU   B'01000000'          1 = ECT INPUT STACK ADDR ALTERED
ZTECTMOD EQU   B'00100000'          1 = ECT PCMD/SCMD WAS ALTERED
ZTESTON  EQU   B'00010000'          1 = ESTAE SUCCESSFUL
ZTSTXON  EQU   B'00001000'          1 = STAX SUCCESSFUL
ZTSUBER  EQU   B'00000100'          1 = SEVERE ERROR IN SUBROUTINE
ZTDETACH EQU   B'00000010'          1 = DETACH IN PROGRESS
ZTAUTH   EQU   B'00000001'          1 = command requires authorization
ZTSTATUS DS    X                   COMMAND STATUS FLAG
ZTNORMAL EQU   0                    COMMAND COMPLETED NORMALLY
ZTATTN   EQU   1                    ATTENTION INTERRUPT OCCURRED
ZTABEND  EQU   2                    ABNORMAL TERMINATION OCCURRED
ZTTSOE   DS    X                   Level of TSO/Extensions active
         SPACE
PTPB     PUTLINE MF=L,OUTPUT=(*-*,TERM,SINGLE,INFOR)
         ORG   PTPB                PUTLINE PARAMETER BLOCK
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJPTPB)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE PUTLINE PARAMETER BLOCK (PTPB) IS POINTED TO BY THE PARAM.   *
*    LIST PASSED TO PUTLINE.  IT IS USED TO RETURN PERTINENT INFO.    *
*    AS WELL AS CONTROL PUTLINE FUNCTIONS                             *
***********************************************************************
         SPACE
         DS    0F
         DS    CL4      INTERNAL PUTLINE USAGE
PTPBOPUT DS    A        ADDRESS OF OUTPUT LINE DESCRIPTOR OR DATA LINE
PTPBFLN  DS    A        PTR TO FORMATTED LINE RETURNED WHEN OUTPUT=
*                       ADDR,FORMAT) IS SPECIFIED
         ORG
         SPACE
PGPB     PUTGET  MF=L,OUTPUT=(*-*,,MODE)
PGPBL    EQU   *-PGPB
PGPBSUB  PUTGET  MF=L,OUTPUT=(*-*,,MODE),SUBSTACK=YES
PGPBSUBL EQU   *-PGPBSUB
         ORG   PGPB                PUTGET PARAMETER BLOCK
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJPGPB)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE PUTGET PARAMETER BLOCK (PGPB) IS POINTED TO BY THE LIST      *
*    PASSED TO PUTGET.  PUTGET USES IT FOR CONTROL AS WELL AS         *
*    RETURNING INFORMATION.                                           *
***********************************************************************
         SPACE
         DS    0F
         DS    CL12     INTERNAL TO GETLINE/PUTLINE
PGPBIBUF DS    A        PTR TO OBTAINED INPUT LINE
         ORG
         SPACE
STKINIT  STACK MF=L,DATASET=*      STACK TERMINAL ELEMENT LIST FORM
FLUSHALL STACK MF=L,DELETE=ALL     NORMAL STACK FLUSH LIST FORM
FLUSHTOP STACK MF=L,DELETE=TOP     ATTN STACK FLUSH LIST FORM
STKECREA STACK MF=L,ENVIRON=CREATE  TSO/E Version 2 ECT builder
STKEDEST STACK MF=L,ENVIRON=DESTROY TSO/E Version 2 ECT remover
STKBARR  STACK MF=L,BARRIER=*
STKDELB  STACK MF=L,DELETE=BARRIER
ZTATTACH ATTACH SF=L,SHSPV=78,SZERO=NO
ZTESTAE  ESTAE MF=L
ZTSTAX   STAX  MF=L,REPLACE=NO
         SPACE
MODEDATA DC    Y(MODELEN,0)
MODEMSG  DC    C' TSO'             LEADING BLANK REQUIRED - NO MSGID
MODELEN  EQU   *-MODEDATA
         SPACE
***********************************************************************
* MESSAGES                                                            *
***********************************************************************
         SPACE
SYNMSG   DC    C'ZILTSO01 INVALID COMMAND SYNTAX'
TERMMSG  DC    C'ZILTSO05 COMMAND INPUT IGNORED, CLIST HAS TERMINATED'
ERRMSG1  DC    C'ZILTSO06 TSO FAILED, '
ERRMSG2  DC    C' ERROR CODE '
         SPACE
         LTORG
         EJECT
         SPACE
***********************************************************************
* Fields used by the TSO Authorized Service Facility                  *
***********************************************************************
         SPACE
ZTTSFP1  DS    A                   TSO Service Facility parameter 1
ZTTSFP2  DS    A                   TSO Service Facility parameter 2
ZTTSFP3  DS    A                   TSO Service Facility parameter 3
ZTTSFP4  DS    A                   TSO Service Facility parameter 4
ZTTSFP5  DS    A                   TSO Service Facility parameter 5
ZTTSFP6  DS    A                   TSO Service Facility parameter 6
ZTTSFRC  DS    A                   Return code from TSO command
ZTTSFRS  DS    A                   Reason code from TSO command
ZTTSFAC  DS    A                   Abend code from TSO command
ZTTSFLEN DS    A                   Length of command
         SPACE
***********************************************************************
* PUTGET MODE MESSAGE AREA                                            *
***********************************************************************
         SPACE
ZTPGOLD  DS    A(1)                NUMBER OF MESSAGE SEGMENTS
ZTPGPTR  DS    A                   ADDRESS OF THE ONLY MESSAGE SEGMENT
ZTPGHDR  DS    2Y                  MESSAGE HEADER
ZTPGMODE DS    CL(L'MODEMSG)       MESSAGE TEXT
         SPACE
***********************************************************************
* WORKAREA FOR CONSTRUCTING PUTLINE MESSAGES                          *
* NOTE: THIS IS SET UP FOR SINGLE-LEVEL INFORMATIONAL MESSAGES ONLY.  *
***********************************************************************
         SPACE
ZTMSGOLD DS    A(1)                NUMBER OF MESSAGE SEGMENTS
ZTMSGPTR DS    A                   ADDRESS OF THE ONLY MESSAGE SEGMENT
ZTMSGHDR DS    2Y                  MESSAGE HEADER
ZTMSG    DS    CL128               MESSAGE TEXT
ZTMSG1   EQU   ZTMSG+L'ABEMSGID    OFFSET OF "ENDED DUE TO ERROR"
ZTMSG2   EQU   ZTMSG1+8+L'ABEMSG1  OFFSET OF "SYSTEM" OR "USER"
ZTSYSTEM EQU   ZTMSG2+6+L'ABEMSG2  OFFSET OF SYSTEM ABEND CODE
ZTUSER   EQU   ZTMSG2+4+L'ABEMSG2  OFFSET OF USER ABEND CODE
ZTSYSL   EQU   ZTSYSTEM+3-ZTMSG    LENGTH OF SYSTEM ABEND MESSAGE
ZTUSERL  EQU   ZTUSER+4-ZTMSG      LENGTH OF USER ABEND MESSAGE
         SPACE 2
CSPL     DS    0D                  COMMAND SCAN PARAMETER LIST
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJCSPL)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE COMMAND SCAN PARAMETER LIST (CSPL) IS A LIST OF ADDRESSES    *
*    PASSED FROM THE INVOKER TO COMMAND SCAN VIA REGISTER 1           *
***********************************************************************
         SPACE
CSPLUPT  DS    A        PTR TO  UPT
CSPLECT  DS    A        PTR TO  ECT
CSPLECB  DS    A        PTR TO  CP'S ECB
CSPLFLG  DS    A        PTR TO  FLAG WORD WHICH IS OBTAINED & FREED
*                       BY CALLER. BIT 0 SET TO 0= SYNTAX CHECKING OF
*                       COMMAND NAME.
CSPLOA   DS    A        PTR TO OUTPUT AREA (CSOA DSECT)
CSPLCBUF DS    A        PTR TO COMMAND BUFFER
         SPACE
CSOA     DS    0H                  COMMAND SCAN OUTPUT AREA
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJCSOA)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE COMMAND SCAN OUTPUT AREA (CSOA) IS AN AREA POINTED TO        *
*    BY THE CSPL.  IT IS USED BY COMMAND SCAN TO INDICATE ITS         *
*    FINDINGS.  IT IS OBTAINED AND FREED BY THE INVOKER               *
***********************************************************************
         SPACE
CSOACNM  DS    A        PTR TO COMMAND NAME-IF 0 INVALID CMD NAME
CSOALNM  DS    H        LENGTH OF CMD NAME
CSOAFLG  DS    X        FLAGS
CSOAVWP  EQU   X'80'    VALID WITH PARAMETERS
CSOAVNP  EQU   X'40'    VALID NO   PARAMS
CSOAQM   EQU   X'20'    QUESTION MARK
CSOANOC  EQU   X'10'    NO COMMAND
CSOABAD  EQU   X'08'    BAD CMD NAME
CSOAEXEC EQU   X'04'    IMPLICIT EXEC COMMAND NAME
         DS    CL1      RESERVED
         SPACE
ZTCSFLG  DS    F                   COMMAND SCAN FLAG WORD
         SPACE 2
         EJECT
         SPACE 1
         LTORG
         EJECT
         IKJECT
         EJECT
         IKJPSCB
         EJECT
         IKJRLGB
         EJECT
         IKJEFLWA
         EJECT
         IKJTSVT
         EJECT
         IKJSTPB
         EJECT
         PRINT NOGEN
         IHASDWA
         IEZJSCB
         IKJTCB
         IHAASCB
         IHAASXB
         IHAPSA
         CVT   DSECT=YES
         END
