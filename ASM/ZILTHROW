         TITLE 'ZILTHROW - ZIL 1.3 THROW PROCESSOR'
***********************************************************************
*                                                                     *
* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *
*                     All rights reserved.                            *
*                                                                     *
***********************************************************************
*                                                                     *
* THIS ROUTINE PROCESSES THE "THROW" FUNCTION.                        *
*                                                                     *
* IT TAKES TWO ARGUMENTS IN REGISTERS AS FOLLOWS:                     *
*                                                                     *
* REGISTER 1 CONTAINS ARGUMENT 1, THE TAG.                            *
* REGISTER 2 CONTAINS ARGUMENT 2, THE RESULT.                         *
*                                                                     *
* THIS ROUTINE SEARCHES THROUGH THE ACTIVE CATCH FRAMES UNTIL IT      *
* FINDS ONE WHOSE TAG MATCHES ARGUMENT 1.  WHEN IT DOES, IT SCANS     *
* AGAIN THROUGH THE CHAIN OF CATCH FRAMES LOOKING FOR UNWIND-PROTECT  *
* FRAMES TO PROCESS; FOR EACH ONE IT FINDS, IT INVOKES THE CLEANUP    *
* FORMS, TEMPORARILY RESTORING THE ENVIRONMENT TO THE STATE IT WAS IN *
* AT THE LEXICAL TIME OF THE CLEANUP FORMS.  THIS SCAN TERMINATES     *
* AT THE CATCH FRAME FOUND ABOVE (TO WHICH WE ARE THROWING), AT WHICH *
* POINT RETURN TO THAT LEXICAL ENVIRONMENT IS EFFECTED.  IT RESTORES  *
* THE ENVIRONMENT FROM THE CATCH FRAME, PLACES THE RESULT ARGUMENT IN *
* REGISTER 15, AND RETURNS TO THE ADDRESS FROM THE CATCH FRAME WHERE  *
* THE CATCH FUNCTION EXPECTS THE VALUE TO BE RETURNED AND THE CATCH   *
* FRAME TO BE DEACTIVATED.                                            *
*                                                                     *
* IF NO CATCH FRAME IS FOUND, THEN IF THE TAG IS NIL THE PROGRAM IS   *
* ABNORMALLY TERMINATED, OTHERWISE THE "ZILERR" FUNCTION IS INVOKED   *
* TO DISPLAY AN ERROR MESSAGE AND ISSUE A THROW TO A TAG OF NIL.      *
*                                                                     *
* NO STACK SPACE IS REQUIRED, AND REGISTERS NEED NOT BE SAVED.        *
* REGISTER 15 IS USED AS THE BASE REGISTER AND REGISTER 14 IS         *
* IRRELEVANT SINCE CONTROL WILL NEVER BE RETURNED NORMALLY.           *
*                                                                     *
* THE STRUCTURE OF THE CATCH FRAME IS AS FOLLOWS (NOTE THAT THE       *
* COMPILER GENERATES THIS STRUCTURE, SO IT MAY NOT BE CHANGED):       *
*                                                                     *
* +0  ... ADDRESS OF THE PREVIOUS CATCH FRAME (X'00000000' IF NONE)   *
* +4  ... SAVED REGISTER 11 (STACK POINTER FROM INVOKER OF CATCH)     *
* +8  ... SAVED REGISTER 12 (BASE REGISTER FROM INVOKER OF CATCH)     *
* +12 ... RETURN ADDRESS (TO BRANCH TO END OF CATCH CODE)             *
* +16 ... SAVED SPECIAL ALIST (VARIABLE BINDING ENVIRONMENT)          *
* +20 ... SAVED FLUID ALIST (VARIABLE BINDING ENVIRONMENT)            *
* +24 ... THE CATCH/THROW TAG (X'00000000' FOR UNWIND-PROTECT FRAME)  *
*                                                                     *
* ...PLUS THE FOLLOWING, PRESENT ONLY IN UNWIND-PROTECT FRAMES:       *
*                                                                     *
* +28 ... ADDRESS OF THE CLEANUP FORMS CODE TO INVOKE                 *
*         (DURING UNWIND, THIS CONTAINS THE TAG BEING THROWN TO)      *
* +32 ... THE RETURN VALUE STORED FROM EVALUATING THE PROTECTED FORM  *
*         (DURING UNWIND, THIS CONTAINS THE RETURN VALUE FROM THROW)  *
*                                                                     *
* DURING PROCESSING OF UNWIND-PROTECT CLEANUP FORMS, THE ACTIVE       *
* CATCH FRAME IS THE ONE ESTABLISHED PREVIOUSLY TO THE UNWIND-PROTECT *
* FRAME; THE CODE TO DEACTIVATE THE UNWIND-PROTECT FRAME AND TO       *
* MAKE THE PREVIOUS FRAME THE CURRENT CATCH FRAME IS AT THE BEGINNING *
* OF THE CLEANUP FORMS CODE GENERATED BY THE COMPILER.                *
* UPON RETURN FROM THE CLEANUP FORMS, REGISTER 14 POINTS TO THE FRAME *
* (WHICH HAS NOT BEEN LEXICALLY POPPED FROM THE STACK, DESPITE BEING  *
* UNHOOKED FROM THE ACTIVE CHAIN).                                    *
*                                                                     *
* IF THROWING TO TAG NIL, WHICH MEANS THAT AN ERROR IS                *
* BEING SIGNALLED, IT DOES A BACK TRACE OF THE STACK IF DEBUG MODE    *
* IS ACTIVE.                                                          *
*                                                                     *
***********************************************************************
         GBLB  &ZILXA
         #ZSYS
         EJECT
ZILTHROW #ZBEG NAME='ZILTHROW'
         SPACE 1
*
* FIRST OF ALL, RESET THE PROGRAM MASK IN CASE SOME FORTRAN ROUTINE
* SCREWED AROUND WITH IT
*
         SPACE 1
         ICM   #14,8,ZLCPMASK      GET INITIAL PROGRAM MASK
         SPM   #14                 SET PROGRAM MASK BACK TO NORMAL
*
* TURN OFF MISCELLANEOUS ZIL BITS THAT MAY HAVE BEEN LEFT ON SO WE
* DON'T END UP IN A WEIRD STATE
*
         NI    ZLCGCFLG,255-ZLCGCBLD  TURN OFF SPECIAL-GC-CALLER FLAG
         NI    ZLCPFLGS,255-ZLCPRINT  TURN OFF ZILPRIN-IN-PROCESS FLAG
         NI    ZLCDFLGS,255-ZLCDCOPY  TURN OFF ZILADMP COPY FLAG
         NI    ZLCERFLG,255-ZLCERTRC  TURN OFF STACK TRACE FLAG
         NI    ZLCERFLG,255-ZLCERCFA  TURN OFF CONDITIONAL FILE ACCESS
         SPACE 1
         L     #14,ZLCCATCH        GET POINTER TO CURRENT CATCH FRAME
LOOP     DS    0H
         LTR   #14,#14             IF NO MORE CATCH FRAMES ARE ACTIVE
         BZ    NOCATCH             THEN PROCESS THROW ERROR
         USING CATCH,#14
         C     #1,CATCHTAG         IF TAG MATCHES
         BE    GOTCATCH            THEN WE FOUND THE CATCH TO PROCESS
         L     #14,CATCHLNK        ELSE GET PREVIOUS CATCH FRAME
         B     LOOP                AND CONTINUE.
         SPACE 1
GOTCATCH DS    0H                  WE HAVE THE CATCH FRAME...
         SPACE 1
         ST    #12,SAVE12          Save base reg on entry
         LR    #12,#15             GET A BETTER BASE REGISTER
         DROP  #15
         USING ZILTHROW,#12
         SPACE 1
***********************************************************************
*                                                                     *
* OK, TRY BACK TRACE BEFORE THROWING TO SIGNAL ERROR.                 *
*                                                                     *
* Remember that the only registers that can be maintained across      *
* a call to PRINT/TERPRI are #5.                                      *
*                                                                     *
* #4 must point to the object to be printed                           *
* #7 must point to the file block for standard output                 *
*                                                                     *
***********************************************************************
         SPACE 1
         CR    #1,#10              If throw tag is not NIL
         BNE   NOTRACE             then skip trace
         SPACE 1
         TM    ZLCERFLG,ZLCERDBG   If debug mode is not active
         BZ    NOTRACE             then skip trace
         SPACE 1
         TM    ZLCERFLG,ZLCERTRC   If already doing a back trace
         BO    NOTRACE             then skip trace
         SPACE 1
         OI    ZLCERFLG,ZLCERTRC   Indicate stack tracing active
         STM   #0,#2,SAVEARGS      Save args to THROW
         L     #7,ZLCSTDOU         GET STANDARD OUTPUT FILE POINTER
         USING ZLFILBLK,#7
         NI    ZLCPFLGS,255-ZLCPSLSH REQUEST NO SLASHIFICATION BE DONE
         LA    #4,TRCMSG1
         L     #15,ZLCPRIN         Call ZILPRIN to print message
         #BASR #14,#15
         L     #15,ZLCTERP         Call ZILTERP to TERPRI
         #BASR #14,#15
         SPACE 1
***********************************************************************
*                                                                     *
* Try to find the current stack pointer.                              *
*                                                                     *
***********************************************************************
         SPACE 1
         L     #0,SAVEARGS+0       Get reg 0 at entry to ZILTHROW
         TM    ZLCGCFLG,ZLCGCBLD   If it was set for CONS/GC
         BO    REG0OK              then we can assume that it is OK
         L     #1,SAVE12           Else get base reg of who called us
         CLC   0(3,#1),=X'47F0F0'  Check for valid ZIL code
         BNE   GIVEUP              If wrong code, assume default stack
         XR    #2,#2
         IC    #2,3(,#1)           Get B2D2 of initial branch instr.
         AR    #1,#2               Point to next executable instr.
         CLC   0(2,#1),=X'4100'    Check valid (expected) ZIL code
         BNE   MAYBLEX             If not what is expected, maybe LEXPR
         LH    #2,2(,#1)           Get B2D2 of stack size LA instr.
         SLA   #2,20               Shift out base reg and
         SRA   #2,20                isolate the maximum stack size
         AR    #2,#11              Add stack ptr to get max stack addr
         CR    #0,#11              If reg 0 less than current stack ptr
         BL    BADREG0             then can't use it
         CR    #0,#2               If reg 0 greater than max stack ptr
         BH    BADREG0             then can't use it
         B     REG0OK              Otherwise use reg 0 as top of stack
MAYBLEX  DS    0H                  Maybe it's a lexpr...
         CLC   0(L'LCODE,#1),LCODE See if it's compiled lexpr prologue
         BNE   GIVEUP              If not, can't verify #0, wrong code
         LH    #2,L'LCODE(,#1)     Get B2D2 of stack size LA instr.
         SLA   #2,20               Shift out base reg and
         SRA   #2,20                isolate the maximum stack size
         SH    #2,=H'4'            Adjust it
         AR    #2,#11              Add stack ptr to get max stack addr
         CR    #0,#11              If reg 0 less than current stack ptr
         BL    BADREG0             then can't use it
         CR    #0,#2               If reg 0 greater than max stack ptr
******** BH    BADREG0             then can't use it
         BNH   REG0OK              Otherwise use reg 0 as top of stack
BADREG0  DS    0H
         LR    #5,#2               Continue, using max stack addr
         B     STKLOOP
REG0OK   DS    0H
         LR    #5,#0               Put into a useable register
         B     STKLOOP
         SPACE 1
LCODE1   DS    0A
         SPACE 1
***********************************************************************
*                                                                     *
*  The code that follows is used to compare with LEXPR header code.   *
*  See ZCGBEGIN.  If this code is changed in ZCGBEGIN it must also    *
*  be changed here.                                                   *
*                                                                     *
***********************************************************************
         SPACE 1
         L     #2,0(,#1)           Get pointer to LEXPR arg on stack
         L     #2,##CDR(,#2)       Get fixnum value thereof
         SLA   #2,2                Multiply it by 4 to get stack length
         LA    #0,*-*(#2,#1)       Half of the expected LA instruction
         ORG   *-2                 Throw away the other half
LCODE    EQU   LCODE1,*-LCODE1     Length of this code
         SPACE 1
GIVEUP   DS    0H                  Can't determine stack pointer?
         SPACE 1
         LA    #5,4(,#11)          Get last stack pointer
         SPACE 1
STKLOOP  DS    0H                  #5 should be top-of-stack pointer
         C     #5,ZLCPDADR         Loop until we hit bottom
         BL    STKEND
         ICM   #4,15,0(#5)         Get pointer off stack
         BNP   STKSKIP             If negative, probably ret addr, skip
         C     #4,ZLCPDADR         If it points into the stack, skip it
         BL    NOTINSTK
         CR    #4,#8
         BL    STKBOUND
NOTINSTK DS    0H
         CR    #4,#13              If unsupplied optional argument
         BE    NOTCODE              or
         C     #4,ZLCUNBND           the unbound marker
         BE    NOTCODE                or
         C     #4,ZLCRMNIL             the RMNIL object
         BE    NOTCODE                  then it ought to be printed
         TM    0(#4),X'80'         If this looks like a cons
         BO    NOTCODE             then it may be suspicious
         CLC   0(3,#4),=X'47F0F0'  If CAR looks like code
         BE    CODE                then this must be code
         AIF   (&ZILXA).XACARCK
         CLI   0(#4),0             370: If CAR is not a 24-bit pointer
         BNE   STKSKIP             then skip
         AGO   .NCARCK
.XACARCK ANOP
         C     #10,0(,#4)          XA: If higher than any possible CAR
         BL    STKSKIP             then skip
.NCARCK  ANOP
         CLC   0(4,#4),=F'0'       if CAR looks like zeroes
         BE    STKSKIP             then skip
         B     NOTCODE             Else print out as LISP object
CODE     DS    0H
         TM    4(#4),X'80'         If invalid module identifier
         BNO   CODENAME             then...
         LA    #4,NNCODE            point to unnamed-code-string
         NI    ZLCPFLGS,255-ZLCPSLSH REQUEST NO SLASHIFICATION BE DONE
         B     STKPRIN              and go print it.
CODENAME DS    0H                  Else...
         XR    #15,#15
         IC    #15,4(,#4)          Get length of module identifier
         LTR   #15,#15             Reduce by length of date/time info
         BNP   STKSKIP             If no name, skip
         CH    #15,=Y(L'FUNTEXT)   If longer than maximum length we use
         BNH   *+8                 then
         LA    #15,L'FUNTEXT        use maximum length
         STCM  #15,7,FUNLEN        Store length into fake string
         BCTR  #15,0               Reduce for execute
         EX    #15,MVCNAME         Move function name to our message
         LA    #4,FUNSTR           Point to our fake string message
         NI    ZLCPFLGS,255-ZLCPSLSH REQUEST NO SLASHIFICATION BE DONE
         B     STKPRIN
STKBOUND DS    0H                  Pointer back into stack found...
         LA    #4,BOUNDSTR         Point to boundary string
         NI    ZLCPFLGS,255-ZLCPSLSH REQUEST NO SLASHIFICATION BE DONE
         B     STKPRIN
NOTCODE  DS    0H
         OI    ZLCPFLGS,ZLCPSLSH   REQUEST SLASHIFICATION BE DONE
STKPRIN  DS    0H
         L     #15,ZLCPRIN         Call ZILPRIN to print the object
         #BASR #14,#15
         L     #15,ZLCTERP         Call ZILTERP to TERPRI
         #BASR #14,#15
STKSKIP  DS    0H
         SH    #5,=H'4'            Bump down stack
         B     STKLOOP             Continue
         SPACE 1
STKEND   DS    0H
         SPACE 1
         NI    ZLCPFLGS,255-ZLCPSLSH REQUEST NO SLASHIFICATION BE DONE
         LA    #4,TRCMSG2
         L     #15,ZLCPRIN         Call ZILPRIN to print message
         #BASR #14,#15
         L     #15,ZLCTERP         Call ZILTERP to TERPRI
         #BASR #14,#15
         LM    #0,#2,SAVEARGS      Restore args to THROW
         NI    ZLCERFLG,255-ZLCERTRC No more stack tracing
         SPACE 1
NOTRACE  DS    0H                  End tracing
         SPACE 1
         LR    #15,#12             BACK TO THE OLD BASE REGISTER
         DROP  #12
         USING ZILTHROW,#15
*
* NOW THAT WE KNOW WE HAVE A CATCH TO THROW TO, SCAN FOR UNWIND-PROTECT
* FRAMES TO PROCESS CLEANUP FORMS.
*
* TO DO THIS, WE HAVE TO SCAN THE CHAIN OF CATCH FRAMES AGAIN (THE
* FIRST SCAN WAS JUST TO MAKE SURE WE HAD A VALID TAG).  THIS IS OK
* BECAUSE GUY STEELE, IN CLTL, SAID WE'D PROBABLY HAVE TO DO THIS IN
* A VALID IMPLEMENTATION.
*
         L     #14,ZLCCATCH        START FROM THE BEGINNING AGAIN
LOOP2    DS    0H
         LTR   #14,#14             (THIS CAN'T HAPPEN)
         BZ    CANTBE
         ICM   #0,15,CATCHTAG      LOAD THE TAG
         BZ    DOCLEAN             IF ZEROES, IT'S AN UNWIND-PROTECT
         CR    #0,#1               IF THIS IS THE MATCHING TAG
         BE    DOTHROW             THEN REALLY DO THE THROW NOW
         L     #14,CATCHLNK        ELSE GET PREVIOUS CATCH FRAME
         B     LOOP2               AND CONTINUE SCAN.
         SPACE 1
DOCLEAN  DS    0H                  EXECUTE UNWIND-PROTECT CLEANUP FORMS
         SPACE 1
         LA    #0,CLEANRET         SET WHERE TO RETURN AFTER CLEANUP
         ST    #0,CATCHRET         IN RETURN ADDRESS SLOT OF FRAME
         L     #0,CATCHSAL         GET SAVED SPECIAL ALIST
         ST    #0,ZLCSALST         SET CURRENT SPECIAL ALIST THERETO
         L     #0,CATCHFAL         GET SAVED FLUID ALIST
         ST    #0,ZLCFALST         SET CURRENT FLUID ALIST THERETO
         LM    #11,#12,CATCHS11    RESTORE STACK AND BASE REGS #11,#12
         ST    #15,CATCHS12        SAVE OUR OWN BASE REG IN FRAME
         DROP  #15                 (THIS INVALIDATES OUR BASE REG)
         L     #15,CATCHCLN        GET ADDRESS OF CLEANUP FORMS CODE
         STM   #1,#2,CATCHCLN      SAVE THROW'S ARGS IN FRAME
         BR    #15                 BRANCH TO CLEANUP FORMS CODE
         SPACE 1
CLEANRET DS    0H                  RETURN HERE AFTER CLEANUP FORMS DONE
*                                  (NOTE: #14 POINTS TO THE UWP FRAME)
         L     #15,CATCHS12        RESTORE OUR OWN BASE REGISTER
         USING ZILTHROW,#15        (LETS US HAVE A BASE AGAIN)
         LM    #1,#2,CATCHCLN      RESTORE THROW'S ARGS
         L     #14,ZLCCATCH        LOAD WHAT IS NOW CURRENT CATCH FRAME
         B     LOOP2               CONTINUE SCAN THROUGH FRAMES
         SPACE 1
DOTHROW  DS    0H                  NOW ACTUALLY THROW TO THE CATCH
*
* TURN OFF REQUEST TO ABEND, BUT LEAVE THE USER CODE SO THAT FUTURE
* FUNCTIONS MAY BE ABLE TO INTERROGATE IT.
*
         NI    ZLCERFLG,255-ZLCERSET  INDICATE NO ABEND TO BE DONE
*
* RESTORE THE ALISTS AND REGS 11 AND 12, AND
* GO TO RETURN ADDRESS WITH RESULT VALUE IN REG 15
*
         L     #0,CATCHSAL         GET SAVED SPECIAL ALIST
         ST    #0,ZLCSALST         RESTORE SPECIAL ALIST
         L     #0,CATCHFAL         GET SAVED FLUID ALIST
         ST    #0,ZLCFALST         RESTORE FLUID ALIST
         LM    #11,#12,CATCHS11    RESTORE STACK AND BASE REGISTERS
         L     #14,CATCHRET        GET RETURN ADDRESS (END OF CATCH)
         DROP  #14
         LR    #15,#2              SET RESULT VALUE
         BR    #14                 GO TO RETURN POINT
         SPACE 1
NOCATCH  DS    0H                  NO CATCH FRAME FOUND...
         CR    #1,#10              IF THROW TAG IS NIL,
         BE    DISASTER            THEN THERE'S NO HOPE FOR RECOVERY.
         LR    #3,#15
         DROP  #15
         USING ZILTHROW,#3
         LR    #2,#1
         #ERR  'ZIL1011 THROW: No catch active for tag - ',(#2),       X
               PREFIX=NO
         DROP  #3
         SPACE 1
DISASTER DS    0H                  THROW TO NIL, NO CATCH ACTIVE
         SPACE 1
         USING ZILTHROW,#15
*
* CANCEL ESTAE AND/OR STAX ENVIRONMENTS IF ANY.
*
         TM    ZLCEFLGS,ZLCESTAE   IF AN ESTAE WAS ACTIVE
         BZ    NOESTAE             THEN
         ESTAE 0                    CANCEL ABEND HANDLER
NOESTAE  DS    0H
         DROP  #15
         #BASR #15,0
         USING *,#15
         TM    ZLCERFLG,ZLCERSET   IF A USER ABEND CODE WAS SET
         BZ    ABEND000            THEN
         LH    #1,ZLCABEND          GET USER ABEND CODE SET BY ZILERR
         LTR   #1,#1                BUT MUST BE BETWEEN 1 AND 4095
         BNP   ABEND000
         CH    #1,=H'4095'
         BNH   ABEND                OTHERWISE
ABEND000 XR    #1,#1                SET USER ABEND CODE = 0
ABEND    DS    0H
         ABEND (1),DUMP            ABEND WITH RESULT AS USER CODE
         SPACE 1
CANTBE   DS    0H
         EX    0,*                 FORCE 0C3 ABEND IF ERROR SCANNING
         SPACE 1
         DROP  #15
         USING ZILTHROW,#12
MVCNAME  MVC   FUNTEXT(*-*),5(#4)  Executed: Move function name to msg
         SPACE 1
SAVEARGS DS    3A
SAVE12   DS    A
FUNSTR   DC    YL1(##STRING)
FUNLEN   DC    AL3(0)
FUNTEXT  DS    CL64
NNCODE   DC    YL1(##STRING)
         DC    AL3(L'NNTEXT)
NNTEXT   DC    C'#<NAMELESS ZIL CODE>'
BOUNDSTR DC    YL1(##STRING)
         DC    AL3(L'BOUNDTXT)
BOUNDTXT DC    C';-------<STACK BOUNDARY>-------'
TRCMSG1  #SATM 'ZIL1600 BACK TRACE OF PUSH DOWN STACK FOLLOWS.'
TRCMSG2  #SATM 'ZIL1601 END OF STACK TRACE.'
         SPACE 1
         LTORG
         EJECT
CATCH    DSECT ,                   THIS MAPS THE CATCH FRAME
         SPACE 1
CATCHLNK DS    A                   +00 ADDRESS OF PREVIOUS CATCH FRAME
CATCHS11 DS    A                   +04 ADDRESS OF STACK (SAVED #11)
CATCHS12 DS    A                   +08 BASE REGISTER (SAVED #12)
CATCHRET DS    A                   +0C RETURN ADDRESS AFTER FORMS
CATCHSAL DS    A                   +10 ADDRESS OF SAVED SPECIAL ALIST
CATCHFAL DS    A                   +14 ADDRESS OF SAVED FLUID ALIST
CATCHTAG DS    A                   +18 THE CATCH TAG (0 FOR UWP)
CATCHCLN DS    A                   +1C ADDRESS OF CLEANUP FORMS CODE
CATCHVAL DS    A                   +20 RETURN VALUE SAVED DURING CLNUP
         SPACE 2
         END
