         PUNCH ' ALIAS ZILFGETI,ZILFGETO'
         TITLE 'ZILFGET - ZIL 1.3 FILE LOCATOR MODULE'
***********************************************************************
*                                                                     *
* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *
*                     All rights reserved.                            *
*                                                                     *
***********************************************************************
*                                                                     *
* THIS MODULE IS INVOKED VIA BALR FROM ASSEMBLER-LANGUAGE FUNCTIONS   *
* WHICH REQUIRE THE USE OF FILES.  TWO ENTRY POINTS EXIST:            *
*                                                                     *
*  ZILFGETI - LOCATES A FILE BLOCK ON THE CHAIN OF INPUT FILE BLOCKS. *
*  ZILFGETO - LOCATES A FILE BLOCK ON THE CHAIN OF OUTPUT FILE BLOCKS.*
*                                                                     *
* THIS MODULE USES NO STACK SPACE,  SINCE IT'S NOT RECURSIVE.         *
*                                                                     *
* ON ENTRY REG 1 CONTAINS THE PASSED (ATOMIC) ARGUMENT SPECIFYING THE *
* FILE TO BE ACCESSED, AND REG 7 IS SET ON RETURN TO POINT TO THE     *
* APPROPRIATE FILE BLOCK.                                             *
*                                                                     *
***********************************************************************
         GBLB  &ZILXA
         #ZSYS
         EJECT
ZILFGET  CSECT
         ENTRY ZILFGETI
         ENTRY ZILFGETO
         USING ZLCOMMON,#13
ZILFGETI DS    0H
         L     #2,ZLCIFBAD         USE INPUT FILE BLOCK CHAIN
         L     #7,ZLCSTDIN         SET STANDARD INPUT IN CASE OF NIL
         LA    #3,INPUT            SET TYPE = INPUT
         B     START-ZILFGETI(,#15)
ZILFGETO DS    0H
         L     #2,ZLCOFBAD         USE OUTPUT FILE BLOCK CHAIN
         L     #7,ZLCSTDOU         SET STANDARD OUTPUT IN CASE OF NIL
         LA    #3,OUTPUT           SET TYPE = OUTPUT
         B     START-ZILFGETO(,#15)
         EJECT
ZILFGET  #ZBEG NAME='ZILFGET'
         SPACE 1
START    #BASR #15,0               SET BASE REGISTER
         USING *,#15
USING15  EQU   *
         CR    #1,#10              IF FILE SPEC IS NIL
         BER   #14                 THEN RETURN WITH STANDARD FILE
         CR    #1,#13              IF FILE SPEC IS UNSUPPLIED OPTIONAL
         BER   #14                 THEN RETURN WITH STANDARD FILE
NOTNIL   DS    0H                  ELSE NON-NIL FILE SPECIFIED
         CLI   ##TYPE(#1),##SYMBOL IF NOT A SYMBOL
         BNE   INVALID             THEN ERROR - INVALID ARGUMENT
         LTR   #7,#2               ELSE TRY FIRST FILE IN CHAIN
         USING ZLFILBLK,#7
FILLOOP  DS    0H
         BZ    ERROR1              IF NO MORE FILES IN CHAIN, ERROR
         C     #1,ZLFATOM          IF FILE NAMES MATCH
         BE    FOUNDIT             THEN RETURN WITH FILE BLOCK POINTER
         LR    #2,#7               SAVE ADDRESS OF PREVIOUS FILE BLOCK
         ICM   #7,15,ZLFCHAIN      ELSE GET NEXT FILE BLOCK
         BNZ   FILLOOP             AND CONTINUE
         B     ERROR1              IF NO MORE, THEN FILE NOT FOUND
         SPACE 1
FOUNDIT  DS    0H                  FOUND FILE BLOCK (FOR NON-NIL ONLY)
         TM    ZLFFLAG1,ZLFTERM    SEE IF THIS IS A TERMINAL FILE
         BO    GETTERM             IF SO, DON'T CHECK DCB
         TM    ZLFDCB+48,X'10'     IF FILE IS OPEN
         BOR   #14                 THEN OK
         B     UNUSABLE            ELSE FILE IS UNUSABLE.
         SPACE
GETTERM  DS    0H                  FILE IS A TERMINAL FILE
         L     #7,ZLFTFPTR         GET POINTER TO TRUE FILE BLOCK
         BR    #14                 AND RETURN WITH IT.
         SPACE 1
         DROP  #15
         SPACE 1
INVALID  DS    0H                  File arg is invalid
         SPACE 1
         LR    #4,#15
         USING USING15,#4
         LR    #6,#1               Save file argument
         STC   #3,TYPE             Set file type
         LR    #1,#12              Get pointer to calling function
         #BAS  #14,GETCALR         Get name of calling function
         #ERR  PREFIX=NO,          FILE NAME INVALID                   X
               'ZIL0009 ',CALLER,': ',TYPESTR,                         X
               ' file name not a 1-4 character symbol - ',(#6)
         SPACE 1
UNUSABLE DS    0H                  FILE IS PRESENT BUT NOT OPEN
         SPACE 1
         LR    #4,#15
         USING USING15,#4
         LR    #6,#1               Save file argument
         STC   #3,TYPE             Set file type
         LR    #1,#12              Get pointer to calling function
         #BAS  #14,GETCALR         Get name of calling function
         #ERR  PREFIX=NO,          FILE NAME INVALID                   X
               'ZIL0031 ',CALLER,': ',TYPESTR,                         X
               ' file ',(#6),                                          X
               ' is not usable.  Try closing it first.'
         SPACE 1
ERROR1   DS    0H                  FILE NOT FOUND
         SPACE 1
         DROP  #4
         USING USING15,#15
         SPACE 1
* VALIDATE FILE NAME
         ST    #1,FILEATOM         SAVE FILE ATOM
         L     #1,##PNAME(,#1)     GET POINTER TO SYMBOL PRINT NAME
         XR    #4,#4               CLEAR INSERT REGISTER
         ICM   #4,7,1(#1)          GET LENGTH OF PRINT NAME
         BZ    INVALID             IF ZERO, ERROR - BAD FILE NAME
         CH    #4,=H'4'            MUST BE 1-4 IN LENGTH
         BH    INVALID             ELSE ERROR - BAD FILE NAME
         MVC   FNAME,=CL4' '       PRESET BLANKS
         BCTR  #4,0                REDUCE LENGTH FOR EXECUTE
         EX    #4,MVCFNAME         MOVE FILE NAME TO FNAME
         B     AROUNDEX            BRANCH AROUND EXECUTED INSTR
         SPACE
MVCFNAME MVC   FNAME(*-*),##VECDAT(#1)   MOVE PRINT NAME TO FILE NAME
         SPACE
AROUNDEX DS    0H
         SPACE
***********************************************************************
*
* IF A FILE NAME IS NOT FOUND, WE SEARCH THE TIOT TO SEE IF IT IS
* CURRENTLY ALLOCATED.  IF SO, WE BUILD A FILE BLOCK FOR IT AND
* ATTEMPT TO OPEN IT (FOR INPUT OR OUTPUT, DEPENDING ON THE REQUEST
* TYPE).  IF WE ARE SUCCESSFUL, WE RETURN WITH THE ADDRESS OF THE
* NEWLY OPENED FILE BLOCK.  IF WE FAIL, AN ERROR IS SIGNALLED.
*
***********************************************************************
         SPACE
         STM   #14,#12,ZLCSAVE2    SAVE REGISTERS
         LR    #1,#12              Save caller's register 12
         #BASR #12,0
USING12  EQU   *
         DROP  #15
         USING USING12,#12
         SPACE 1
         STC   #3,TYPE             STORE TYPE (INPUT OR OUTPUT)
         LR    #6,#2               Save file block pointer
********                           #1 = caller's #12
         #BAS  #14,GETCALR         Get calling function name
         MVC   DDNAME(3),=C'ZIL'   SET UP DDNAME
         STC   #3,DDNAME+3         MAKE ZILI... OR ZILO...
         MVC   DDNAME+4(4),FNAME   LAST 4 CHARS = FILE NAME
         LA    #4,DDNAME+7         Loop searching for last nonblank
         LA    #0,8
DDSLOOP  DS    0H
         CLI   0(#4),C' '
         BNE   DDSEND
         BCTR  #4,0
         BCT   #0,DDSLOOP
DDSEND   DS    0H
         STCM  #0,7,DDLEN          Set length of DDNAME in fake string
*
* NOW LOCATE A USER SPECIFIED FILE ALLOCATION, CREATE A FILE BLOCK
* FOR IT AND OPEN IT.
* SEARCH THE TASK INPUT/OUTPUT TABLE (TIOT) FOR A FILE ALLOCATION OF
* THE DDNAME ZILI____ (FOR INPUT FILES) AND ZILO____ (FOR OUTPUT FILES)
*
         XR    #4,#4               CLEAR INSERT REGISTER
         L     #3,540              TCB ADDRESS
         L     #3,12(,#3)          TIOT ADDRESS
         LA    #3,24(,#3)          POINT TO FIRST TIOT ENTRY
TIOTLOOP DS    0H
         TM    1(#3),X'80'         IF THIS ENTRY IS NOT IN USE
         BO    TIOTNEXT            THEN SKIP IT
         CLC   4(8,#3),DDNAME      IF THIS IS OUR FILE
         BE    TIOTFILE            THEN PROCESS IT
TIOTNEXT IC    #4,0(,#3)           ELSE GET LENGTH OF THIS ENTRY
         ALR   #3,#4               BUMP TO NEXT ENTRY
         CLI   0(#3),0             IF NOT END OF TIOT YET
         BNE   TIOTLOOP            THEN CONTINUE LOOPING THRU TIOT
NOTFOUND DS    0H                  ELSE END OF TIOT - FILE NOT FOUND
         XR    #3,#3               INDICATE NO TIOT ENTRY FOR FILE
         C     #8,FILEATOM         IF REQUESTED FILE IS NOT T
         BNE   TIOTEND             THEN ERROR - FILE DOES NOT EXIST
*                                  ELSE FILE IS T - ASSUME TERMINAL
         CLI   DDNAME+3,C'I'       IF THIS IS SUPPOSED TO BE INPUT FILE
         BNE   FNDTRMOU            THEN...
         ICM   #7,15,ZLCIFTRM       GET @ OF INPUT TERMINAL FILE BLOCK
         BNZ   TIOTEND              IF THERE IS ONE, THEN USE IT
         B     TIOTFILE             IF THERE ISN'T ONE, BUILD ONE NOW
FNDTRMOU DS    0H                  ELSE...
         ICM   #7,15,ZLCOFTRM       GET @ OF OUTPUT TERMINAL FILE BLOCK
         BNZ   TIOTEND              IF THERE IS ONE, THEN USE IT
*
* Experimental addition 08/27/87.  If this is file T, and DDname ZILOT
* isn't allocated, and there's no terminal file block, and this is a
* batch environment (no wonder there's no terminal file block!), then
* let file T be identical to file NIL (standard output).
*
         L     #15,X'224'          ASCB address
         ICM   #15,15,X'3C'(#15)   TSB address
         BNZ   TIOTFILE            If exists, TSO env., use terminal
         L     #7,ZLCSTDOU         Get @ of standard output file block
         B     TIOTEND             and use that.
         SPACE 1
TIOTFILE DS    0H                  WE FOUND OUR FILE TO PROCESS
         LH    #0,ZLCFBLEN         GET LENGTH OF A FILE BLOCK
         #GETMAIN RC,LV=(0),LOC=BELOW GET STORAGE FOR A FILE BLOCK
         LTR   #15,#15             IF GETMAIN FAILED,
         BNZ   FBERROR             THEN ERROR
         LR    #7,#1               POINT TO FILE BLOCK
         LH    #1,ZLCFBLEN         GET LENGTH OF A FILE BLOCK
         BCTR  #1,0
         EX    #1,CLRFB            CLEAR FILE BLOCK TO ZEROES
         MVC   ZLFPDDN(8),DDNAME   SET UP DDNAME
         MVC   ZLFATOM(4),FILEATOM SET UP FILE ATOM FOR ZIL TO USE
         LTR   #3,#3               IF FILE NOT IN TIOT (MEANS TERMINAL)
         BZ    ISTERM               OR
         TM    3(#3),X'20'           IF TIOT ENTRY SAYS IT'S A TERMINAL
         BZ    NOTTERM                THEN
ISTERM   OI    ZLFFLAG,ZLFTERM         INDICATE SO IN FILE BLOCK
NOTTERM  DS    0H
* FOUND THE FILE - NOW CHAIN IT ONTO THE FILE BLOCK
         LTR   #2,#6               IF NO FILE BLOCK CHAIN EXISTED,
         BNZ   CHAINIT             THEN...
NOCURFIL DS    0H                  START A NEW CHAIN
         CLI   TYPE,INPUT          IF TYPE IS INPUT
         BNE   CHNOTIN             THEN...
         ST    #7,ZLCIFBAD          MAKE NEW INPUT FILE BLOCK CHAIN
         L     #2,ZLCSTDIN          CHAIN THIS TO STANDARD INPUT
         B     CHAINIT             ELSE...
CHNOTIN  ST    #7,ZLCOFBAD          MAKE NEW OUTPUT FILE BLOCK CHAIN
         L     #2,ZLCSTDOU          CHAIN THIS TO STANDARD OUTPUT
CHAINIT  DS    0H
         ST    #7,ZLFCHAIN-ZLFILBLK(,#2)  CHAIN THIS TO PREV FILE BLOCK
CHAINED  DS    0H
         CLI   TYPE,INPUT          IF TYPE IS INPUT
         BNE   NOTINPUT            THEN...
         OI    ZLFFLAG,ZLFINPUT    FLAG AS AN INPUT FILE
         XR    #1,#1               SET CHARACTER POSITION = -1
         BCTR  #1,0                 (NEGATIVE SO FIRST READ(CH)
         ST    #1,ZLFCHAR            WILL FORCE READ OF FIRST RECORD)
         TM    ZLFFLAG,ZLFTERM     IF THIS IS NOT A TERMINAL FILE
         BO    FITERM              THEN...
         MVC   ZLFDCB(96),INDDDCB   SET UP DCB
         MVI   OPENL,X'80'          SET TO OPEN FOR INPUT
         B     OPENIT               GO TO OPEN THE FILE
         SPACE 1
CLRFB    XC    ZLFILBLK(*-*),ZLFILBLK  EXECUTED: CLEAR BLOCK TO ZEROES
         SPACE 1
FITERM   DS    0H                  ELSE (TERMINAL FILE)...
         ICM   #1,15,ZLCIFTRM       GET @ OF INPUT TERMINAL FILE BLOCK
         BNZ   GOTIFTRM             IF NONE YET, THEN...
         ST    #7,ZLCIFTRM           THIS IS THE FIRST. SET IT NOW
         LR    #1,#7                 FOR FUTURE TERMINAL FILES
GOTIFTRM DS    0H                  ANYHOW...
         ST    #1,ZLFTFPTR          SET INDIRECT POINTER TO TRUE FILBLK
         OI    ZLFFLAG2,ZLFTABS     SET TABS MODE ON BY DEFAULT
         LA    #0,80                SET RECORD LENGTH TO 80
         STH   #0,ZLFLRECL          SET LINE LENGTH
         LA    #1,ZLFLINE
         ST    #1,ZLFCARD           SET POINTER TO RECORD AREA
         ALR   #1,#0                AREA + LENGTH = END
         ST    #1,ZLFEND            SET END-OF-RECORD ADDRESS
         B     FILOPEND             CONSIDER THE FILE OPEN
NOTINPUT DS    0H                  ELSE THIS IS AN OUTPUT FILE...
         LA    #1,1
         ST    #1,ZLFCHAR          CHARACTER POSITION = 1
         TM    ZLFFLAG,ZLFTERM     IF THIS IS NOT A TERMINAL FILE
         BO    FOTERM              THEN...
         MVC   ZLFDCB(96),OUTDDDCB  SET UP DCB
         MVI   OPENL,X'8F'          SET TO OPEN FOR OUTPUT
         B     OPENIT               GO TO OPEN THE FILE
FOTERM   DS    0H                  ELSE (TERMINAL FILE)...
         ICM   #1,15,ZLCOFTRM       GET @ OF OUTPUT TERMINAL FILE BLOCK
         BNZ   GOTOFTRM             IF NONE YET, THEN...
         ST    #7,ZLCOFTRM           THIS IS THE FIRST. SET IT NOW
         LR    #1,#7                 FOR FUTURE TERMINAL FILES
GOTOFTRM DS    0H                  ANYHOW...
         ST    #1,ZLFTFPTR          SET INDIRECT POINTER TO TRUE FILBLK
         LA    #0,78                SET RECORD LENGTH TO 78
         LA    #1,ZLFLINE           (NO PRINT CONTROL CHARACTER)
         B     NOTRECFA             GO TO SET UP FILE PARAMETERS
OPENIT   DS    0H
         MVC   ZLFDCB+40(8),ZLFPDDN SET DDNAME IN DCB
         SPACE 1
         LA    #0,STARETRY         SET ADDRESS OF RETRY ROUTINE
         ST    #0,STAERTRY
         XC    STAECOMP,STAECOMP   CLEAR COMPLETION CODE
         STM   #7,#13,STAEREGS     SAVE REGISTERS FOR ESTAE RETRY
         ESTAE STAEEXIT,PARAM=STAEPARM ESTABLISH ESTAE EXIT
         LTR   #15,#15             IF ESTAE FAILED
         BNZ   ESTAEERR            THEN ERROR
         OI    STAEOK,X'FF'        ELSE SET ESTAE-SET FLAG ON
ESTAEERR DS    0H
         SPACE 1
         AIF   (NOT &ZILXA).SKIP1
*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24
         LA    #1,OPEN24           ADDRESS OF THIS CODE
         LA    #2,OPEN24E          RETURN ADDRESS
         BSM   #2,#1
OPEN24   DS    0H
*---------------------------------THE AMODE IS NOW 24
.SKIP1   ANOP
         SPACE 1
         LA    #1,ZLFDCB           POINT TO DCB
         STCM  #1,7,OPENL+1        SET UP OPEN LIST FORM
         OPEN  MF=(E,OPENL)        OPEN THE INPUT OR OUTPUT FILE
         SPACE 1
         AIF   (NOT &ZILXA).SKIP2
*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE
         BSM   0,#2
OPEN24E  DS    0H
*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY
.SKIP2   ANOP
         SPACE 1
         TM    STAEOK,X'FF'        IF ESTAE WAS SUCCESSFULLY SET
         BNO   NOESTOFF            THEN
         ESTAE 0                   CANCEL ESTAE EXIT
NOESTOFF DS    0H
         SPACE 1
         TM    ZLFDCB+48,X'10'     IF FILE SUCCESSFULLY OPENED
         BO    FITSTNUM            THEN PROCEED. ELSE...
OPENFAIL DS    0H
         L     #6,FILEATOM         Get file argument
         L     #1,ZLCSAVE2+56      Load saved #12
         #ERR  3,PREFIX=NO,SIGNAL=NO,                                  X
               'ZIL0007 ',CALLER,': ',TYPESTR,                         X
               ' file ',(#6),' open failed.'
         EJECT
         XR    #7,#7               CLEAR FILE BLOCK POINTER - ERROR
         B     TIOTEND             RETURN
         SPACE 1
FBERROR  DS    0H                  FILE BLOCK ALLOCATION ERROR
         #ERR  3,PREFIX=NO,SIGNAL=NO,                                  X
               'ZIL0032 ZILFGET: Not enough memory available for file bX
               lock.'
         B     OPENFAIL            FILE OPEN FAILED
         SPACE 1
FITSTNUM DS    0H
*
* IF FILE IS OPEN FOR INPUT AND NOT THE TERMINAL, IT MAY BE NUMBERED
* OR UNNUMBERED. DETERMINE THIS DYNAMICALLY BY READING THE FIRST
* RECORD FROM THE FILE AND CHECKING THE SEQUENCE NUMBER FIELD.
*
         TM    ZLFFLAG,ZLFINPUT    IF THIS IS AN INPUT FILE,
         BZ    FNOUTPUT            THEN
         TM    ZLFFLAG,ZLFTERM      IF THIS IS NOT THE TERMINAL
         BO    TIOTNEXT             THEN
         TM    ZLFDCB+36,X'C0'       IF RECFM = U
         BNO   NRECFMU               THEN...
         OI    ZLFFLAG2,ZLFRECU       INDICATE A RECFM=U FILE
         B     RECFMF                ELSE...
NRECFMU  DS    0H
         TM    ZLFDCB+36,X'80'       IF RECFM = V...
         BO    RECFMF                THEN...
         OI    ZLFFLAG2,ZLFRECV       INDICATE A RECFM=V FILE
RECFMF   DS    0H
         LA    #1,FIRSTEOF           SET TEMPORARY EODAD ROUTINE ADDR
         STCM  #1,7,ZLFDCB+33        IN DCB
         AIF   (NOT &ZILXA).SKIP3
         LA    #15,EOFCONT           GET ADDR OF EOF CONTINUATION
         BSM   #15,0                 AND ADD CURRENT AMODE TO IT
         ST    #15,AEOFCONT          STORE THIS VALUE
.SKIP3   ANOP
         AIF   (NOT &ZILXA).SKIP4
*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24
         LA    #1,GET24            ADDRESS OF THIS CODE
         LA    #2,GET24E           RETURN ADDRESS
         BSM   #2,#1
GET24    DS    0H
*---------------------------------THE AMODE IS NOW 24
.SKIP4   ANOP
         ST    #9,ZLCISV09            SAVE ZIL REGISTERS
         OI    ZLCIFLGS,ZLCISYS       INDICATE NON-ZIL CODE RUNNING
         GET   ZLFDCB                DO INITIAL GET
         NI    ZLCIFLGS,255-ZLCISYS
         AIF   (NOT &ZILXA).SKIP5
*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE
         BSM   0,#2
GET24E   DS    0H
*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY
.SKIP5   ANOP
         TM    ZLCIFLGS,ZLCIATTN      IF ATTENTION INTERRUPT OCCURRED
         BOR   #13                    THEN GO TO HANDLE IT
         OI    ZLFFLAG1,ZLFSTART      SHOW FIRST FILE READ DONE
         ST    #1,ZLFREC1            SAVE ADDR OF LOGICAL RECORD READ
         XR    #0,#0
         BCTR  #0,0
         ST    #0,ZLFCHAR            SET CHARACTER POINTER TO -1 (NL)
         TM    ZLFFLAG2,ZLFRECV      IF RECFM = V...
         BZ    NOTRECV               THEN...
         LH    #0,0(,#1)              GET LRECL FROM RDW OF RECORD
         LA    #15,4
         AR    #1,#15                 BUMP RECORD POINTER UP 4
         SR    #0,#15                 DECREASE LENGTH BY 4
         ST    #1,ZLFCARD             SET RECORD POINTER
         LR    #14,#1
         AR    #14,#0                 SET END-OF-RECORD POINTER
         CH    #0,=H'8'               IF RECORD SHORTER THAN 8 BYTES
         BL    VCHKREC                THEN CAN'T BE LINE NUMBERED
         TRT   0(8,#1),NUMTBL         SCAN FOR NUMERICS
         BNZ   VCHKREC                IF ALL NUMERICS, IT'S NUMBERED
VNUMBERD DS    0H                    RECFM=V WITH LINE NUMBERS
         OI    ZLFFLAG2,ZLFNUM       SHOW THAT FILE IS LINE NUMBERED
         LA    #1,8(,#1)             POINT TO TEXT (TRT DIDN'T BASH R1)
         ST    #1,ZLFCARD            SET RECORD POINTER
         SH    #0,=H'8'
VCHKREC  DS    0H                    OK, NOW CHECK FOR NULL RECORD
         LTR   #0,#0                 IF RECLEN ZERO OR NEGATIVE
         BP    SETINFIL              THEN
         XR    #1,#1                  SET CHAR PTR TO -1
         BCTR  #1,0
         ST    #1,ZLFCHAR
         B     SETINFIL
NOTRECV  DS    0H                    RECFM NOT V, MUST BE F OR U
         TM    ZLFFLAG2,ZLFRECU      IF RECFM = U
         BZ    NOTRECU               THEN...
         ST    #1,ZLFCARD             SET RECORD POINTER
         LH    #14,ZLFDCB+82          GET DCBLRECL
         LTR   #0,#14                 USE IT AS RECORD LENGTH
         BNZ   ULRECLOK               UNLESS IT'S ZERO, IN WHICH CASE
         LH    #14,ZLFDCB+52          GET DCB BLOCKSIZE
         LR    #0,#14                 USE IT AS RECORD LENGTH
ULRECLOK DS    0H
         AR    #14,#1                 COMPUTE END OF RECORD ADDRESS
         B     SETINFIL               AND GO USE THEM
NOTRECU  DS    0H                    RECFM NOT U, MUST BE F
         ST    #1,ZLFCARD            SET RECORD POINTER
         LH    #0,ZLFDCB+82          GET LRECL FROM DCB
         LR    #14,#1
         AR    #14,#0                POINT TO END OF RECORD
         SH    #14,=H'8'             BUMP BACK TO SEQUENCE NUMBER FIELD
         TRT   0(8,#14),NUMTBL       SCAN FOR NUMERICS
         BZ    NUMBERED              IF ALL NUMERICS, IT'S NUMBERED
NOTNUMBD DS    0H                    ELSE ASSUME UNNUMBERED
         LA    #14,8(,#14)           SET END-OF-RECORD POINTER
         B     SETINFIL
NUMBERED DS    0H                   OTHERWISE
         OI    ZLFFLAG2,ZLFNUM       SHOW THAT FILE IS LINE NUMBERED
         SH    #0,=H'8'              ASSUME NUMBERED, DECR REC LENGTH
SETINFIL DS    0H                   NOW RESET FILE FIELDS ACCORDINGLY
         STH   #0,ZLFLRECL          SET REVISED RECORD AREA LENGTH
         ST    #14,ZLFEND           SET END-OF-RECORD ADDRESS
         B     FILOPEND             FILE IS NOW OK
         SPACE 2
FIRSTEOF DS    0H                  HERE IF EOF ON INPUT FILE (EMPTY)
*                                  NOTE: THIS GETS CONTROL IN AMODE24!
         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE-RUNNING FLAG
         AIF   (NOT &ZILXA).SKIP6
         L     #15,AEOFCONT        GET ADDRESS OF EOF CONTINUATION
         BSM   0,#15               GO TO IT IN CALLER'S AMODE
AEOFCONT DS    A
.SKIP6   ANOP
EOFCONT  DS    0H
         TM    ZLCIFLGS,ZLCIATTN    IF ATTENTION INTERRUPT OCCURRED
         BOR   #13                  THEN GO TO HANDLE IT
         XR    #1,#1               INDICATE END OF FILE BY
         ST    #1,ZLFCARD          SETTING RECORD POINTER TO ZERO AND
         ST    #1,ZLFCHAR          SETTING CHARACTER POINTER TO ZERO
         LH    #0,ZLFDCB+82        PICK UP LRECL (IN CASE SOMEONE ASKS)
         STH   #0,ZLFLRECL          SET REVISED RECORD AREA LENGTH
         AR    #1,#0                POINT TO END OF RECORD
         ST    #1,ZLFEND            SET END-OF-RECORD ADDRESS
         B     FILOPEND             FILE IS NOW OK
         SPACE 2
FNOUTPUT DS    0H                  THIS IS AN OPEN OUTPUT FILE...
         TM    ZLFDCB+36,X'40'     IF RECFM = V...
         BZ    FNOUTOK             THEN...
         TM    ZLFDCB+36,X'80'
         BO    FNOUTOK
         OI    ZLFFLAG2,ZLFRECV     INDICATE SO IN FILE BLOCK
FNOUTOK  DS    0H
         AIF   (NOT &ZILXA).SKIP7
*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24
         LA    #1,PUT24            ADDRESS OF THIS CODE
         LA    #2,PUT24E           RETURN ADDRESS
         BSM   #2,#1
PUT24    DS    0H
*---------------------------------THE AMODE IS NOW 24
.SKIP7   ANOP
         ST    #9,ZLCISV09         SAVE ZIL REGISTERS
         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING
         LA    #1,ZLFDCB           DO THE INITIAL PUT LOCATE
         PUT   (1)                 (SETS #1 TO CURRENT LINE)
         NI    ZLCIFLGS,255-ZLCISYS
         AIF   (NOT &ZILXA).SKIP8
*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE
         BSM   0,#2
PUT24E   DS    0H
*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY
.SKIP8   ANOP
         TM    ZLCIFLGS,ZLCIATTN    IF ATTENTION INTERRUPT OCCURRED
         BOR   #13                  THEN GO TO HANDLE IT
         LH    #0,ZLFDCB+82        GET DCB LRECL
         TM    ZLFFLAG2,ZLFRECV    IF RECFM=V FILE
         BZ    NOTRECVO            THEN...
         TM    ZLFDCB+36,X'04'      IF RECFM = V.A
         BZ    NOTRECVA             THEN...
         STH   #0,0(,#1)             INITIALIZE RDW
         XC    2(2,#1),2(#1)
         MVI   4(#1),C'1'            INITIALIZE PRINT CONTROL CHAR
         LA    #1,5(,#1)             BUMP PAST RDW TO TEXT
         SH    #0,=H'5'              SET LENGTH OF ACTUAL TEXT
         B     NOTRECFA
NOTRECVA DS    0H                   RECFM = V(B), NOT A
         STH   #0,0(,#1)            INITIALIZE RDW
         XC    2(2,#1),2(#1)
         LA    #1,4(,#1)            BUMP PAST RDW TO TEXT
         SH    #0,=H'4'             SET LENGTH OF ACTUAL TEXT
         B     NOTRECFA
NOTRECVO DS    0H
         TM    ZLFDCB+36,X'04'     IF RECFM = ..A
         BZ    NOTRECFA            THEN...
         MVI   0(#1),C'1'           INITIALIZE PRINT CONTROL CHAR
         LA    #1,1(,#1)            BUMP POINTER PAST CONTROL CHAR
         BCTR  #0,0                 SUBTRACT 1 FOR PRINT CONTROL CHAR
NOTRECFA DS    0H
         STH   #0,ZLFLRECL         STORE RECORD LENGTH
         ST    #1,ZLFCARD          STORE CURRENT RECORD ADDRESS
         ALR   #1,#0               RECORD ADDRESS + LRECL GIVES...
         ST    #1,ZLFEND           NEW END-OF-RECORD POINTER
         LA    #15,X'40'           SOURCE LENGTH = 0
         SLL   #15,24              FILL = BLANK
         L     #0,ZLFCARD          TARGET = OUTPUT AREA
         LH    #1,ZLFLRECL         LENGTH = LENGTH OF OUTPUT AREA
         XR    #14,#14             SOURCE = NULL
         MVCL  #0,#14              CLEAR OUTPUT AREA TO BLANKS
FILOPEND DS    0H                  FILE OPEN COMPLETE...
         OI    ZLFFLAG2,ZLFOPEN    INDICATE FILE OPEN
         CLI   ZLCMSLVL,0
         BH    NONOTIFY
         MVI   ZIL0006,C' '        CLEAR MESSAGE TO BLANKS
         MVC   ZIL0006+1(L'ZIL0006-1),ZIL0006
         MVC   ZIL0006(L'FM1MSG),FM1MSG
         MVC   FM1NAME(4),FNAME    SET FILE NAME IN MESSAGE
         LA    #1,FM1NAME          SEARCH FOR TERMINATING WHITESPACE
         LA    #0,4                IN FILE NAME
GETFM1   CLI   0(#1),X'40'
         BNH   GOTFM1
         LA    1,1(,#1)
         BCT   #0,GETFM1
GOTFM1   DS    0H
         MVC   0(L'FM1REST,#1),FM1REST
         CLI   TYPE,INPUT
         BNE   FM1NOTIN
         MVC   L'FM1REST(6,#1),=CL6'INPUT.'
         B     FM1AFTIN
FM1NOTIN MVC   L'FM1REST(7,#1),=CL7'OUTPUT.'
FM1AFTIN DS    0H
         #TPUT 0,ZIL0006           FILE OPEN SUCCESSFUL
NONOTIFY DS    0H
         SPACE 1
         TM    ZLFFLAG1,ZLFTERM    IF THIS IS A TERMINAL FILE
         BZ    TIOTEND             THEN
         L     #7,ZLFTFPTR          LOAD PTR TO TRUE TERMINAL FILBLK
         SPACE
TIOTEND  DS    0H                  TIOT SEARCH OVER
         SPACE
         LM    #14,#6,ZLCSAVE2     RESTORE REGISTERS
         LM    #8,#12,ZLCSAVE2+40  EXCEPT FOR REGISTER 7
         DROP  #12
         SPACE 1
         LTR   #7,#7               IF A FILE BLOCK SUCCESSFULLY FOUND
         BNZR  #14                 THEN RETURN WITH IT. ELSE ERROR
         SPACE 1
***********************************************************************
*
* FILE NOT FOUND, SIGNAL ERROR
*
***********************************************************************
         SPACE 1
         #BASR #4,0
         USING *,#4
         TM    ZLCERFLG,ZLCERCFA   IF THIS FILE ACCESS IS CONDITIONAL
         BZ    FNFERROR            THEN...
         XR    #7,#7                SET FILE BLOCK POINTER TO ZERO
         BR    #14                  AND RETURN
FNFERROR DS    0H                  ELSE FILE-NOT-FOUND ERROR
         L     #6,FILEATOM         Get file argument
         #ERR  PREFIX=NO,'ZIL0008 ',CALLER,': ',TYPESTR,               X
               ' file ',(#6),' does not exist (DDNAME ',               X
               DDSTR,' not found).'
         SPACE 1
         DROP  #4
         EJECT
GETCALR  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* This subroutine extracts the name of the calling function, as       *
* pointed to by register 12 on entry, and builds a "fake string"      *
* out of it to pass to the error message handler.                     *
*                                                                     *
* It also sets the file type string to INPUT or OUTPUT.               *
*                                                                     *
* On entry register 1 points to the compiled function code (#12).     *
*                                                                     *
***********************************************************************
         SPACE 1
         PUSH  USING
         #BASR #2,0
         USING *,#2
         SPACE 1
         CLI   TYPE,C'I'           IF FILE TYPE IS INPUT
         BNE   GETCNI              then
         MVC   TYPESTR(L'STRINPUT),STRINPUT
         B     AFTGCETS            else
GETCNI   MVC   TYPESTR(L'STROUTPT),STROUTPT
AFTGCETS DS    0H
         SPACE 1
         XR    #15,#15             Clear insert register
         IC    #15,4(,#1)          Get length of module identifier
         SH    #15,=H'16'          Reduce by length of date/time info
         BNP   DUNNO               If no name, generate dummy name
         CH    #15,=Y(L'CALLTEXT)  If name longer than our text area
         BNH   *+8                 then
         LA    #15,L'CALLTEXT       use our maximum length
         STCM  #15,7,CALLLEN       Store length of function name
         BCTR  #15,0               Reduce length for execute
         EX    #15,MVCCALL         Move caller's name to fake string
         BR    #14                 Return to caller
DUNNO    DS    0H                  Can't figure out function name?
         MVC   CALLER(CALLDUML),CALLDUM Then use this...
         BR    #14                 Return to caller
         SPACE 1
MVCCALL  MVC   CALLTEXT(*-*),5(#1) Executed: Move caller name to string
         SPACE 1
         DS    0H,XL1              Align string to non-halfword
CALLER   DC    YL1(##STRING)       Fake string header
CALLLEN  DC    AL3(0)              Fake string length
CALLTEXT DS    CL64                Fake string text
         DS    0H,XL1              Align string to non-halfword
TYPESTR  #SATM '      '            Room for file type
         SPACE 1
         DS    0H,XL1              Align string to non-halfword
STRINPS  #SATM 'Input'             Possible file type
STRINPUT EQU   STRINPS,*-STRINPS
         DS    0H,XL1              Align string to non-halfword
STROUPS  #SATM 'Output'            Possible file type
STROUTPT EQU   STROUPS,*-STROUPS
         SPACE 1
         DS    0H,XL1              Align string to non-halfword
CALLDUM  #SATM 'ZILFGET'           Use this if can't figure out caller
CALLDUML EQU   *-CALLDUM
         SPACE 1
FM1MSG   DC    C'ZIL0006 FILE '
FM1REST  DC    C' OPEN FOR '
FM1TYPE  DC    C'       '
ZIL0006  DS    CL(L'FM1MSG+4+L'FM1REST+7)
FM1NAME  EQU   ZIL0006+L'FM1MSG,4,C'C'
         SPACE 1
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         SPACE 1
         POP   USING
         EJECT
STAEOK   DC    X'00'               Flag set if ESTAE successful
         SPACE 1
STAEPARM DS    0A                  ESTAE PARAM AREA
STAECOMP DS    A                   COMPLETION CODE
STAEREAS DS    A                   REASON CODE
STAERTRY DS    A                   ADDRESS OF RETRY ROUTINE
STAEREGS DS    7A                  SAVE AREA FOR REGS 7-13
         EJECT
STARETRY DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* RETRY ROUTINE TO RECEIVE CONTROL WHEN ESTAE EXIT DETECTED AN ABEND  *
* IN THE OPEN ROUTINE.  THIS ROUTINE WILL ATTEMPT TO RETURN TO THE    *
* MAINLINE CODE FOR THE PURPOSE OF DISPLAYING AN ERROR MESSAGE.       *
*                                                                     *
*  ON ENTRY TO THIS ROUTINE:                                          *
*                                                                     *
*  IF AN SDWA WAS AVAILABLE (REGISTER 0 = OTHER THAN 12 IN STAEEXIT)  *
*  THEN (ASSUMING DEFAULTS OF RETREGS=NO AND FRESDWA=NO):             *
*                                                                     *
*    REGISTER  0 = 0                                                  *
*    REGISTER  1 = ADDRESS OF THE SDWA                                *
*    REGISTER 14 = ADDRESS OF AN SVC 3 INSTRUCTION (EXIT)             *
*    REGISTER 15 = ENTRY POINT ADDRESS OF THIS RETRY ROUTINE          *
*                                                                     *
*  OTHERWISE (REGISTER 0 = 12 IN STAEEXIT):                           *
*                                                                     *
*    REGISTER  0 = 12                                                 *
*    REGISTER  1 = ADDRESS OF THE ESTAE PARAMETER LIST (PARAM)        *
*    REGISTER  2 = ADDRESS OF THE PURGE I/O LIST OR 0                 *
*    REGISTER 14 = ADDRESS OF AN SVC 3 INSTRUCTION (EXIT)             *
*    REGISTER 15 = ENTRY POINT ADDRESS OF THIS RETRY ROUTINE          *
*                                                                     *
*  OTHER REGISTER CONTENTS ARE UNPREDICTABLE (UNLESS RETREGS=YES      *
*  WAS SPECIFIED IN THE ESTAE EXIT).                                  *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    #6,#15
         USING STARETRY,#6
         LA    #3,12               CHECK IF REGISTER 0 = 12
         CR    #0,#3               IF AN SDWA IS AVAILABLE
         BE    NOSDWAR             THEN...
         USING SDWA,#1
         L     #4,SDWAPARM          #4 -> WORKAREA
         B     AFTSDWAR
NOSDWAR  DS    0H                  ELSE...
         LR    #4,#1                #4 -> WORKAREA
AFTSDWAR DS    0H
         ESTAE 0                   CANCEL ESTAE
         LM    #7,#13,STAEREGS-STAEPARM(#4)  RELOAD REGISTERS
         DROP  #6
         USING USING12,#12
         MVC   ABENDF(4),FNAME
         L     #0,STAECOMP-STAEPARM(,#4)      GET COMPLETION CODE
         SLL   #0,4                SHIFT OUT HIGH ORDER BYTE
         ST    #0,ZLCDBL
         UNPK  ABENDC(4),ZLCDBL(3)
         TR    ABENDC(4),HEXTBL
         MVI   ABENDC+3,C','
         L     #0,STAEREAS-STAEPARM(,#4)      GET REASON CODE
         SLL   #0,16               ONLY CARE ABOUT LAST 3 NIBBLES
         ST    #0,ZLCDBL
         UNPK  ABENDR(4),ZLCDBL(3)
         TR    ABENDR(4),HEXTBL
         MVI   ABENDR+3,C'.'
         #ERR  PREFIX=NO,          FILE NAME INVALID                   X
               'ZIL0030 ',CALLER,': ',TYPESTR,                         X
               ' file ',ABENDFS,' open failed, ABEND code ',ABENDCS,   X
               ' reason code ',ABENDRS
         SPACE 1
         DS    0H,XL1
ABENDFS  #SATM '    '
ABENDF   EQU   ABENDFS+4,4,C'C'
         DS    0H,XL1
ABENDCS  #SATM '   ,'
ABENDC   EQU   ABENDCS+4,4,C'C'
         DS    0H,XL1
ABENDRS  #SATM '   .'
ABENDR   EQU   ABENDRS+4,4,C'C'
         SPACE 1
         DROP  #12
         SPACE 1
         EJECT
STAEEXIT DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* ESTAE EXIT THAT GETS CONTROL IF AN ABEND OCCURS DURING OPEN.        *
*                                                                     *
*  ON ENTRY TO THIS ROUTINE:                                          *
*                                                                     *
*  REGISTER 0 = 12 - NO SWDA AVAILABLE                                *
*               OTHER - SDWA AVAILABLE                                *
*                                                                     *
*  IF REGISTER 0 = 12:                                                *
*                                                                     *
*     REGISTER 1  = ABEND COMPLETION CODE                             *
*     REGISTER 2  = ADDRESS OF THE ESTAE PARAMETER LIST (PARAM)       *
*     REGISTER 14 = RETURN ADDRESS TO RTM                             *
*     REGISTER 15 = ENTRY POINT ADDRESS OF THIS ESTAE EXIT ROUTINE    *
*                                                                     *
*  OTHERWISE:                                                         *
*                                                                     *
*     REGISTER 1  = ADDRESS OF THE SDWA                               *
*     REGISTER 13 = ADDRESS OF A 72-BYTE SAVE AREA                    *
*     REGISTER 14 = RETURN ADDRESS TO RTM                             *
*     REGISTER 15 = ENTRY POINT ADDRESS OF THIS ESTAE EXIT ROUTINE    *
*                                                                     *
***********************************************************************
         SPACE 1
         PUSH  USING
         LR    #7,#15              SAVE ENTRY ADDRESS REGISTER
         USING STAEEXIT,#7
         LA    #3,12               CHECK IF REGISTER 0 = 12
         CR    #0,#3               IF AN SDWA IS AVAILABLE
         BE    NOSDWAE             THEN...
         USING SDWA,#1
         L     #4,SDWAPARM          #4 -> WORKAREA
         XR    #5,#5
         ICM   #5,7,SDWACMPC        #5 = COMPLETION CODE
         ST    #5,STAECOMP-STAEPARM(,#4) STORE COMPLETION CODE
         L     #6,SDWAGR15          #6 = REASON CODE FROM ABEND MACRO
         ST    #6,STAEREAS-STAEPARM(,#4) STORE REASON CODE
         L     #2,STAERTRY-STAEPARM(,#4) ADDRESS OF RETRY ROUTINE
         SETRP RETADDR=(#2),DUMP=NO,RC=4  INDICATE RETRY
         BR    #14                 AND RETURN
         SPACE 1
NOSDWAE  DS    0H                  NO SDWA AVAILABLE...
         LR    #4,#2                #4 -> WORKAREA
         LR    #5,#1                #5 = COMPLETION CODE
         ST    #5,STAECOMP-STAEPARM(,#4) STORE COMPLETION CODE
         XR    #6,#6                #6 = REASON CODE ZERO (UNKNOWN)
         ST    #6,STAEREAS-STAEPARM(,#4) STORE REASON CODE
         L     #0,STAERTRY-STAEPARM(,#4) ADDRESS OF RETRY ROUTINE
         LA    #15,4               INDICATE RETRY TO BE ATTEMPTED
         BR    #14                 AND RETURN
         POP   USING
         EJECT
OUTEXIT  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* DCB OPEN EXIT FOR ALL OUTPUT FILES.  THIS FILLS IN DCB INFO.        *
*                                                                     *
* NOTE: THIS ROUTINE EXECUTES IN AMODE 24 (I THINK).                  *
*                                                                     *
***********************************************************************
         SPACE 1
         USING DCBSTUFF,#1
DCBSTUFF DSECT
DSORG    EQU   DCBSTUFF+X'1A',2,C'X'
RECFM    EQU   DCBSTUFF+X'24',1,C'X'
LRECL    EQU   DCBSTUFF+X'52',2,C'H'
BLKSIZE  EQU   DCBSTUFF+X'3E',2,C'H'
         SPACE 1
ZILFGET  CSECT
         SPACE 1
         USING OUTEXIT,#15
         OC    DSORG,DSORG         IF NO DSORG PRESENT
         BNZ   OXGOTDS             THEN
         MVI   DSORG,X'40'          SET DSORG = PS
OXGOTDS  DS    0H
         CLI   RECFM,X'00'         IF NO RECFM PRESENT
         BNE   OXGOTRF             THEN
         MVI   RECFM,X'90'          SET RECFM = FB
         B     OXFIXED              AND PROCESS FIXED LRECL.
OXGOTRF  DS    0H                  ELSE THERE IS A RECFM
         TM    RECFM,X'80'         IF RECFM = V..
         BO    OXFIXED             THEN
         OC    LRECL,LRECL          IF THERE'S NO LRECL
         BNZ   OXGOTLR              THEN
         LA    #15,255               SET LRECL = 255
         STH   #15,LRECL
         LA    #15,4095
         LA    #15,6233-4095(,#15)   SET BLKSIZE = 6233
         STH   #15,BLKSIZE
         BR    #14                   AND RETURN.
OXFIXED  DS    0H
         OC    LRECL,LRECL         IF LRECL IS ZERO
         BZ    OXSETF              THEN SET LRECL AND BLKSIZE
OXGOTLR  OC    BLKSIZE,BLKSIZE     IF BLOCK SIZE EXISTS
         BNZR  #14                 THEN WE ARE ALL SET
         LA    #15,6160/80         ELSE GET DEFAULT BLOCKING FACTOR
         MH    #15,LRECL           MULTIPLY BY LRECL
         STH   #15,BLKSIZE         SET BLOCKSIZE
         BR    #14
OXSETF   LA    #15,80               SET LRECL = 80
         STH   #15,LRECL
         LA    #15,4095
         LA    #15,6160-4095(,#15)  SET BLKSIZE = 6160
         STH   #15,BLKSIZE
         BR    #14                  AND RETURN.
         SPACE 1
         DROP  #1,#15
         EJECT
INPUT    EQU   C'I'
OUTPUT   EQU   C'O'
         SPACE 1
         DS    0H,XL1              Align fake string to non-halfword
DDSTR    DC    YL1(##STRING)
DDLEN    DC    AL3(8)
DDNAME   DS    CL8
TYPE     EQU   DDNAME+3,1,C'C'
FILEATOM DS    A
FNAME    DS    CL4
         SPACE 1
OPENL    OPEN  (*-*),MF=L
         SPACE 1
XLOUT    DC    0F'0',X'85',AL3(OUTEXIT) EXIT LIST FOR OUTPUT DCB
         EJECT
NUMTBL   DC    256YL1(1)           TABLE TO SCAN FOR NUMERICS
         ORG   NUMTBL+C'0'
         DC    10YL1(0)
         ORG
         EJECT
INDDDCB  DCB   DDNAME=X,                                               X
               MACRF=GL,                                               X
               DSORG=PS   NOTE - NO EODAD. THIS IS SET DYNAMICALLY.
         EJECT
OUTDDDCB DCB   DDNAME=X,                                               X
               MACRF=PL,                                               X
               DSORG=PS,                                               X
               EXLST=XLOUT
         EJECT
         #ZHDR ,
         EJECT
         IHASDWA  ,
         END
