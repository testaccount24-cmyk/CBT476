         TITLE 'ZILVALS - ZIL 1.3 returner of multiple values'
***********************************************************************
*                                                                     *
* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *
*                     All rights reserved.                            *
*                                                                     *
***********************************************************************
*                                                                     *
* This routine, linked with ZILSUBS, performs all returning of        *
* multiple values for ZIL.                                            *
*                                                                     *
* The LISP VALUES function will compile into a call to this routine   *
* with the appropriate settings in the appropriate registers.         *
*                                                                     *
***********************************************************************
*                                                                     *
* On entry to this routine:                                           *
*                                                                     *
* =================================================================== *
*                                                                     *
* #0 zero:  scan environment to see if multiple values are being      *
*           requested and return them in the desired format.          *
*                                                                     *
* #0 negative: scan environment to see if multiple values are being   *
*              requested; return the number of values requested in    *
*              #2 (or -1 if a list of values is requested) and the    *
*              stack address of the returned values (or list) in #0.  *
*                                                                     *
* #0 positive: return the values using the stack address, which is    *
*              the positive value in #0, and the number of arguments  *
*              in #2 (-1 if a list of values is requested).           *
*                                                                     *
* =================================================================== *
*                                                                     *
* #1 - when #0 is zero, points to the stack location where the values *
*      passed to this routine are stored in successive stack slots.   *
*                                                                     *
*      when #0 is negative, irrelevant.                               *
*                                                                     *
*      when #0 is positive, the current stack address (for CONSing).  *
*                                                                     *
* =================================================================== *
*                                                                     *
* #2 - when #0 is zero, contains the number of values stored on the   *
*      stack passed to this routine.  If -1, the stack slot points    *
*      to a list of values.                                           *
*                                                                     *
*      when #0 is negative, irrelevant.                               *
*                                                                     *
*      when #0 is positive, the number of multiple values required    *
*      (-1 if a list of values must be built).                        *
*                                                                     *
***********************************************************************
*                                                                     *
* This routine is invoked from compiled code by:                      *
* (VALUES ...)    - #0 = zero                                         *
*                   #1 -> stack location of arguments to VALUES       *
*                   #2 = number of arguments specified to VALUES      *
*                                                                     *
* (VALUES-LIST x) - #0 = zero                                         *
*                   #1 -> stack location of list argument             *
*                   #2 = -1                                           *
*                                                                     *
* (Note: VALUES-LIST might not be specially handled by the compiler,  *
*        but might be a function that invokes ZILVALS with the above) *
*                                                                     *
***********************************************************************
*                                                                     *
* Multiple values are requested by the following special forms, which *
* MUST be handled specially by the compiler:                          *
*                                                                     *
* (MULTIPLE-VALUE-LIST (form))                                        *
*                                                                     *
* (MULTIPLE-VALUE-BIND (arglist) (form) . forms)                      *
*                                                                     *
* Note that these are macros in Common LISP.  The only special form   *
* in Common LISP for requesting multiple values is                    *
* MULTIPLE-VALUE-CALL, which must be implemented in ZIL as a macro.   *
*                                                                     *
* The code sequence for (MULTIPLE-VALUE-LIST (form)) is:              *
*                                                                     *
*          ST    #11,xxx(,#11)       Store junk pointer in stack loc. *
*          ...   ... code to execute (form) ...                       *
*          ...   ... which returns something in #15 ...               *
*          ...   ... possible base register loadings here ...         *
*          C     #11,xxx(,#11)       If multiple values returned,     *
*          BE    G00001              then...                          *
*          L     #15,xxx(,#11)        load pointer to list of values  *
*          B     G00002              else...                          *
* G00001   DS    0H                  No multiple values returned      *
*          LR    #1,#15              Return value = arg 1 to CONS     *
*          L     #15,ZLCCONS         Get address of ZILCONS           *
*          LR    #2,#10              NIL = arg 2 to CONS              *
*          BALR  #14,#15             Call ZILCONS for list of 1 value *
* G00002   DS    0H                  No multiple values returned      *
*                                                                     *
* The code sequence for (MULTIPLE-VALUE-BIND (a b c) (form) ...) is:  *
*                                                                     *
*          ST    #11,xxx+0(,#11)     Store junk pointer in stack loc. *
*          ...   ... code to execute (form) ...                       *
*          ...   ... which returns something in #15 ...               *
*          BC    0,3(#11,0)          NOP (470B) with # of arguments   *
*          C     #11,xxx(,#11)       If multiple values returned,     *
*          BNE   G00001              then do nothing, values set      *
*          ST    #15,xxx+0(,#11)     else set var A to only value     *
*          ST    #10,xxx+4(,#11)     set variable B to NIL            *
*          ST    #10,xxx+8(,#11)     set variable C to NIL            *
* G00001   DS    0H                                                   *
*                                                                     *
* The NOP and the compare to #11 are extremely important, because     *
* they are signals to ZILVALS that multiple values are being          *
* requested.  ZILVALS (this routine) determines if multiple values    *
* are needed by inspecting the instruction flow, starting with the    *
* return address in #14, to see if:                                   *
*                                                                     *
* (1) multiple values are requested by the presence of the special    *
*     NOP (470B....) or C (59B0....) instruction generated by one     *
*     of the multiple-value-requesting special forms.                 *
*                                                                     *
* (2) a single value is requested (i.e. normal operation) by the      *
*     presence of instructions that use or reset the contents of #15. *
*                                                                     *
* (3) an instruction occurs that signals passing of control to        *
*     another function (e.g. BALR) or outside of LISP (e.g. SVC).     *
*                                                                     *
* Only in case (1) is the processing of multiple values done.         *
* The instruction flow scanning needs to track the values of the      *
* ZIL registers #11, #12, and #14 as it goes.  If a call to VALUES,   *
* for example, is in tail-recursive position, it will be followed     *
* (not necessarily immediately, since ALIST restores or the like      *
* may occur) by the code sequence                                     *
*                                                                     *
*          LR    1,11                                                 *
*          LM    11,12,...(1)                                         *
*          L     14,...(1)                                            *
*          BR    14                                                   *
*                                                                     *
* which is the standard ZIL return sequence from compiled code.       *
* When this is found, the new values of #11,#12 and #14 must be       *
* taken from the stack and instruction scanning resumed until one     *
* of the three cases above is encountered.                            *
*                                                                     *
* Branch instructions must be followed as well.  This means that      *
* base registers must be determined if necessary, as follows:         *
*                                                                     *
* #12, the primary base register, must be known at the time.          *
*                                                                     *
* #7, if used, is either #12+4095 or #12+4096.  Which it is may       *
* be determined based on whether the displacement is odd or even.     *
*                                                                     *
* #6, if used, is #12+(2*4096).                                       *
* #5, if used, is #12+(3*4096).                                       *
* #4, if used, is #12+(4*4096).                                       *
*                                                                     *
* Backward branches are NOT followed.                                 *
*                                                                     *
* The NOP branch (4700) is a signal used by UNWIND-PROTECT.  When     *
* this is seen, the NOP branching path is followed, and must take     *
* you to an instruction that loads a register from the stack.  If     *
* the register is 15, multiple values are possible (this is one of    *
* the only cases where a load of 15 does not rule out multiple        *
* values); if a different register is loaded, the value is not        *
* being returned and therefore multiple values are irrelevant.        *
*                                                                     *
***********************************************************************
         SPACE 1
ZILVALS  CSECT
         SPACE 1
         USING ZILVALS,#15
         #ZUSING ,
         SPACE 1
*
* Dispatch based on the contents of #0.
* Zero ------- normal call for VALUES:  scan and return values
* Negative --- scan only, return MV info
* Positive --- return values only, using info from previous scan call
*
         LTR   #0,#0
         BZ    NORMAL
         BM    ONLYSCAN
         BP    ONLYRET
         EJECT
NORMAL   DS    0H                  Normal call for VALUES
ONLYSCAN DS    0H                  Scan environment for requestor
         SPACE 1
***********************************************************************
*
* Register usage:
*
* #0 --- entry code (zero, negative or positive)
* #1 --- volatile (destroyed by TRT)
* #2 --- volatile (destroyed by TRT)
* #3 --- VALUES stack pointer    (#1)
* #4 --- VALUES number of values (#2)
* #5 --- track stack pointer    (#11)
* #6 --- track base register    (#12)
* #7 --- track return address   (#14)
* #14 -- ZILVALS return address. Be careful!!!
* #15 -- ZILVALS base register.  Be careful!!!
*
***********************************************************************
         SPACE 1
*
* Save the input parameter registers (1,2).
*
         LR    #3,#1               Pointer to values on stack
         LR    #4,#2               Number of values on stack
*
* Save the contents of the three important registers (11, 12, 14)
* at entry to ZILVALS.
*
         LR    #5,#11              Caller's stack pointer
         LR    #6,#12              Caller's code base register
         LR    #7,#14              Caller's return address
         SPACE 1
CONTINUE DS    0H
         SPACE 1
         XR    #2,#2               Clear TRT flag register
         SPACE 1
OPLOOP   DS    0H
*
* Check the opcode pointed to by #7 to see where we're going.
*
         TRT   0(1,#7),INSTRTBL    Test the instruction opcode
         BNZ   GO(#2)              Branch depending on opcode
GO       B     NO                  #2=0, bad or unusual opcode, no MV's
         B     MBMV47              #2=4
         B     MBMV59              #2=8
         B     MBMV18              #2=12
         B     MBBALR              #2=16
         B     MBBCR               #2=20
         B     MBSVC               #2=24
         B     MBRR                #2=28
         B     BUMP2               #2=32
         B     MBRX                #2=36
         B     MBSTMLM             #2=40
         B     MBSI                #2=44
         B     MBMASK              #2=48
         B     MBSS                #2=52
         SPACE 1
TRTNO    EQU   0
TRTMV47  EQU   4
TRTMV59  EQU   8
TRTMV18  EQU   12
TRTBALR  EQU   16
TRTBCR   EQU   20
TRTSVC   EQU   24
TRTRR    EQU   28
TRTBUMP2 EQU   32
TRTRX    EQU   36
TRTSTMLM EQU   40
TRTSI    EQU   44
TRTMASK  EQU   48
TRTSS    EQU   52
         SPACE 1
INSTRTBL DS    0X                  Table of instruction op codes
*
* Most opcodes are undefined or unusual, so they fall into the "nope,
* no multiple values being returned from here" category.  Also, to
* keep things simple, any instruction that potentially references
* register 15 implicitly (other than STM and LM) is considered to fall
* into this category.  In other words, instructions like MVCL, SRDL,
* M, DR, BXLE are not expected to occur in compiled code, so if they
* should occur, they will stop the return of multiple values.
* Instructions that give control temporarily to other code (EX, BAL)
* for the most part fall into the same category.
*
         DC    256YL1(TRTNO)
         ORG   INSTRTBL+X'05'      BALR
         DC    1YL1(TRTBALR)
         ORG   INSTRTBL+X'06'      BCTR
         DC    1YL1(TRTBALR)
         ORG   INSTRTBL+X'07'      BCR
         DC    1YL1(TRTBCR)
         ORG   INSTRTBL+X'0A'      SVC
         DC    1YL1(TRTSVC)
         ORG   INSTRTBL+X'0B'      BSM
         DC    1YL1(TRTNO)
         ORG   INSTRTBL+X'0C'      BASSM
         DC    1YL1(TRTNO)
         ORG   INSTRTBL+X'0D'      BASR
         DC    1YL1(TRTBALR)
         ORG   INSTRTBL+X'10' -17  LPR,LNR,LTR,LCR,NR,CLR,OR,XR
         DC    8YL1(TRTRR)
         ORG   INSTRTBL+X'18'      LR
         DC    1YL1(TRTMV18)
         ORG   INSTRTBL+X'19' -1B  CR,AR,SR
         DC    3YL1(TRTRR)
         ORG   INSTRTBL+X'1E' -1F  ALR,SLR
         DC    2YL1(TRTRR)
         ORG   INSTRTBL+X'20' -3F  Floating-point RR instructions
         DC    32YL1(TRTBUMP2)
         ORG   INSTRTBL+X'40' -43  STH,LA,STC,IC
         DC    4YL1(TRTRX)
         ORG   INSTRTBL+X'46'      BCT
         DC    1YL1(TRTRX)
         ORG   INSTRTBL+X'47'      BC
         DC    1YL1(TRTMV47)
         ORG   INSTRTBL+X'48' -4C  LH,CH,AH,SH,MH
         DC    5YL1(TRTRX)
         ORG   INSTRTBL+X'4E' -50  CVD,CVB,ST
         DC    3YL1(TRTRX)
         ORG   INSTRTBL+X'54' -58  N,CL,O,X,L
         DC    5YL1(TRTRX)
         ORG   INSTRTBL+X'59'      C
         DC    1YL1(TRTMV59)
         ORG   INSTRTBL+X'5A' -5B  A,S
         DC    2YL1(TRTRX)
         ORG   INSTRTBL+X'5E' -5F  AL,SL
         DC    2YL1(TRTRX)
         ORG   INSTRTBL+X'60'      STD
         DC    1YL1(TRTRX)
         ORG   INSTRTBL+X'67' -70  More floating-point
         DC    10YL1(TRTRX)
         ORG   INSTRTBL+X'78' -7F  More floating-point
         DC    8YL1(TRTRX)
         ORG   INSTRTBL+X'88' -8B  SRL,SLL,SRA,SLA
         DC    4YL1(TRTRX)
         ORG   INSTRTBL+X'90'      STM
         DC    1YL1(TRTSTMLM)
         ORG   INSTRTBL+X'91' -92  TM,MVI
         DC    2YL1(TRTSI)
         ORG   INSTRTBL+X'94' -97  NI,CLI,OI,XI
         DC    4YL1(TRTSI)
         ORG   INSTRTBL+X'98'      LM
         DC    1YL1(TRTSTMLM)
         ORG   INSTRTBL+X'BD'      CLM,STCM,ICM
         DC    3YL1(TRTMASK)
         ORG   INSTRTBL+X'D1' -D7  MVN,MVC,MVZ,NC,CLC,OC,XC
         DC    7YL1(TRTSS)
         ORG   INSTRTBL+X'DC' -DF  TR,TRT,ED,EDMK
         DC    4YL1(TRTSS)
         ORG   INSTRTBL+X'F0' -F3  SRP,MVO,PACK,UNPK
         DC    4YL1(TRTSS)
         ORG   INSTRTBL+X'F8' -FD  ZAP,CP,AP,SP,MP,DP
         DC    6YL1(TRTSS)
         ORG
         EJECT
MBMV47   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Opcode is:                                                          *
*                                                                     *
*        X'47' BC                                                     *
*                                                                     *
* Format:      opcd c1 i2 b2 d2d2d2                                   *
*                                                                     *
* Rule:                                                               *
*                                                                     *
*  This may be one of the multiple value sentinels:                   *
*                                                                     *
*     4700x...                                                        *
*     470B....                                                        *
*                                                                     *
*  If it is, go to handle that case specifically.                     *
*                                                                     *
*  If it is 47F0...., then we must follow the branch, unless it       *
*  goes backward, in which case no MV's are returned.                 *
*                                                                     *
*  Otherwise, it's a conditional branch, so no MV's are returned.     *
*                                                                     *
*  Note that 47Fx where x is nonzero is a computed branch, so we      *
*  treat that the same wrt no MV's.  We assume that 47Fx0yyy will     *
*  not occur in compiled code.                                        *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   1(#7),X'F0'         If it's 47F0....
         BE    MBBRANCH            then go to follow branch
         CLI   1(#7),X'00'         If it's NOP (4700....)
         BE    MBBRANCH            then go to handle NOP
         CLI   1(#7),X'0B'         If it's 470B....
         BE    MB470B              then go to handle 470B
         B     NO                  else answer is no
         SPACE 1
MB470B   DS    0H                  470B.... - MULTIPLE-VALUE-BIND
*
***********************************************************************
*                                                                     *
* 470B.... is part of the generated code for MULTIPLE-VALUE-BIND or   *
* THROW.  If it's 470B,8000, then it's THROW; otherwise M.V.BIND.     *
*                                                                     *
* If #0 is negative, return information only.                         *
* If #0 is zero, store the multiple values here.                      *
* If #0 is positive - well, that will never get here.                 *
*                                                                     *
***********************************************************************
*
         LH    #2,2(,#7)           Load number of values from 470Bxxxx
         LTR   #2,#2               If negative (470B8000),
         BM    MBTHROW             then go to process THROW
         LTR   #0,#0               If #0 is negative
         BM    MVBINFO             then go to return info only
*
* The instruction following the 470B.... should be 59B0Bxxx, where
* Bxxx is the location of the stack slots where the values are to go.
*
         LH    #0,6(,#7)           Get Bxxx from 59B0Bxxx instruction
         N     #0,=X'00000FFF'     Isolate displacement
         AR    #5,#0               Add displ. to tracked stack address
MB47VALS DS    0H
*
* In the degenerate case of MULTIPLE-VALUE-BIND with a null list of
* variables to be assigned values, we will return info that zero
* values are being requested, but will return a single value as if
* it was a non-multiple-value-returning situation.
*
         LTR   #2,#2               If # of requested values is zero
         BZ    DONOVALS            then return immediate value only
         LTR   #1,#4               Get number of values being returned
         BNZ   MVBPUTS             If no values being returned (VALUES)
         ST    #10,0(,#5)          then store NIL into first value slot
         LA    #5,4(,#5)            bump to next value slot
         BCT   #2,MVBNILS           go put NILs in rest of slots if any
         B     DONOVALS             and then go to return immed. value
MVBPUTS  DS    0H                  Else one or more values to return
         LR    #7,#3               Get pointer to values being passed
MVBPUT   DS    0H                  Loop storing values
         MVC   0(4,#5),0(#7)       Move value to requesting stack slot
         BCTR  #2,0                Decrement requested value count
         LTR   #2,#2               If no more value slots to fill
         BZ    DONOVALS            then through, go return immed. value
         LA    #5,4(,#5)           Bump requesting stack slot
         LA    #7,4(,#7)           Bump passed stack slot
         BCT   #1,MVBPUT           Decrement passed value count & loop
******** B     MVBNILS             When all values passed...
MVBNILS  DS    0H                  Fill unpassed slots with NIL
         ST    #10,0(,#5)          Store NIL into requesting slot
         LA    #5,4(,#5)           Bump requesting-slot pointer
         BCT   #2,MVBNILS          Loop until requestor count exhausted
         B     DONOVALS            Then go to return immediate value
         SPACE 1
MVBINFO  DS    0H                  Return info for MULTIPLE-VALUE-BIND
         SPACE 1
*
* Put stack pointer of values slots in #0, number of values in #2
*
* The instruction following the 470B.... should be 59B0Bxxx, where
* Bxxx is the location of the stack slots where the values are to go.
*
         LH    #0,6(,#7)           Get Bxxx from 59B0Bxxx instruction
         N     #0,=X'00000FFF'     Isolate displacement
         AR    #0,#5               Add displ. to tracked stack address
         BR    #14                 Return to caller with info
         SPACE 1
MBTHROW  DS    0H                  470B8000 (THROW)
*
***********************************************************************
*                                                                     *
* When we see that we've hit a THROW, as generated by the compiler    *
* (this is why THROW has to be a special form), we must find out      *
* where we're throwing to and keep on tracking.  To do this, we must  *
* examine the THROW tag and chase the chain of CATCH frames to see    *
* where we come out.  The tracked stack, base and return registers    *
* must be "restored" in the same way as they would be when the        *
* THROW is really executed.  To do this, we duplicate the search      *
* for the THROW tag.  If the tag is not found (which will cause an    *
* error to be signalled later on), we just come back as if no         *
* values are being requested.                                         *
*                                                                     *
* Is the tag available at run time?  Sure is at this point, because   *
* the only way we could have gotten this far is in the case of        *
* (THROW tag (multiple-value-returning-form)), at which point the     *
* tag has already been evaluated, as you can see.                     *
*                                                                     *
***********************************************************************
*                                                                     *
* The code sequence for THROW looks something like this:              *
*                                                                     *
*   --- evaluate tag and store into xxx(,#11) ---                     *
*   --- evaluate possible-multiple-value-returning-form ---           *
*   --- result from above set up to go into #15 ---                   *
*        BC    0,0(11,8)     470B8000 NOP to signify THROW            *
*        L     #1,xxx(,#11)  5810Bxxx Load tag into #1                *
*        LR    #2,#15        182F     Load return value into #2       *
*        L     #15,ZLCTHROW           Get address of ZILTHROW         *
*        BR    #15                    Go to ZILTHROW                  *
*                                                                     *
***********************************************************************
*                                                                     *
* #7 -> 470B8000,5810Bxxx
*
         LH    #1,6(,#7)           Get B2D2 of stack location of tag
         N     #1,=X'00000FFF'     Isolate displacement
         L     #1,0(#1,#5)         Load tag from stack location
         L     #2,ZLCCATCH         Get pointer to current catch frame
TAGLOOP  DS    0H
         LTR   #2,#2               If no more catch frames are active
         BZ    NO                  then tag not found, assume no MV's
         USING CATCH,#2
         C     #1,CATCHTAG         If tag matches
         BE    GOTCATCH            then we found the catch to process
         L     #2,CATCHLNK         Else get previous catch frame
         B     TAGLOOP             and continue.
GOTCATCH DS    0H                  We have the catch frame...
         LM    #5,#6,CATCHS11      "Restore" tracked stack and base reg
         L     #7,CATCHRET         "Restore" tracked return address
         B     CONTINUE            Continue scanning for MV's
         SPACE 1
MBBRANCH DS    0H                  4700 or 47F0
         SPACE 1
*                                  First determine the base register.
*                                  Assert #2 = X'000000xx'
         IC    #2,2(,#7)           Get b2xx into low-order byte
         SRL   #2,4                Set to base register number
         LR    #1,#6               Load tracked base register
         CH    #2,#SFT+8*12+6      If base register = 12
         BE    BBUPDATE            then OK, use base as is
         CH    #2,#SFT+8*7+6       If base register = 7
         BE    BB7                 then set base
         CH    #2,#SFT+8*6+6       If base register = 6
         BE    BB6                 then set base
         CH    #2,#SFT+8*5+6       If base register = 5
         BE    BB5                 then set base
         CH    #2,#SFT+8*4+6       If base register = 4
         BE    BB4                 then set base
         B     NO                  Else branch to unknown, answer = no
         SPACE 1
BB7      DS    0H                  Branch to somewhere off register 7
         SPACE 1
         LA    #1,4095(,#1)        Assume using 12-base plus 4095
         STC   #1,ZLCDBL           Store low-order byte
         TM    ZLCDBL,X'01'        If resulting address is odd
         BNO   BBUPDATE            then
         LA    #1,1(,#1)            it's really 12-base plus 4096
         B     BBUPDATE            Go extract address
         SPACE 1
BB6      DS    0H                  Branch to somewhere off register 6
         SPACE 1
         AH    #1,=Y(2*4096)       Assume using 12-base plus 2*4K
         B     BBUPDATE            Go extract address
         SPACE 1
BB5      DS    0H                  Branch to somewhere off register 5
         SPACE 1
         AH    #1,=Y(3*4096)       Assume using 12-base plus 3*4K
         B     BBUPDATE            Go extract address
         SPACE 1
BB4      DS    0H                  Branch to somewhere off register 4
         SPACE 1
         AH    #1,=Y(4*4096)       Assume using 12-base plus 4*4K
         B     BBUPDATE            Go extract address
         SPACE 1
BBUPDATE DS    0H                  #1 is the base address
*
* Update the code register, check it, and follow the code.
*
         SPACE 1
         LH    #2,2(,#7)           Get b2d2 of BC (Cxxx)
         N     #2,=X'00000FFF'     Isolate displacement
         AR    #2,#1               Get new code address
         CR    #2,#7               If address not after tracked address
         BNH   NO                  then backward branch, answer is no
*
* A valid forward branch.  Now we either continue, if it was 47F0,
* or follow through with UNWIND-PROTECT check, if it was 4700.
*
         CLI   1(#7),X'00'         If it was 4700
         BE    UWPCHECK            then check UWP
         LR    #7,#2               Else load new code tracking address
         B     CONTINUE            Continue from new address
         SPACE 1
UWPCHECK DS    0H                  #2 -> instruction following cleanup
*
* The instruction following the cleanup form is expected to be a load
* of register 15 from the stack, if multiple values are possible.
* If it is anything else, values are not being returned from the
* protected form.  Note that this is an unusual case in that the load
* of #15 indicates MAYBE rather than NO!
*
         CLI   0(#2),X'58'         If not a LOAD of 15,
         BNE   NO                  then answer is NO
         TM    1(#2),X'F0'
         BNO   NO
         LA    #7,4(,#2)           Else continue with instr. past LOAD
         B     CONTINUE            Continue from new address
         SPACE 1
         EJECT
MBMV59   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Opcode is:                                                          *
*                                                                     *
*        X'59' C                                                      *
*                                                                     *
* Format:      opcd r1 i2 b2 d2d2d2                                   *
*                                                                     *
* Rule:                                                               *
*                                                                     *
*  This may be one of the multiple value sentinels:                   *
*                                                                     *
*     59B0....                                                        *
*                                                                     *
*  If it is, go to handle that case specifically.                     *
*                                                                     *
*  Otherwise, treat like a normal RX instruction.                     *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   1(#7),X'B0'         If it's 59B0....
******** BE    MB59B0              then go to handle 59B0
         BNE   MBRX                else handle like normal RX instr
         SPACE 1
MB59B0   DS    0H                  59B0.... - MULTIPLE-VALUE-LIST
*
***********************************************************************
*                                                                     *
* 59B0Bxxx indicates that a list of all the passed values must be     *
* consed up.                                                          *
* Bxxx is the location of the stack slot where the list is to go.     *
*                                                                     *
***********************************************************************
*
         LTR   #0,#0               If #0 is negative
         BNM   MB59NI              then (return info only)
         LH    #0,2(,#7)            get Bxxx from 59B0Bxxx instruction
         N     #0,=X'00000FFF'      isolate displacement
         L     #2,#SFWM1            set #2 to -1
         BR    #14                  and return with info
MB59NI   DS    0H                  Else actually set the values
         LH    #1,2(,#7)           Get Bxxx from 59B0Bxxx instruction
         N     #1,=X'00000FFF'     Isolate displacement
         AR    #5,#1               Add displ. to tracked stack address
MB59VALS DS    0H
         LTR   #1,#4               Number of values on stack
         BNZ   MB59NZ              If zero, then...
         ST    #10,0(,#5)           store NIL as list of m. values
         LR    #15,#10              set immed. return value to NIL
         BR    #14                  and return
MB59NZ   DS    0H                  Else prepare to cons a list of vals
         LR    #0,#3               Pointer to values on stack
         SLA   #1,2                Convert # of values to index
         AR    #1,#0               Get pointer to top of stack
         LA    #0,12(,#1)          3 more stack slots for saving
         #ZPDS (0)                 Check for stack overflow
         STM   #11,#12,0(#1)       Save the usual registers
         ST    #14,8(,#1)
         BALR  #15,0               Set up new local base register
NEWUSING B     AROUND-*(,#15)      Set up fake header for CONS to see
         DC    YL1(AROUND-*-1)
         DC    C'ZILVALS &SYSDATE &SYSTIME '
AROUND   DS    0H
         LR    #12,#15             Give us a real base register
         LR    #11,#1              Save that there stack pointer
         DROP  #15
         USING NEWUSING,#12
         OI    ZLCGCFLG,ZLCGCBLD   Tell CONS that #0 has good value
         LR    #15,#10             Initialize list to NIL
         LR    #6,#11
CONSLOOP DS    0H
         SH    #6,=H'4'            Point to last value on stack
         L     #1,0(,#6)           Arg 1 to CONS = value
         LR    #2,#15              Arg 2 to CONS = list so far
         L     #15,ZLCCONS         Get address of ZILCONS
         #BASR #14,#15             Call ZILCONS
         CR    #6,#3               Loop until we hit bottom
         BH    CONSLOOP
         ST    #15,0(,#5)          Store list of values in the place
         NI    ZLCGCFLG,255-ZLCGCBLD Turn off special consing flag
         SPACE 1
         DROP  #12
         LR    #1,#11              Return sequence...
         LM    #11,#12,0(#1)       Restore the usual registers
         L     #14,8(,#1)
         L     #15,0(,#3)          Load first value from stack
         BR    #14                 and return with it.
         SPACE 1
         USING ZILVALS,#15
         EJECT
MBMV18   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Opcode is:                                                          *
*                                                                     *
*        X'18' LR                                                     *
*                                                                     *
* Format:      opcd r1 r2                                             *
*                                                                     *
* Rule:                                                               *
*                                                                     *
*  This may be the start of a function return sequence:               *
*                                                                     *
*     181B 98BC1... 58E01... 07FE                                     *
*                                                                     *
*  or:                                                                *
*                                                                     *
*     181B 58E01... 98BC1... 07FE                                     *
*                                                                     *
*  If it is one of these, go to handle that case specifically.        *
*                                                                     *
*  Otherwise, treat like a normal LR instruction.                     *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   1(#7),X'1B'         If it's "LR 1,11"
         BNE   MBRR                then
         L     #1,2(,#7)            get next 4 bytes of instructions
         N     #1,=X'FFFFF000'      mask out variable part
         C     #1,=X'98BC1000'      If it's "LM 11,12,xxx(1)"
         BE    MB111214             then go process 98BC...., 58E0....
         C     #1,=X'58E01000'      If it's "L 14,xxx(1)"
         BE    MB141112             then go process 58E0...., 98BC....
         B     MBRR                 else processs like normal RR instr
MB111214 DS    0H
*
* At this point we could assume the rest is OK.  But to make sure...
*
         L     #1,6(,#7)             get next 4 bytes of instructions
         N     #1,=X'FFFFF000'       mask out variable part
         C     #1,=X'58E01000'       If it's "L 14,xxx(1)"
         BNE   MBRR                   and
         CLI   10(#7),X'07'            next instruction is "BR 14"
         BNE   MBRR
         CLI   11(#7),X'FE'
         BNE   MBRR                   then
*
* We have a function return sequence.  Update the stack pointer,
* the base register and the return register, and follow the code.
*
         LR    #2,#5               Save tracked stack pointer
         LH    #1,4(,#7)           Get b2d2 of LM (1xxx)
         N     #1,=X'00000FFF'     Isolate displacement
         L     #5,0(#1,#2)         Update tracked stack pointer
*                                  by loading it from stack + displ
         L     #6,4(#1,#2)         Update tracked base register
*                                  by loading it from stack + displ + 4
         LH    #1,8(,#7)           Get b2d2 of "L 14, xxx(1)" instr.
         N     #1,=X'00000FFF'     Isolate displacement
         L     #7,0(#1,#2)         Update tracked return address
*                                  by loading it from stack + displ
         N     #7,=X'7FFFFFFF'     Clear high-order bit of address
         B     CONTINUE            Continue from new address
         SPACE 1
MB141112 DS    0H
*
* At this point we could assume the rest is OK.  But to make sure...
*
         L     #1,6(,#7)             get next 4 bytes of instructions
         N     #1,=X'FFFFF000'       mask out variable part
         C     #1,=X'98BC1000'       If it's "LM 11,12,xxx(1)"
         BNE   MBRR                   and
         CLI   10(#7),X'07'            next instruction is "BR 14"
         BNE   MBRR
         CLI   11(#7),X'FE'
         BNE   MBRR                   then
*
* We have a function return sequence.  Update the stack pointer,
* the base register and the return register, and follow the code.
*
         LR    #2,#5               Save tracked stack pointer
         LH    #1,8(,#7)           Get b2d2 of LM (1xxx)
         N     #1,=X'00000FFF'     Isolate displacement
         L     #5,0(#1,#2)         Update tracked stack pointer
*                                  by loading it from stack + displ
         L     #6,4(#1,#2)         Update tracked base register
*                                  by loading it from stack + displ + 4
         LH    #1,4(,#7)           Get b2d2 of "L 14, xxx(1)" instr.
         N     #1,=X'00000FFF'     Isolate displacement
         L     #7,0(#1,#2)         Update tracked return address
*                                  by loading it from stack + displ
         N     #7,=X'7FFFFFFF'     Clear high-order bit of address
         B     CONTINUE            Continue from new address
         EJECT
MBRR     DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Opcode is one of the following:                                     *
*                                                                     *
*        X'10' LPR                                                    *
*        X'11' LNR                                                    *
*        X'12' LTR                                                    *
*        X'13' LCR                                                    *
*        X'14' NR                                                     *
*        X'15' CLR                                                    *
*        X'16' OR                                                     *
*        X'17' XR                                                     *
*        X'18' LR - if not a function return sequence                 *
*        X'19' CR                                                     *
*        X'1A' AR                                                     *
*        X'1B' SR                                                     *
*        X'1E' ALR                                                    *
*        X'1F' SLR                                                    *
*                                                                     *
* Format:      opcode r1,r2                                           *
*                                                                     *
* Rule:                                                               *
*                                                                     *
*  If r1 is 15, that's a set or use of #15, so no MV's returned.      *
*  If r2 is 15, that's a use of #15, so no MV's returned.             *
*  Otherwise, this affects nothing, so continue.                      *
*                                                                     *
* Notes:                                                              *
*                                                                     *
*  X'18FF' ("LR 15,15") may be used by the compiler when the form     *
*  (VALUES <form>) is used to force return of exactly one value.      *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    1(#7),X'F0'         If it's rrFx
         BO    NO                  then answer is no
         TM    1(#7),X'0F'         If it's rrxF
         BO    NO                  then answer is no
         B     BUMP2               Otherwise continue
         EJECT
MBRX     DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Opcode is one of the following:                                     *
*                                                                     *
*        X'40' STH                                                    *
*        X'41' LA                                                     *
*        X'42' STC                                                    *
*        X'43' IC                                                     *
*        X'46' BCT                                                    *
*        X'48' LH                                                     *
*        X'49' CH                                                     *
*        X'4A' AH                                                     *
*        X'4B' SH                                                     *
*        X'4C' MH                                                     *
*        X'4E' CVD                                                    *
*        X'4F' CVB                                                    *
*        X'50' ST                                                     *
*        X'54' N                                                      *
*        X'55' CL                                                     *
*        X'56' O                                                      *
*        X'57' X                                                      *
*        X'58' L                                                      *
*        X'5A' A                                                      *
*        X'5B' S                                                      *
*        X'5E' AL                                                     *
*        X'5F' SL                                                     *
*        X'88' SRL                                                    *
*        X'89' SLL                                                    *
*        X'8A' SRA                                                    *
*        X'8B' SLA                                                    *
* The following are floating-point instructions.  Note that the r1    *
* field can never be X'F', by definition, so that just falls thru.    *
*        X'60' STD                                                    *
*        ...through...                                                *
*        X'7F' SU                                                     *
*                                                                     *
* Format:      opcode r1 i2 b2 d2d2d2                                 *
*                                                                     *
* Rule:                                                               *
*                                                                     *
*  If r1 is 15, that's a set or use of #15, so no MV's returned.      *
*  If i2 is 15, that's a use of #15, so no MV's returned.             *
*  If b2 is 15, that's a use of #15, so no MV's returned.             *
*  Otherwise, this affects nothing, so continue.                      *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    1(#7),X'F0'         If r1 is 15
         BO    NO                  then answer is no
         TM    1(#7),X'0F'         If i2 is 15
         BO    NO                  then answer is no
         TM    2(#7),X'F0'         If b2 is 15
         BO    NO                  then answer is no
         B     BUMP4               Otherwise continue
         EJECT
MBSI     DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Opcode is one of the following:                                     *
*                                                                     *
*        X'91' TM                                                     *
*        X'92' MVI                                                    *
*        X'94' NI                                                     *
*        X'95' CLI                                                    *
*        X'96' OI                                                     *
*        X'97' XI                                                     *
*                                                                     *
* Format:      opcode immed b1 d1d1d1                                 *
*                                                                     *
* Rule:                                                               *
*                                                                     *
*  If b1 is 15, that's a use of #15, so no MV's returned.             *
*  Otherwise, this affects nothing, so continue.                      *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    2(#7),X'F0'         If b1 is 15
         BO    NO                  then answer is no
         B     BUMP4               Otherwise continue
         EJECT
MBMASK   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Opcode is one of the following:                                     *
*                                                                     *
*        X'BD' CLM                                                    *
*        X'BE' STCM                                                   *
*        X'BF' ICM                                                    *
*                                                                     *
* Format:      opcode r1 i2 b3 d3d3d3                                 *
*                                                                     *
* Rule:                                                               *
*                                                                     *
*  If r1 is 15, that's a set or use of #15, so no MV's returned.      *
*  If b3 is 15, that's a use of #15, so no MV's returned.             *
*  Otherwise, this affects nothing, so continue.                      *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    1(#7),X'F0'         If r1 is 15
         BO    NO                  then answer is no
         TM    2(#7),X'F0'         If b3 is 15
         BO    NO                  then answer is no
         B     BUMP4               Otherwise continue
         EJECT
MBSS     DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Opcode is one of the following:                                     *
*                                                                     *
*        X'D1' MVN                                                    *
*        X'D2' MVC                                                    *
*        X'D3' MVZ                                                    *
*        X'D4' NC                                                     *
*        X'D5' CLC                                                    *
*        X'D6' OC                                                     *
*        X'D7' XC                                                     *
*        X'DC' TR                                                     *
*        X'DD' TRT                                                    *
*        X'DE' ED                                                     *
*        X'DF' EDMK                                                   *
*        X'F0' SRP                                                    *
*        X'F1' MVO                                                    *
*        X'F2' PACK                                                   *
*        X'F3' UNPK                                                   *
*        X'F8' ZAP                                                    *
*        X'F9' CP                                                     *
*        X'FA' AP                                                     *
*        X'FB' SP                                                     *
*        X'FC' MP                                                     *
*        X'FD' DP                                                     *
*                                                                     *
* Format:      opcode ll b1 d1d1d1 b2 d2d2d2                          *
*                                                                     *
* Rule:                                                               *
*                                                                     *
*  If b1 is 15, that's a use of #15, so no MV's returned.             *
*  If b2 is 15, that's a use of #15, so no MV's returned.             *
*  Otherwise, this affects nothing, so continue.                      *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    2(#7),X'F0'         If b1 is 15
         BO    NO                  then answer is no
         TM    4(#7),X'F0'         If b2 is 15
         BO    NO                  then answer is no
         B     BUMP6               Otherwise continue
         EJECT
MBSTMLM  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Opcode is one of the following:                                     *
*                                                                     *
*        X'90' STM                                                    *
*        X'98' LM                                                     *
*                                                                     *
* Format:      opcode r1 r2 b2 d2d2d2                                 *
*                                                                     *
* Rule:                                                               *
*                                                                     *
*  If r1 thru r2 includes register 15, no MV's returned.              *
*  If i2 is 15, that's a use of #15, so no MV's returned.             *
*  If b2 is 15, that's a use of #15, so no MV's returned.             *
*  Otherwise, this affects nothing, so continue.                      *
*                                                                     *
* Notes:                                                              *
*                                                                     *
*  The LM that occurs as part of a function return sequence is not    *
*  processed here.  It is handled when the "LR 1,11" (181B) is seen.  *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    2(#7),X'F0'         If b2 is 15
         BO    NO                  then answer is no
         TRT   1(1,#7),STMLMTBL    Else check register combination
         BZ    NO                  If it includes 15, answer is no
         B     BUMP4               Otherwise continue
         SPACE 1
STMLMTBL DC    256YL1(0)           Table to check STM/LM reg combos
         ORG   STMLMTBL+X'00'      00 - 0E are OK
         DC    15YL1(1)
         ORG   STMLMTBL+X'11'      11 - 1E are OK
         DC    14YL1(1)
         ORG   STMLMTBL+X'22'      22 - 2E are OK
         DC    13YL1(1)
         ORG   STMLMTBL+X'33'      33 - 3E are OK
         DC    12YL1(1)
         ORG   STMLMTBL+X'44'      44 - 4E are OK
         DC    11YL1(1)
         ORG   STMLMTBL+X'55'      55 - 5E are OK
         DC    10YL1(1)
         ORG   STMLMTBL+X'66'      66 - 6E are OK
         DC    9YL1(1)
         ORG   STMLMTBL+X'77'      77 - 7E are OK
         DC    8YL1(1)
         ORG   STMLMTBL+X'88'      88 - 8E are OK
         DC    7YL1(1)
         ORG   STMLMTBL+X'99'      99 - 9E are OK
         DC    6YL1(1)
         ORG   STMLMTBL+X'AA'      AA - AE are OK
         DC    5YL1(1)
         ORG   STMLMTBL+X'BB'      BB - BE are OK
         DC    4YL1(1)
         ORG   STMLMTBL+X'CC'      CC - CE are OK
         DC    3YL1(1)
         ORG   STMLMTBL+X'DD'      DD - DE are OK
         DC    2YL1(1)
         ORG   STMLMTBL+X'EE'      EE is OK
         DC    1YL1(1)
         ORG
         EJECT
MBBALR   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Opcode is one of the following:                                     *
*                                                                     *
*        X'05' BALR                                                   *
*        X'06' BCTR                                                   *
*        X'0D' BASR                                                   *
*                                                                     *
* Format:      opcode r1,r2                                           *
*                                                                     *
* Rule:                                                               *
*                                                                     *
*  If r1 is 15, that's a reset of #15, so no MV's returned.           *
*  If r2 is zero, no branch takes place, so keep going.               *
*  Otherwise, this is a branchout, so no MV's returned.               *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    1(#7),X'F0'         If it's 05FX
         BO    NO                  then answer is no
         TM    1(#7),X'0F'         If it's 05X0
         BZ    BUMP2               then continue
         B     NO                  Otherwise answer is no
         EJECT
MBBCR    DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Opcode is one of the following:                                     *
*                                                                     *
*        X'07' BCR                                                    *
*                                                                     *
* Format:      opcode c1,r2                                           *
*                                                                     *
* Rule:                                                               *
*                                                                     *
*  If c1 is 15, that's an unconditional branch, so no MV's returned.  *
*  (An unconditional BR 14 that is found as part of a function return *
*   sequence won't be uncovered here, so it needn't be considered.)   *
*  If c1 is 0, this is a NOPR, so continue.                           *
*  If r2 is 0, this is a NOPR, so continue.                           *
*  If r2 is 15, that's a strange use of #15, so no MV's returned.     *
*  Otherwise, this is a conditional branch to strange location,       *
*  so continue.                                                       *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    1(#7),X'F0'         If c1 is 15 (07Fx)
         BO    NO                  then answer is no
*                                  If c1 is 0  (070x)
         BZ    BUMP2               then continue
         TM    1(#7),X'0F'         If r2 is 0  (07x0)
         BZ    BUMP2               then continue
*                                  If r2 is 15 (07xF)
         BO    NO                  then answer is no
         B     BUMP2               Otherwise continue
         EJECT
MBSVC    DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Opcode is one of the following:                                     *
*                                                                     *
*        X'0A' SVC                                                    *
*                                                                     *
* Format:      opcode i1                                              *
*                                                                     *
* Rule:                                                               *
*                                                                     *
*  If i1 is 97, this is a TSO TEST breakpoint.  Beware.               *
*  Otherwise, no multiple values being returned.                      *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   1(#7),97            If i1 is not 97 (0A61)
         BNE   NO                  then answer is no
         LR    #6,#0               Else save system registers
         LR    #7,#15
         LA    #1,TESTWARN
         LA    #0,L'TESTWARN
         TPUT  (1),(0),R           Warn TSO user
         LR    #0,#6               Restore system registers
         LR    #15,#7
         B     NO                  Assume no MV's
         SPACE 1
TESTWARN DC    C'*** ZILVALS encountered TSO TEST breakpoint.  AssumingX
                that multiple values have NOT been requested. ***'
         EJECT
BUMP2    DS    0H                  Keep going after 2-byte opcode
         LA    #7,2(,#7)           Bump to next sequential instruction
         B     OPLOOP              Continue
BUMP4    DS    0H                  Keep going after 4-byte opcode
         LA    #7,4(,#7)           Bump to next sequential instruction
         B     OPLOOP              Continue
BUMP6    DS    0H                  Keep going after 6-byte opcode
         LA    #7,6(,#7)           Bump to next sequential instruction
         B     OPLOOP              Continue
         EJECT
NO       DS    0H                  Here if no multiple values requested
         SPACE 1
         LTR   #0,#0               If requesting info only,
         BZ    DONOVALS            then...
         XR    #0,#0                set MV stack pointer to zero
         LA    #2,1                 set # of values needed to 1
         BR    #14                  and return with that info
         SPACE 1
DONOVALS DS    0H                  Here when must return normal value
*
* Since we are supposed to process the multiple values but there are
* no MV requestors, we simply return the first value in register 15
* (which we would do whether there were MV's to be processed or not).
*
         LTR   #4,#4               If no values to return ("(VALUES)")
         BNZ   RETVAL1             then
         LR    #15,#10              return NIL as the single value
         BR    #14
RETVAL1  DS    0H                  Else...
         L     #15,0(,#3)          load first value from stack
         BR    #14                 and return with it.
         EJECT
ONLYRET  DS    0H
*
***********************************************************************
*                                                                     *
* Here when #0 is positive, meaning that we already know that         *
* multiple values must be returned and where and how to return        *
* them.  #2 is number of slots to put values in (-1 if list needed).  *
*                                                                     *
* #3 and #4 better be set up right.                                   *
*                                                                     *
***********************************************************************
*
         LR    #5,#0               Where to put values
         LR    #0,#1               Current stack pointer
         LTR   #2,#2               If #2 is negative
         BM    MB59VALS            then prepare to return a list
         B     MB47VALS            else prepare to stick 'em on stack
         EJECT
         LTORG
         EJECT
*
***********************************************************************
*                                                                     *
* This DSECT must match the same one in ZILTHROW.  Exactly!!!         *
*                                                                     *
***********************************************************************
*
CATCH    DSECT ,                   THIS MAPS THE CATCH FRAME
         SPACE 1
CATCHLNK DS    A                   +00 ADDRESS OF PREVIOUS CATCH FRAME
CATCHS11 DS    A                   +04 ADDRESS OF STACK (SAVED #11)
CATCHS12 DS    A                   +08 BASE REGISTER (SAVED #12)
CATCHRET DS    A                   +0C RETURN ADDRESS AFTER FORMS
CATCHSAL DS    A                   +10 ADDRESS OF SAVED SPECIAL ALIST
CATCHFAL DS    A                   +14 ADDRESS OF SAVED FLUID ALIST
CATCHTAG DS    A                   +18 THE CATCH TAG (0 FOR UWP)
CATCHCLN DS    A                   +1C ADDRESS OF CLEANUP FORMS CODE
CATCHVAL DS    A                   +20 RETURN VALUE SAVED DURING CLNUP
         EJECT
         #ZEQU
         EJECT
         #ZCOM
         EJECT
         #ZSFT
         EJECT
         END
