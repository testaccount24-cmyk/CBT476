         TITLE 'ZDREAD - BUILT-IN ZIL 1.3 SUBROUTINE'
***********************************************************************
*                                                                     *
* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *
*                     All rights reserved.                            *
*                                                                     *
***********************************************************************
*                                                                     *
* ZDREAD is the ZIL "default reader", called by READ, TYI, TYIPEEK,   *
* and many other routines.                                            *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
* ZDREAD takes 6 arguments:                                           *
*                                                                     *
* arg 1 = the file to read from.                                      *
* arg 2 = a fixnum built from the boolean values listed below.        *
* arg 3 = miscellaneous function-dependent data (e.g. char operand).  *
* arg 4 = eof-error-p.                                                *
* arg 5 = eofval.                                                     *
* arg 6 = recursive-p.                                                *
*                                                                     *
* Arg 2 values are made up from the following bit settings:           *
*                                                                     *
*  00000000  =  Read an S-expression (READ)                           *
*  .....001  =  Read a character (TYI)                                *
*  .....010  =  Unread a character (UNTYI)                            *
*  .....011  =  Peek a character (TYIPEEK)                            *
*  .....100  =  Intern a character (READCH)                           *
*  .....110  =  Intern a character (PEEKCH)                           *
*  ....1...  =  EOF request                                           *
*  ...1....  =  EOL (newline) request                                 *
*  ..1.....  =  1 = set EOF/EOL, 0 = test EOF/EOL                     *
*  .1......  =  Read a line of data (READLINE)                        *
*  1.......  =  Readtable functions                                   *
*  1......1  =  Set reader macro                                      *
*  1.....1.  =  Set MACLISP readtable                                 *
*  1....1..  =  Return reader macro character                         *
*                                                                     *
* Sample calling sequence:                                            *
*                                                                     *
*  (defun read (&optional file eoferp eofval recurp)                  *
*         (zcread file #b0000000 nil eoferp eofval recurp))           *
*                                                                     *
* There are many others, not listed here.  Note that even the one     *
* above may not be the one in use in the present ZIL, depending on    *
* whether we want the Maclisp READ or the Common Lisp READ.           *
*                                                                     *
***********************************************************************
*                                                                     *
* Change activity:                                                    *
*                                                                     *
* 02/28/90 - Fixed GC errors by setting ZLCGCBLD flag.                *
*                                                                     *
***********************************************************************
         SPACE 1
MODEB3   EQU   ##CDR+3
BTYI     EQU   B'00000001'         1 = TYI/TYIPEEK, 0 = READ
BPEEK    EQU   B'00000010'         1 = peek request
BINTERN  EQU   B'00000100'         1 = READCH/PEEKCH, 0 = TYI/TYIPEEK
BEOF     EQU   B'00001000'         1 = EOF request
BEOL     EQU   B'00010000'         1 = EOL (newline) request
BSET     EQU   B'00100000'         1 = set EOF/EOL, 0 = test EOF/EOL
BREADLIN EQU   B'01000000'         1 = READLINE
BRM      EQU   B'10000000'         1 = Readtable functions
BRMBITS  EQU   B'01111111'         Other bits used with readtable funx
BRMSRM   EQU   B'00000001'         1 = set reader macro
BRMMACRT EQU   B'00000010'         1 = set MACLISP readtable
BRMCHAR  EQU   B'00000100'         1 = return reader macro character
         SPACE 1
ZDREAD   #ZBEG MINARGS=6,MAXARGS=6,NAME='ZDREAD',SUBRS=ZILSUBR
         #ZPDS 60
         #ZSAV ,
*
* If arg 1 is a symbol, then assume that it is an input file and
* process it accordingly.  Otherwise, assume that it is a "stream"
* (in whatever format that may be) and pass control to ZCREXEC to
* handle the stream operation.
*
         L     #7,0(,#11)          Get arg 1
         CLI   ##TYPE(#7),##SYMBOL If file argument is not a symbol
         BNE   ZDSTREAM            then must be a stream, process so
*                                  Else must be an input file...
*                                  This sets #7 based on 0(,#11)
         #IFIL 1                   Arg 1 = input file spec
         SPACE 1
         L     #2,4(,#11)          Get arg 2
         TM    MODEB3(#2),BRM      If readtable bit is on
         BO    DOREADTB            then process readtable requests
         CLI   MODEB3(#2),0        If all bits are off
         BE    DOREAD              then process READ request
         TM    MODEB3(#2),BTYI     If TYI/TYIPEEK bit is on
         BO    DOTYI               then process TYI/TYIPEEK request
         TM    MODEB3(#2),BINTERN  If READCH/PEEKCH bit is on
         BO    DOINTERN            then process READCH/PEEKCH request
         TM    MODEB3(#2),BPEEK    If PEEK but not TYI
         BO    DOUNTYI             then process UNTYI request
         TM    MODEB3(#2),BEOF     If EOF bit is on
         BO    DOEOF               then process EOF set/test request
         TM    MODEB3(#2),BEOL     If EOL bit is on
         BO    DOEOL               then process EOL set/test request
         TM    MODEB3(#2),BREADLIN If READLINE bit is on
         BO    DOREADLI            then process READLINE request
         B     UNKNOWN             else unknown
         EJECT
DOREAD   DS    0H                  This is READ
         #BAS  #14,CKRDTBL         Initialize read table if necessary
         L     #0,0(,#11)
         ST    #0,36(,#11)         Arg 1 = file
         L     #0,8(,#11)
         ST    #0,40(,#11)         Arg 2 = preserving-whitespace-p
         L     #0,12(,#11)
         ST    #0,44(,#11)         Arg 3 = eof-error-p
         L     #0,16(,#11)
         ST    #0,48(,#11)         Arg 4 = eofval
         L     #0,20(,#11)
         ST    #0,52(,#11)         Arg 5 = recursive-p
         L     #15,=A(ZILREAD)     Get address of ZILREAD
         LA    #1,36(,#11)         Point to args
         B     BASR1415            Go to call it.
         EJECT
DOTYI    DS    0H                  This is TYI or TYIPEEK
         TM    MODEB3(#2),BPEEK    If PEEK bit is off
         BO    DOTYIPK             then
         L     #15,=A(ZILTYI)       get address of ZILTYI
         B     BASR1415             go to call it
DOTYIPK  DS    0H                  Else peeking...
*
* Because (TYIPEEK T ...) needs to check whitespacity of characters,
* the readtable may be necessary.
*
         #BAS  #14,CKRDTBL          Initialize read table if necessary
         L     #15,=A(ZILTYIPK)     get address of ZILTYIPK
         B     BASR1415             go to call it
         SPACE
DOUNTYI  DS    0H                  This is UNTYI
         L     #15,=A(ZILUNTYI)    Get address of ZILUNTYI
         B     BASR1415            go to call it
         SPACE
DOINTERN DS    0H                  This is READCH or PEEKCH
         TM    MODEB3(#2),BPEEK    If PEEK bit is off
         BO    DOPEEKCH            then
         L     #15,=A(READCH)       get address of READCH
         B     BASR1415             go to call it
DOPEEKCH DS    0H                  Else peeking...
         L     #15,=A(PEEKCH)       get address of PEEKCH
         B     BASR1415             go to call it
         SPACE
DOREADLI DS    0H                  READLINE request
         L     #15,=A(READLINE)
         B     BASR1415            Go to call it.
         SPACE
DOEOF    DS    0H                  This is EOF or QUIT
         TM    MODEB3(#2),BSET     If set bit is off
         BO    DOSETEOF            then
*
* EOF - return TRUE or FALSE depending on whether EOF has been reached
*
         TM    ZLFFLAG,ZLFEOF      Test EOF flag
         BZ    FALSE               If off, not EOF
         B     TRUE                If on, EOF
DOSETEOF DS    0H                  Else set EOF...
*
* QUIT - force EOF on the file
*
         OI    ZLFFLAG,ZLFEOF      Set EOF flag
         B     FALSE               Return NIL
         SPACE
DOEOL    DS    0H                  This is NEWLINEP or ENDREAD
         TM    MODEB3(#2),BSET     If set bit is off
         BO    DOSETEOL            then
*
* NEWLINEP - return TRUE or FALSE depending on if EOL has been reached
*
         TM    ZLFFLAG,ZLFNEWLN    Test newline flag
         BZ    FALSE               If off, not newline
         B     TRUE                If on, newline
DOSETEOL DS    0H                  Else set newline...
*
* ENDREAD - force next line to be read.  This isn't really the same as
*           setting NEWLINE.  But it sort of fits with the bit setting
*           configurations for ZCREAD/ZDREAD, so here it is.
*
         NI    ZLFFLAG2,255-ZLFTGT12 Reset incomplete-TGET indicator
         XR    #3,#3
         BCTR  #3,0
         ST    #3,ZLFCHAR          Force newline condition on file
         B     FALSE               Return NIL
         SPACE
DOREADTB DS    0H                  This is RMINIT or something
         TM    MODEB3(#2),BRMBITS  If all other bits are off
         BZ    DORMINIT            then this is an initialization
         TM    MODEB3(#2),BRMSRM   If set-reader-macro bit is on
         BO    DORDRMAC            then this is set-reader-macro
         TM    MODEB3(#2),BRMMACRT If set-maclisp-reader bit is on
         BO    DORMMAC             then set MACLISP readtable
         TM    MODEB3(#2),BRMCHAR  If reader-macro-character bit on
         BO    DORMCHAR            then return reader macro character
         B     UNKNOWN             Else we don't know what it is yet
DORMINIT DS    0H                  Else RMINIT request...
         L     #15,@ZRMINIT        Get address of ZRMINIT
         B     BASR1415            Go to call it.
DORDRMAC DS    0H                  RDRMACRO request...
         #BAS  #14,CKRDTBL         Initialize read table if necessary
         L     #15,=A(RDRMACRO)    Get address of RDRMACRO
         B     BASR1415            Go to call it.
DORMMAC  DS    0H                  Else RMMAC request...
         #BAS  #14,CKRDTBL         Initialize read table if necessary
         L     #4,ZLCRDTBL         Get read table address
         MVI   C'/'(#4),##ESCAPE   Set syntax of slash like backslash
         MVI   C'\'(#4),##NORMAL   Set normal syntax for backslash
         B     FALSE               Return NIL
DORMCHAR DS    0H                  RMCHAR request...
         #BAS  #14,CKRDTBL         Initialize read table if necessary
         L     #15,=A(RMCHAR)      Get address of RMCHAR
         B     BASR1415            Go to call it.
         SPACE
UNKNOWN  DS    0H
         #ERR  'Unknown ZDREAD request, code ',4(#11)
         SPACE
FALSE    DS    0H                  Come here to return FALSE
         LR    #15,#10             Set return value to NIL
         B     RETURN
         SPACE
TRUE     DS    0H                  Come here to return TRUE
         LR    #15,#8              Set return value to T
         B     RETURN
         SPACE
ZDSTREAM DS    0H                  Here if arg1 not a "file"
         SPACE 1
         LM    #14,3,0(#11)        Args 1-6
         STM   #14,3,36(#11)       Store on stack
         ICM   #15,15,@ZCREXEC     Get address of ZCREXEC
         BZ    LOADZCR             If zero, not loaded yet
         LA    #1,36(,#11)         Point to args
******** B     BASR1415            Go to call it.
         SPACE 1
BASR1415 DS    0H                  Come here to call a subroutine
         #BASR #14,#15             Call whatever you put in #15
******** B     RETURN              and return with its result value(s)
         SPACE
RETURN   DS    0H                  Return to caller
         SPACE 1
         #ZRET ,
         SPACE 1
LOADZCR  DS    0H                  Here when ZCREXEC isn't loaded yet
         SPACE 1
         LA    #1,SZCREXEC         Address of "ZCREXEC" name
         ST    #1,36(,#11)         Store on stack
         L     #15,@ZILLOAD        Get address of ZILLOAD
         LA    #1,36(,#11)         Point to args
         #BASR #14,#15             Call ZILLOAD to load ZCREXEC
         XR    #1,#1               Clear insert register
         CR    #15,#10             If module could not be loaded
         BE    ERRLOAD             then error - load failure
         ICM   #1,7,##CAR+1(#15)   Else get address of compiled code
         ST    #1,@ZCREXEC         Store it into our address constant
         B     ZDSTREAM            Go to retry
         SPACE 1
SZCREXEC DC    YL1(##STRING),AL3(8),CL8'ZCREXEC '    String "ZCREXEC"
         SPACE 1
ERRLOAD  DS    0H
         #ERR  PREFIX=NO,                                              X
               'ZIL1015 Unable to load ZCREXEC, stream operations imposX
               sible.'
         EJECT
CKRDTBL  DS    0H                  Routine to check for read table
*
* If no read table exists yet, create it.
* This also insures the existence of the ZIL work area.
* Note that ZRMINIT alters only registers 15,0,1,and 2.
*
         ICM   #15,15,ZLCRDTBL     Get address of read table
         BNZR  #14                 If it's there, OK
         L     #15,@ZRMINIT        If not, allocate one
         BR    #15                 Call ZRMINIT to initialize table
*                                  and return via #14
         SPACE 1
*
* The adcon for ZCREXEC is not within the ZILSUBRS area because it
* is loaded on demand, not resolved at linkedit time.
*
@ZCREXEC DC    A(0)                ADDRESS OF ZCREXEC
         SPACE 1
ZILSUBRS DS    0A                  EXTERNAL SUBROUTINES
@ZRMINIT DC    V(ZRMINIT)          ADDRESS OF ZRMINIT
         DC    CL8'ZRMINIT'
@ZILLOAD DC    V(ZILLOAD)          ADDRESS OF ZILLOAD
         DC    CL8'ZILLOAD'
ZILSUBRE DS    0A                  END OF SUBROUTINES
         SPACE
*                                                                     *
*               0(#11) --> arg3    misc. function-dependent data
*               4(#11) --> arg4    eof-error-p
*               8(#11) --> arg5    eofval
*              12(#11) --> arg6    recursive-p
*                                                                     *
         SPACE
         DROP  #12
         SPACE
         LTORG
         EJECT
*
***********************************************************************
*                                                                     *
* ZILREAD - This code is taken from the original ZIL "READ" module.   *
* #7 contains the file pointer on entry.  The arguments on the stack  *
* are as in the following pseoducall:                                 *
*                                                                     *
* (zilread file whitespace-p eof-error-p eofval recursive-p)          *
*                                                                     *
***********************************************************************
*                                                                     *
* This isn't quite Common LISP READ yet.  First of all, the syntax    *
* for READ in Common LISP is:                                         *
*                                                                     *
* (defun read                                                         *
*        (&optional input-stream eof-error-p eof-value recursive-p)...*
*                                                                     *
* whereas this READ currently uses the Maclisp syntax                 *
*                                                                     *
* (defun read (&optional file eofval) ...                             *
*   which maps into, kind of,                                         *
* (zilread nil nil eofval nil) as a default mode of operation.        *
*                                                                     *
* Second of all, this READ doesn't handle packages yet, which is to   *
* say that it doesn't do anything different about colons, among other *
* things.                                                             *
*                                                                     *
* Third of all, this READ treats # as a terminating macro rather      *
* than a non-terminating macro.  The current architecture of the      *
* read table does not have any way of representing a non-terminating  *
* reader macro.                                                       *
*                                                                     *
***********************************************************************
*                                                                     *
*               0(#11) --> arg1    file, needed by reader macros      *
*               4(#11) --> arg3    T if preserving-whitespace-p       *
*               8(#11) --> arg4    eof-error-p                        *
*              12(#11) --> arg5    eofval                             *
*              16(#11) --> arg6    recursive-p                        *
*                                                                     *
*               #7 already contains the input file pointer.           *
*                                                                     *
***********************************************************************
         SPACE
ZILREAD  #ZBEG MINARGS=5,MAXARGS=5,NAME='ZILREAD',MAIN=NO
         #ZPDS 5*4+12  =  32       DEFINE STACK SIZE
         ST    #14,28(,#1)
         STM   #11,#12,20(#1)
         LR    #11,#1
         LR    #12,#15
         DROP  #15
         USING ZILREAD,#12
         SPACE
         TM    ZLFFLAG,ZLFEOF      IF END OF FILE ALREADY HIT
         BO    RDAFTEOF            THEN ERROR - READ AFTER EOF
         SPACE
         L     #3,ZLFCHAR          GET CURRENT CHARACTER POINTER
GOTINPUT DS    0H
         LTR   #3,#3               CHECK FOR EOF OR NEWLINE
         BP    INPUTOK             IF POSITIVE, WE HAVE GOOD STUFF
         BZ    R0EOF               IF ZERO, EOF ENCOUNTERED
******** BM    R0NEWLN             IF NEGATIVE, NEWLINE ENCOUNTERED
R0NEWLN  DS    0H                  (READ NEVER RETURNS A NEWLINE)
         #GETC ,                   READ ANOTHER CHARACTER
         B     GOTINPUT            UNTIL NO MORE NEWLINE
         SPACE
RDAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT
         L     #2,ZLFATOM
         #ERR  'ZIL2003 READ: Read after end of file ',                X
               (#2),PREFIX=NO
         SPACE
INPUTOK  DS    0H
         SPACE
         MVI   SYNFLAGS,0          CLEAR SYNTAX FLAGS
         LA    #1,32(,#11)         SET STACK POINTER
         #BAS  #14,READ1           GO GET AN S-EXPRESSION INTO #15
         ST    #3,ZLFCHAR          RESET CHARACTER POINTER
         B     R0GO(#2)            BRANCH DEPENDING ON WHAT RETURNED
R0GO     B     R0STUFF             0...WE GOT SOMETHING
         B     R0BADRP             4...RIGHT PARENTHESIS FOUND
         B     R0BADDOT            8...PERIOD FOUND
         B     R0EOF               12...EOF ENCOUNTERED
         SPACE
R0EOF    DS    0H                  NO DATA RETURNED, EOF HIT
         OI    ZLFFLAG,ZLFEOF      SET EOF FLAG ON IN FILE BLOCK
         C     #10,8(,#11)         If eof-error-p is NIL,
         BNE   R0EOFERR            then...
         L     #15,12(,#11)         set return value to eofval
         CR    #15,#13              if eofval is unsupplied &optional
         BNE   R0RETURN             then
         LR    #15,#10               set return value to nil
         B     R0RETURN
R0EOFERR DS    0H                  Else eof-error-p is true...
         L     #2,ZLFATOM          Load file atom for error message.
         #ERR  'ZIL2006 READ: End of file encountered - file ',       ,X
               (#2),PREFIX=NO
         SPACE
R0BADRP  DS    0H                  BAD RIGHT PAREN
         L     #2,ZLFATOM          Load file atom for error message.
         #ERR  'ZIL2020 READ: Unmatched right parenthesis ")" - file ',X
               (#2),PREFIX=NO
         SPACE
R0BADDOT DS    0H                  BAD PERIOD
         L     #2,ZLFATOM          Load file atom for error message.
         #ERR  'ZIL2020 READ: Period "." not in dotted pair - file ',  X
               (#2),PREFIX=NO
         SPACE
R0STUFF  DS    0H                  WE GOT SOMETHING, BUT...
         SPACE 1
         TM    SYNFLAGS,SYNERROR   IF A SYNTAX ERROR WAS FOUND
         BZ    R0RETURN            THEN...
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2001 READ: Syntax error reading file ',             X
               (#2),PREFIX=NO
         SPACE 1
R0RETURN DS    0H
         SPACE
         LR    #1,#11
         LM    #11,#12,20(#1)
         L     #14,28(,#1)
         BR    #14
         EJECT
READ1    DS    0H
         SPACE
***********************************************************************
* THIS SUBROUTINE IS THE SECOND-LEVEL READ ROUTINE.  IT RETURNS SOME  *
* S-EXPRESSION THAT IT FINDS IN THE INPUT STREAM.  THIS ROUTINE IS    *
* INVOKED RECURSIVELY.  LOGIC IS AS FOLLOWS:                          *
*   SCAN UNTIL NON-WHITESPACE CHARACTER (BLANK IS A WHITESPACE)       *
*   IF LEFT PAREN FOUND, GET READY TO START A LIST, CALL READ1 UNTIL  *
*   A RIGHT PARENTHESIS IS FOUND.  BUILD LIST FROM ATOMS FROM READ1.  *
*   IF RIGHT PARENTHESIS IS FOUND, RETURN TO CALLER WITH CODE 4.      *
*   IF PERIOD IS FOUND, RETURN TO CALLER WITH CODE 8.                 *
*   IF READER MACRO CHAR, INVOKE MACRO AND RETURN WITH ITS VALUE.     *
*   IF END OF FILE REACHED, RETURN TO CALLER WITH CODE 12.            *
*   IF ANY OTHER CHARACTER IS FOUND, BUILD AN ATOM AND RETURN WITH IT *
***********************************************************************
         SPACE
         #ZPDS 32                  MAKE SURE WE HAVE ENOUGH STACK SPACE
         L     #15,0(,#11)         PICK UP FILE SPEC
         ST    #15,0(,#1)          SAVE FILE POINTER
         ST    #14,4(,#1)          SAVE RETURN REGISTER ON STACK
         ST    #11,8(,#1)          SAVE STACK POINTER ON STACK
         LR    #11,#1              SET NEW STACK POINTER
         LR    #15,#10             INITIALIZE VALUE TO NIL
         MVI   FLAGS,X'00'         CLEAR FLAGS
         B     R1GO                SKIP OVER CHARACTER GET
         SPACE
CONTINUE DS    0H
         #GETC ,                   GET A CHARACTER
         SPACE
R1GO     DS    0H
         LTR   #6,#3               GET CURRENT CHARACTER POINTER
         BP    R1NOTEOF            IF WE GOT A CHAR, PROCESS IT
         BM    CONTINUE            IF NEWLINE, GET NEXT CHARACTER
         LA    #2,12               ELSE EOF - SET RETURN TO 12
         B     READ1RET             AND RETURN
R1NOTEOF DS    0H
         BCTR  #6,0                CONVERT FROM RELATIVE COLUMN
         A     #6,ZLFCARD          TO ABSOLUTE OFFSET IN RECORD
         L     #4,ZLCWA            SET ADDRESS OF WHERE TO PUT CHARS
         XR    #5,#5               SET LENGTH OF ATOM SO FAR
         L     #14,ZLCRDTBL        GET ADDRESS OF READ TABLE
         XR    #1,#1               CLEAR TRT REG
         XR    #2,#2               CLEAR TRT REG
         LA    #0,X'80'            SET UP TO COMPARE FOR MACRO CHAR
         TRT   0(1,#6),0(#14)      SEE WHAT KIND OF CHARACTER THIS IS
         CR    #2,#0               IF MACRO BIT WAS ON IN READTABLE
         BNL   GMACRO              THEN IT'S A MACRO CHAR, PROCESS
         B     GO(#2)              ELSE BRANCH ON CHARACTER TYPE
GO       B     GALOOP              CHARACTER THAT CAN OCCUR IN ATOM
         B     CONTINUE            BLANK
         B     GLEFTP              LEFT PARENTHESIS
         B     GRIGHTP             RIGHT PARENTHESIS
         B     GSEMI               SEMICOLON
         B     GPERIOD             PERIOD
         B     GCONT               CONTINUATION CHARACTER
         B     GESCAPE1            SINGLE ESCAPE BACKSLASH (HEX E0)
         B     GESCAPE2            DOUBLE ESCAPE VERTICAL BAR (|)
         B     GSTRING             DOUBLE QUOTE MARK (")
         EJECT
GCONT    DS    0H                  It's a line continuation character
         SPACE 1
***********************************************************************
*                                                                     *
* If the last character of a line (RECFM=F or RECFM=V) is the         *
* "continuation character" (which defaults to cent sign in the        *
* readtable), then ignore the following newline and process the       *
* characters in the next line as if it was all on one line.           *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    ZLFFLAG1,ZLFTERM    If this is from the terminal
         BO    GALOOP              then process like ordinary char
         LA    #0,1(,#6)           If address following this character
         C     #0,ZLFEND           doesn't point to end of record
         BL    GALOOP              then handle this like ordinary char
         #GETC ,                   Otherwise get next character
         LTR   #3,#3               which should be newline,
         BNM   GABEND               or else cent sign
         B     CONTINUE            and then go read the next one.
         EJECT
         SPACE
GALOOP   DS    0H                  A NORMAL ATOM
         C     #5,ZLCWALEN         IF LENGTH HAS ALREADY REACHED MAX
         BL    NOT2LONG            THEN
         #BAS  #14,INCRWA           ENLARGE THE WORK AREA
NOT2LONG DS    0H                  ELSE
         LTR   #4,#4               SKIP IF NO STORAGE WAS AVAILABLE
         BZ    RSTSLASH
         MVC   0(1,#4),0(#6)       MOVE CHARACTER TO ATOM AREA
         TM    FLAGS,INBAR+SLASHED IF NOT ESCAPED IN EITHER WAY
         BNZ   AFTASIS             THEN
         TR    0(1,#4),UPTBL        FOLD TO UPPER CASE
AFTASIS  DS    0H
         LA    #4,1(,#4)           BUMP OUTPUT POINTER
         LA    #5,1(,#5)           INCREMENT LENGTH
RSTSLASH DS    0H
         NI    FLAGS,255-SLASHED   RESET SINGLE-ESCAPE FLAG
AFT2LONG DS    0H
         #GETC ,                   GET THE NEXT CHARACTER
         LTR   #3,#3               CHECK FOR EOF OR NEWLINE
         BP    WHATISIT            IF NEITHER, PROCESS CHARACTER
         BZ    GAFINISH            IF EOF, THEN END OF ATOM
         TM    FLAGS,INBAR         IF NEWLINE, THEN IF WITHIN |  ... |
         BO    AFT2LONG            THEN SKIP OVER IT, GET NEXT CHAR
         B     GAFINISH            ELSE (NON-ESCAPED NEWLINE) END ATOM
         SPACE 1
WHATISIT DS    0H
         L     #14,ZLCRDTBL        GET ADDR OF READ TABLE TO SCAN CHAR
         TRT   0(1,#6),0(#14)      IF IT IS NOT A DELIMITER
         BZ    GALOOP              THEN CONTINUE BUILDING ATOM TEXT
         CLM   #2,1,=YL1(##PERIOD) IF IT IS A PERIOD
         BE    GALOOP              THEN IT'S A NORMAL CHAR, CONTINUE
         CLM   #2,1,=YL1(##ESCAPE) IF IT IS A BACKSLASH
         BE    GESCAPE1            THEN PROCESS SINGLE ESCAPE CHAR
         CLM   #2,1,=YL1(##BAR)    IF IT IS A VERTICAL BAR
         BE    GESCAPE2            THEN PROCESS DOUBLE ESCAPE CHAR
         CLM   #2,1,=YL1(##CONT)   IF IT IS A CONTINUATION CHARACTER
         BE    GCONT1              THEN PROCESS DOUBLE ESCAPE CHAR
* ELSE OTHER CHARACTER (PARENTHESIS, PERIOD, ETC.)
         TM    FLAGS,INBAR         IF WE'RE ALREADY WITHIN BARS
         BO    GALOOP              THEN PROCESS AS NORMAL CHARACTER
         B     GAFINISH            ELSE TERMINATE ATOM
         SPACE 1
GESCAPE1 DS    0H                   PROCESS SINGLE ESCAPE CHAR
         OI    FLAGS,NONUM          SHOW THIS CAN'T BE A NUMERIC ATOM
         #GETC ,                    READ NEXT CHARACTER FOR ATOM
         LTR   #3,#3                SEE IF EOF OR NEWLINE HIT
         BZ    ESCERROR             IF EOF, FLAG AS SYNTAX ERROR
         BP    ESCDOIT              IF NEWLINE, THEN
         LA    #6,FAKECR             SET CHAR TO FAKE CARRIAGE RETURN
ESCDOIT  OI    FLAGS,SLASHED        CAUSE THIS CHAR NOT TO BE UPCASED
         B     GALOOP               AND PROCESS AS REGULAR CHAR
         SPACE 1
GESCAPE2 DS    0H                  PROCESS VERTICAL BAR
         TM    FLAGS,INBAR         IF ALREADY WITHIN BARS
         BZ    NOTINBAR            THEN
         NI    FLAGS,255-INBAR      SET BAR MODE OFF
         B     AFT2LONG             GO TO PROCESS THE NEXT CHAR
NOTINBAR DS    0H                  ELSE NOT IN BARS YET...
         OI    FLAGS,INBAR+NONUM    INDICATE WITHIN BARS & NOT NUMERIC
         B     AFT2LONG             GO TO PROCESS THE NEXT CHAR
         SPACE 1
GCONT1   DS    0H                  It's a line continuation character
         SPACE 1
***********************************************************************
*                                                                     *
* If the last character of a line (RECFM=F or RECFM=V) is the         *
* "continuation character" (which defaults to cent sign in the        *
* readtable), then ignore the following newline and process the       *
* characters in the next line as if it was all on one line.           *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    ZLFFLAG1,ZLFTERM    If this is from the terminal
         BO    GALOOP              then process like ordinary char
         LA    #0,1(,#6)           If address following this character
         C     #0,ZLFEND           doesn't point to end of record
         BL    GALOOP              then handle this like ordinary char
         #GETC ,                   Otherwise get next character
         LTR   #3,#3                which should be newline,
         BNM   GABEND                or elsecent sign
         B     AFT2LONG            and then go read the next one.
         SPACE 1
SEOFERR  DS    0H                  NO CLOSING DELIMITER AT EOF
         ST    #3,ZLFCHAR          RESET CHARACTER POINTER
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2005 READ: Missing closing delimiter at end of file X
               ',(#2),PREFIX=NO
         SPACE 1
ESCERROR DS    0H                  ERROR - BACKSLASH FOLLOWED BY EOF
         ST    #3,ZLFCHAR          RESET CHARACTER POINTER
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2019 READ: No character following escape character -X
                file ',(#2),PREFIX=NO
         EJECT
GAFINISH DS    0H                  ELSE END OF ATOM, NOW CREATE IT
*
*** CHECK FOR STORAGE ALLOCATION FAILURE
*
         LTR   #4,#4
         BZ    AFAIL
*
*** CHECK ATOM TYPE - MAY BE NUMERIC - OR WE MAY HAVE TO BUILD SYMBOL
*** STORE CURRENT CHARACTER POINTER IN CASE WE ERROR OUT BELOW...
*
         ST    #3,ZLFCHAR          STORE CURRENT CHARACTER POINTER
         STM   #3,#7,SAVE37        SAVE VOLATILE REGS
         LR    #0,#5               SET LENGTH OF ATOM TEXT
         L     #1,ZLCWA            POINT TO AREA CONTAINING ATOM TEXT
         LR    #2,#8               SET FLAG = T TO INTERN THE ATOM
         TM    FLAGS,NONUM         IF AN ESCAPED ATOM
         BNZ   DONTFMT             THEN MUST BE SYMBOL. ELSE NOT ESCD..
         LR    #3,#8                SET FLAG = T TO FORMAT IF NUMERIC
         B     AFTFMT              IF DELIMITED...
DONTFMT  MVI   FLAGS,X'00'          TURN OFF FLAGS
         LR    #3,#10               SET FLAG = NIL TO TREAT AS SYMBOL
AFTFMT   DS    0H
         L     #15,ZLCABLD         CALL ZILABLD TO BUILD NEW ATOM
         LA    #4,12(,#11)         SET CURRENT STACK POINTER FOR CONS
         #BASR #14,#15             AND PLACE IT ON OBLIST IF SYMBOL
         LM    #3,#7,SAVE37        RESTORE VOLATILE REGS
         XR    #2,#2               SET RETURN TO 0
         B     READ1RET            RETURN TO CALLER WITH ATOM
         EJECT
GSTRING  DS    0H                  FOUND DOUBLE QUOTE "
         SPACE 1
*
* START A STRING.  READ CHARACTERS, BACKSLASHIFICATION INCLUDED,
* UNTIL ANOTHER DOUBLE QUOTE MARK IS ENCOUNTERED.  BUILD THE STRING
* DIRECTLY IN VECTOR/STRING SPACE (IF WE RUN OUT OF SPACE, SIGNAL
* AN ERROR BUT NOT UNTIL WE READ TO THE END OF THE STRING).
*
* REGISTER USAGE:
*
* #4 --> CURRENT LOCATION IN VECTOR/STRING SPACE WHERE WE'RE BUILDING
* #5 = STRING LENGTH AS WE GO
*
         L     #4,ZLCVSNXT         GET PTR TO AVAILABLE STRING SPACE
         ST    #4,VSSTRING         SAVE CURRENT STRING POINTER
STRY     DS    0H
         L     #0,ZLCVSADR         ADDR(VSSPACE)+LENGTH(VSSPACE)
         A     #0,ZLCVSLEN         GIVES POINTER TO END OF STRING SPACE
         XR    #5,#5               CLEAR STRING LENGTH SO FAR
         LA    #1,4(,#4)           POINT TO WHERE TEXT IS GONNA GO
         ST    #0,VSEND            SAVE POINTER TO END OF STRING SPACE
         CR    #1,#0               IF PAST THE END
         BL    SOK1                THEN
         #BAS  #2,SNOROOM           NO ROOM, TRY TO MAKE SOME
         LTR   #4,#4                IF STILL NO ROOM
         BZ    SLOOP                THEN READ THROUGH W/O BUILDING
         L     #4,VSSTRING          ELSE GET TRUE NEW STRING POINTER
         B     STRY                 IF SUCCESSFUL, TRY AGAIN
SOK1     DS    0H
         ST    #5,0(,#4)           ELSE CLEAR STRING PREFIX
         MVI   0(#4),##STRING      SET ATOM AND STRING TYPE BITS
         LR    #4,#1               START POINTING TO STRING AREA
SLOOP    DS    0H
         #GETC ,                   GET AN INPUT CHARACTER
         LTR   #3,#3               CHECK FOR EOF/NEWLINE
         BP    SGOTCHAR            IF OK, PROCESS THE CHARACTER
         BZ    SEOFERR             IF EOF, SIGNAL ERROR
         LA    #6,FAKECR           IF NEWLINE, POINT TO FAKE CR
         B     SCHAR               GO TO MOVE THE STRING
SGOTCHAR DS    0H
         L     #14,ZLCRDTBL        GET ADDRESS OF READ TABLE
         TRT   0(1,#6),0(#14)      CHECK WHAT KIND OF CHARACTER WE GOT
         BZ    SCHAR               IF NORMAL ONE, PROCESS IT
         CLM   #2,1,=YL1(##DQUOTE) IF A DOUBLE QUOTE
         BE    SDQUOTE             THEN PROCESS TERMINATING "
         CLM   #2,1,=YL1(##ESCAPE) IF SINGLE ESCAPE (BACKSLASH)
         BE    SBSLASH             THEN PROCESS AS ESCAPE CHARACTER
         CLM   #2,1,=YL1(##CONT)   IF CONTINUATION CHARACTER
         BE    SCONT               THEN PROCESS AS ESCAPE CHARACTER
SCHAR    DS    0H                  ELSE NORMAL CHARACTER
         C     #4,VSEND            IF WE'RE AT THE END OF VSSPACE
         BL    SOK2                THEN
         #BAS  #2,SNOROOM           NO ROOM FOR STRING RIGHT NOW
         C     #4,VSEND            IF WE'RE STILL AT THE END OF VSSPACE
         BL    SOK2                THEN
         #BAS  #2,SBOMB             PREPARE TO SIGNAL OUT-OF-SPACE
SOK2     DS    0H                   TRY TO GET SOME
         LTR   #4,#4               IF STRING CAN'T BE BUILT
         BZ    SLOOP               THEN CONTINUE WITHOUT BUILDING
         MVC   0(1,#4),0(#6)       ELSE MOVE CHAR INTO STRING SPACE
         LA    #4,1(,#4)           INCREMENT POINTER
         LA    #5,1(,#5)           INCREMENT LENGTH
         B     SLOOP               CONTINUE
         SPACE 1
SBSLASH  DS    0H                  PROCESS BACKSLASHIFIED CHARACTER
         #GETC ,                   GET THE NEXT CHARACTER
         LTR   #3,#3               CHECK FOR NEWLINE/EOF
         BZ    SEOFERR             IF EOF, SIGNAL ERROR
         BP    SCHAR               IF POSITIVE, NORMAL CHARACTER
         LA    #6,FAKECR           ELSE POINT TO FAKE CARRIAGE RETURN
         B     SCHAR               AND PROCESS AS NORMAL CHARACTER
         SPACE 1
SCONT    DS    0H                  It's a line continuation character
         SPACE 1
***********************************************************************
*                                                                     *
* If the last character of a line (RECFM=F or RECFM=V) is the         *
* "continuation character" (which defaults to cent sign in the        *
* readtable), then ignore the following newline and process the       *
* characters in the next line as if it was all on one line.           *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    ZLFFLAG1,ZLFTERM    If this is from the terminal
         BO    SCHAR               then process like ordinary char
         LA    #0,1(,#6)           If address following this character
         C     #0,ZLFEND           doesn't point to end of record
         BL    SCHAR               then handle this like ordinary char
         #GETC ,                   Otherwise get next character
         LTR   #3,#3                which should be newline,
         BNM   GABEND                or elsecent sign
         B     SLOOP               and then go read the next one.
         SPACE 1
SDQUOTE  DS    0H                  PROCESSING TERMINATING DOUBLE QUOTE
         LTR   #4,#4               IF STRING ERROR OCCURRED
         BZ    SFAIL               THEN FAIL
         L     #15,VSSTRING        ELSE POINT TO STRING WE JUST BUILT
         STCM  #5,7,1(#15)         SET STRING LENGTH
         LTR   #5,#5               IF NULL STRING
         BP    SNZERO              THEN
         LA    #4,1(,#4)            INSURE AT LEAST A FULLWORD OF SPACE
SNZERO   DS    0H
         LA    #4,3(,#4)           ROUND END-POINTER UP TO FULLWORD
         N     #4,=X'FFFFFFFC'     TO INSURE VSSPACE ALIGNMENT
         ST    #4,ZLCVSNXT         SET NEW NEXT-AVAILABLE-VSSPACE-SLOT
         #GETC ,                   PRIME READER WITH NEXT CHARACTER
         XR    #2,#2               RETURN CODE(ZERO)
         B     READ1RET            RETURN WITH SOMETHING FOUND
         SPACE 1
SFAIL    DS    0H                  FAILED TO MAKE A STRING
         #GETC ,                   PRIME READER WITH NEXT CHARACTER
AFAIL    DS    0H                  FAILED TO MAKE A SYMBOL
         ST    #3,ZLFCHAR          RESET CHARACTER POINTER
         L     #4,VSERROR          Get error message address
         L     #2,ZLFATOM          Load file atom for message
         #ERR  (#4),(#2),PREFIX=NO Signal error
         SPACE 1
SNOROOM  DS    0H                  WHAT HAPPENS IF OUT OF STRING SPACE
         SPACE 1
*
* ATTEMPT A GARBAGE COLLECTION, WHICH MAY FREE UP SOME STRING SPACE.
* THIS SHOULD CAUSE THE CURRENT SPACES TO BE FLIPPED, BUT WE WILL
* STILL BE POINTING INTO THE ORIGINAL (NOW OLD) SPACE. SO, AFTER THE
* GARBAGE COLLECTION, IF THERE'S ROOM IN THE NEW SPACE, WE MOVE THE
* STRING WE'RE BUILDING INTO THE NEW SPACE AND KEEP GOING.
*
         L     #9,ZLCGCEND         FORCE END OF FREE LIST
         ST    #2,VSSAVE2          SAVE RETURN REGISTER
         LR    #1,#10              SET DUMMY ARG 1 TO CONS = NIL
         LR    #2,#10              SET DUMMY ARG 1 TO CONS = NIL
         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS
         LA    #0,12(,#11)         SET POINTER TO (NO) ARGS ON STACK
         #BASR #14,#15             CALL CONS 2 FORCE GARBAGE COLLECTION
         L     #2,VSSAVE2          RESTORE RETURN REGISTER
         L     #0,ZLCVSADR         ADDR(NEW_VSSPACE)
         A     #0,ZLCVSLEN         + LENGTH(NEW_VSSPACE)
         S     #0,ZLCVSNXT         - ADDR(NEW_AVAILABLE_SLOT)
         CH    #0,=H'8'            ALWAYS NEED AT LEAST 8 BYTES
         BL    SBOMB               OR ELSE DIE
         LA    #15,4(,#5)          GET LENGTH OF STRING SO FAR + 4
         CR    #0,#15              COMPARE TO NEW AVAILABLE LENGTH
         BL    SBOMB               IF STILL NOT LONG ENOUGH, DIE.
         L     #14,VSSTRING        ELSE GET POINTER TO OLD STRING
         L     #0,ZLCVSNXT         GET POINTER TO NEW STRING LOC
         ST    #0,VSSTRING         SAVE IT
         LR    #1,#15              GET LENGTH TOO
         MVCL  #0,#14              MOVE STRING TO ITS NEW HOME
         LR    #4,#0               SET NEW OUTPUT POINTER
         L     #0,ZLCVSADR         ADDR(VSSPACE)+LENGTH(VSSPACE)
         A     #0,ZLCVSLEN         GIVES POINTER TO END OF STRING SPACE
         ST    #0,VSEND            SAVE NEW POINTER TO END OF SPACE
         BR    #2                  AND RETURN
SBOMB    DS    0H
         LA    #1,ZIL2022          SIGNAL "NO STRING SPACE" ERROR
         ST    #1,VSERROR
         XR    #4,#4               STOP BUILDING THE STRING
         BR    #2                  RETURN
         EJECT
GLEFTP   DS    0H                  FOUND A LEFT PARENTHESIS (
         SPACE
*
* START A LIST.  REPEATEDLY CALL READ1 RECURSIVELY, RETURNING
* AN S-EXPRESSION FOR EACH CALL AND CONSING THEM ALL TOGETHER.
* FINISH WHEN A RIGHT PARENTHESIS IS ENCOUNTERED.
*
         ST    #10,12(,#11)        INITIALIZE LIST TO NIL
         LA    #1,12-##CDR(,#11)   @ PSEUDO-CONS TO STORE THE 1ST CELL
         ST    #1,16(,#11)         SAVE POINTER TO WHERE TO PUT IT
         #GETC ,                   PRIME WITH NEXT CHARACTER
GLGO     DS    0H
         LA    #1,20(,#11)         SET STACK POINTER
         #BAS  #14,READ1           GO GET AN ELEMENT OF THE LIST
         B     R1BR(#2)            BRANCH DEPENDING ON RETURN CODE
R1BR     B     R1GOTIT             0...WE GOT SOMETHING
         B     R1ENDIT             4...RIGHT PARENTHESIS FOUND
         B     R1DOT               8...PERIOD FOUND
         B     R1EOF               12...EOF ENCOUNTERED
         EJECT
R1GOTIT  DS    0H                  READ1 RETURNED SOMETHING GOOD
         SPACE
         LR    #1,#15              ARG 1 TO CONS = WHAT READ1 FOUND
         LR    #2,#10              ARG 2 TO CONS = NIL
         L     #15,ZLCCONS         GET ADDRESS OF CONS
         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS
         #BASR #14,#15             CALL CONS TO CONTINUE BUILDING LIST
         L     #1,16(,#11)         GET PTR TO CELL TO RPLACD THIS INTO
         ST    #15,##CDR(,#1)      SAVE THIS CELL OF LIST
         ST    #15,16(,#11)        CELL TO RPLACD NEXT LIST CELL INTO
         B     GLGO                GO GET ANOTHER S-EXPRESSION
         EJECT
R1ENDIT  DS    0H                  RIGHT PAREN FOUND - END THE LIST
         SPACE
         L     #15,12(,#11)        PICK UP POINTER TO LIST
         XR    #2,#2               SET NORMAL RETURN
         B     READ1RET            THEN RETURN
         EJECT
R1DOT    DS    0H                  PERIOD FOUND - BUILD A DOTTED PAIR
         SPACE
*
* IF A DOT FOLLOWS A LEFT PARENTHESIS WITH NO INTERVENING S-EXPRESSION
* THEN FLAG AS SYNTAX ERROR AND ACCEPT IT ANYWAY.
*
         C     #10,12(,#11)        IF LIST BUILT SO FAR IS NIL
         BNE   R1DOTOK             THEN
R1DOTERR DS    0H                  SYNTAX ERROR IN DOTTED PAIR
         #ERR  1,'ZIL2009 READ: Syntax error in dotted pair',          X
               PREFIX=NO           REPORT IT BUT CONTINUE ANYWAY
         OI    SYNFLAGS,SYNERROR   AND INDICATE A SYNTAX ERROR
         SPACE 1
R1DOTOK  DS    0H
         LA    #1,20(,#11)         SET STACK POINTER
         #BAS  #14,READ1           GO GET AN ELEMENT OF THE LIST
         B     R2GO(#2)            BRANCH DEPENDING ON RETURN CODE
R2GO     B     R2GOTIT             0...WE GOT SOMETHING
         B     R1ERR               4...RIGHT PARENTHESIS FOUND
         B     R2ERR               8...PERIOD FOUND
         B     R1EOF               12...EOF ENCOUNTERED
         EJECT
R2GOTIT  DS    0H
         SPACE
*
* THIS IS AN S-EXPRESSION THAT FOLLOWS THE DOT IN A DOTTED PAIR
* PROCESS ATOM BY MAKING IT THE CDR OF THE CURRENT CONS
*
         L     #1,16(,#11)         PTR TO CELL TO RPLACD WITH THIS ONE
         ST    #15,##CDR(,#1)      PUT THIS CELL AS CDR OF PREV CELL
*
* THE NEXT THING WE SHOULD SEE IS A RIGHT PARENTHESIS.
* ANYTHING ELSE IS AN ERROR AND IS IGNORED UNTIL WE SEE THAT ) .
*
DOTCLNUP DS    0H
         LA    #1,20(,#11)         SET STACK POINTER
         #BAS  #14,READ1           GO GET AN ELEMENT OF THE LIST
         B     R3GO(#2)            BRANCH DEPENDING ON RETURN CODE
R3GO     B     R2EXTRA             0...WE GOT SOMETHING
         B     R1ENDIT             4...RIGHT PARENTHESIS FOUND
         B     R2ERR               8...PERIOD FOUND
         B     R1EOF               12...EOF ENCOUNTERED
         EJECT
R1EOF    DS    0H                  EOF IN MIDDLE OF LIST - NO GOOD
         SPACE
         ST    #3,ZLFCHAR          RESET CHARACTER POINTER
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2002 READ: Missing right paren(s) at end of file ', X
               (#2),PREFIX=NO
         SPACE
R2EXTRA  DS    0H                  EXTRA STUFF TO IGNORE UNTIL )
         SPACE
         #ERR  1,'ZIL2004 READ: Extraneous data in dotted pair',       X
               PREFIX=NO
         OI    SYNFLAGS,SYNERROR   INDICATE A SYNTAX ERROR
         B     DOTCLNUP            KEEP LOOKING FOR RIGHT PAREN
         SPACE
R2ERR    DS    0H                  EXTRA DOT IN DOTTED PAIR - NO GOOD
         SPACE
         #ERR  1,'ZIL2009 READ: Syntax error in dotted pair',          X
               PREFIX=NO
         OI    SYNFLAGS,SYNERROR   INDICATE A SYNTAX ERROR
         B     DOTCLNUP            KEEP LOOKING FOR RIGHT PAREN
         SPACE
R1ERR    DS    0H
         ST    #3,ZLFCHAR          RESET CHARACTER POINTER
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2009 READ: Syntax error in dotted pair - file ',    X
               (#2),PREFIX=NO
         EJECT
GRIGHTP  DS    0H                  FOUND A RIGHT PARENTHESIS )
         SPACE
         #GETC ,                   NEXT CHAR WILL FOLLOW IT
         LA    #2,4                SET RETURN TO 4
         B     READ1RET            AND RETURN WITH IT
         EJECT
GSEMI    DS    0H                  FOUND A SEMICOLON ;
         SPACE
         LA    #3,1                ALL WE WANT TO DO IS...
         AH    #3,ZLFLRECL         FORCE END OF RECORD
         B     CONTINUE            SKIP REST OF RECORD, CONTINUE
         EJECT
GPERIOD  DS    0H                  FOUND A PERIOD .
         SPACE 1
***********************************************************************
*                                                                     *
* TENTATIVELY START BUILDING AN ATOM WITH THIS CHARACTER IN CASE THIS *
* TURNS OUT TO BE PART OF ONE RATHER THAN A TRUE PERIOD.              *
*                                                                     *
***********************************************************************
         SPACE 1
         MVC   0(1,#4),0(#6)       MOVE THE PERIOD TO THE ATOM AREA
         LA    #5,1                SET LENGTH SO FAR TO 1
         LA    #4,1(,#4)           BUMP ATOM POINTER
GPGET    DS    0H
         #GETC ,                   LOOK AT NEXT CHAR
         LTR   #3,#3               CHECK FOR EOF OR NEWLINE
         BZ    R1DOTERR            IF EOF HIT, FLAG AS ERROR
         BM    GISADOT             IF NEWLINE HIT, IT REALLY IS A DOT
         L     #14,ZLCRDTBL        GET ADDR OF READ TABLE TO SCAN CHAR
         TRT   0(1,#6),0(#14)      CHECK WHAT KIND OF CHARACTER THIS IS
         BZ    GALOOP              IF NORMAL, PERIOD IS PART OF AN ATOM
         CLM   #2,1,=YL1(##PERIOD) IF PERIOD, PERIOD IS PART OF AN ATOM
         BE    GALOOP
         CLM   #2,1,=YL1(##ESCAPE) IF ESCAPE, PERIOD IS PART OF AN ATOM
         BE    GESCAPE1
         CLM   #2,1,=YL1(##BAR)    IF BAR, PERIOD IS PART OF AN ATOM
         BE    GESCAPE2
         CLM   #2,1,=YL1(##CONT)   IF CONTINUATION, DON'T KNOW...
         BE    GCONTP
GISADOT  DS    0H                  ELSE IT'S A DOTTED PAIR PERIOD
         LA    #2,8                SET RETURN TO 8
         B     READ1RET            AND RETURN WITH IT
         SPACE 1
GCONTP   DS    0H                  It's a line continuation character
         SPACE 1
***********************************************************************
*                                                                     *
* If the last character of a line (RECFM=F or RECFM=V) is the         *
* "continuation character" (which defaults to cent sign in the        *
* readtable), then ignore the following newline and process the       *
* characters in the next line as if it was all on one line.           *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    ZLFFLAG1,ZLFTERM    If this is from the terminal
         BO    GALOOP              then process like ordinary char
         LA    #0,1(,#6)           If address following this character
         C     #0,ZLFEND           doesn't point to end of record
         BL    GALOOP              then handle this like ordinary char
         #GETC ,                   Otherwise get next character
         LTR   #3,#3                which should be newline,
         BNM   GABEND                or elsecent sign
         B     GPGET               and then go read the next one.
         SPACE 1
         EJECT
GMACRO   DS    0H                  PROCESS READER MACRO CHARACTER
         SPACE
         ICM   #4,15,ZLCRMCHN      START SEARCHING READER MACRO CHAIN
GMLOOP   DS    0H
         BZ    NOMACDEF            IF NO MACRO DEFINED, ERROR
         CLC   0(1,#4),0(#6)       IF MACRO CHARACTER MATCHES
         BE    GMMATCH             THEN WE HAVE IT
         ICM   #4,15,##CDR(#4)     ELSE GET NEXT MACRO FORM IN CHAIN
         B     GMLOOP              AND CONTINUE CHECKING.
GMMATCH  DS    0H                  MACRO FOUND
         MVC   ZLCRMCHR,0(#6)      SET MACRO CHAR FOR RMCHAR FUNCTION
         #GETC ,                   BUMP TO NEXT CHARACTER
         ST    #3,ZLFCHAR          UPDATE CHARACTER POINTER
         ST    #7,20(,#11)         SAVE FILE SPEC
         L     #14,0(,#11)         GET FILE ARGUMENT
         XR    #15,#15             CLEAR INSERT REGISTER
         ST    #14,28(,#11)        SET ARG 1 TO MACRO FUNCTION = FILE
         ICM   #15,7,1(#4)         GET ADDRESS OF MACRO PROCESSOR
         LA    #1,28(,#11)         POINT TO ARGUMENT ON STACK
******** LA    #2,1*4              SET # OF ARGS * 4 FOR FUNCTION
*
* The following code imitates the code sequence generated by the
* MULTIPLE-VALUE-LIST function to return a list of multiple values.
*
         ST    #11,24(,#11)        Prime for multiple value receiving
         #BASR #14,#15             CALL THE MACRO PROCESSOR
         C     #11,24(,#11)        Test for multiple value list
         L     #7,20(,#11)         RESTORE FILE SPEC
         L     #3,ZLFCHAR          PICK UP UPDATED CHARACTER POINTER
         LA    #2,ZLCRMNIL         GET ADDRESS OF "RMNIL" OBJECT
         L     #14,ZLCRDTBL        RESET READ TABLE POINTER
         BE    RMMV1               If multiple value list ret'd, then
         L     #15,24(,#11)        load up the multiple value list
         CR    #15,#10             if null value list (VALUES) ret'd
         BE    R1GO                then go read another form.
         L     #15,##CAR(,#15)     else load the first value
RMMV1    DS    0H                  #15 = the one and only value
         CR    #15,#2              IF THE READER MACRO RETURNED (RMNIL)
         BE    R1GO                THEN GO READ ANOTHER FORM. ELSE
         XR    #2,#2               RETURN WITH NORMAL VALUE IN #15
         B     READ1RET
NOMACDEF DS    0H
         ST    #3,ZLFCHAR          RESET CHARACTER POINTER
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2018 READ: Internal error in reader macro processingX
                - file ',(#2),PREFIX=NO
         EJECT
READ1RET DS    0H                  RETURN FROM READ1
         LR    #1,#11              RESTORE STACK POINTER
         L     #11,8(,#1)
         L     #14,4(,#1)
         BR    #14
         EJECT
INCRWA   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* THIS SUBROUTINE IS CALLED WHEN THE ATOM BEING BUILT EXCEEDS THE     *
* SIZE OF THE CURRENT WORKAREA.  IT ALLOCATES A LARGER WORKAREA,      *
* COPIES THE OLD INTO THE NEW, FREES THE OLD AND RESETS THE POINTER   *
* IN #4 TO THE NEW.  RETURN REGISTER IS #14.  THIS SUBROUTINE ALTERS  *
* REGISTERS #0, #1 AND #15.                                           *
*                                                                     *
***********************************************************************
         SPACE 1
         LTR   #4,#4               IF POINTER ALREADY ZERO
         BZR   #14                 THEN RETURN WITHOUT TRYING
         ST    #14,INCRSAVE        ELSE SAVE RETURN REGISTER
         L     #4,ZLCWA            GET ADDRESS OF NEW WORKAREA
         L     #14,ZLCWALEN        GET CURRENT WORKAREA LENGTH
         ST    #14,INCRSAVL        SAVE IT FOR FUTURE FREEMAIN
         LA    #0,512(,#14)        COMPUTE NEW WORKAREA LENGTH
         ST    #0,ZLCWALEN         SET NEW WORKAREA LENGTH
         #GETMAIN RC,LV=(0),LOC=BELOW SET A NEW LARGER WORKAREA
         LTR   #15,#15             IF GETMAIN FAILED (NO MEMORY)
         BNZ   INCRERR             THEN ERROR
         ST    #1,ZLCWA            SAVE NEW WORKAREA ADDRESS
         LR    #0,#1               ADDRESS OF NEW WORKAREA
         L     #1,ZLCWALEN         LENGTH OF NEW WORKAREA
         LR    #14,#4              ADDRESS OF OLD WORKAREA
         L     #15,INCRSAVL        LENGTH OF OLD WORKAREA
         MVCL  #0,#14              COPY OLD WORKAREA TO NEW WORKAREA
         LR    #1,#4               GET ADDRESS OF OLD WORKAREA
         L     #0,INCRSAVL         GET LENGTH OF OLD WORKAREA
         FREEMAIN R,LV=(0),A=(1)   FREE THE OLD WORKAREA
         L     #4,ZLCWA            GET ADDRESS OF NEW WORKAREA
         ALR   #4,#5               SET POINTER TO NEW PORTION OF AREA
         L     #14,INCRSAVE        RESTORE RETURN REGISTER
         BR    #14                 RETURN TO CALLER
         SPACE 1
INCRERR  DS    0H
         LA    #1,ZIL2007          SIGNAL "NOT ENOUGH CORE" ERROR
         ST    #1,VSERROR          SAVE FOR FUTURE ERROR FLAGGING
         XR    #4,#4               ZERO OUT WORKAREA POINTER
         XR    #5,#5               ZERO OUT WORKAREA LENGTH
         LA    #0,512              GET ANOTHER 256-BYTE AREA
         ST    #0,ZLCWALEN         TO REINITIALIZE WORK AREA
         #GETMAIN RU,LV=(0),LOC=BELOW (IT'S GOT TO BE AVAILABLE OR ELSE
         ST    #1,ZLCWA            STORE ITS ADDRESS AND LENGTH
         L     #14,INCRSAVE        RESTORE RETURN REGISTER
         BR    #14                 RETURN TO CALLER
         EJECT
GABEND   #ERR  'ZIL2018 READ: Expected newline not found following contX
               inuation character.'
         EJECT
SAVE37   DS    5A                  SAVE AREAS
INCRSAVE DS    A
INCRSAVL DS    A
         SPACE
*
* FIELDS USED BY STRING PROCESSING
*
VSSTRING DS    A                   POINTER TO STRING BEING BUILT
VSEND    DS    A                   POINTER TO END OF AVAILABLE VSSPACE
VSSAVE2  DS    A                   REGISTER SAVE
VSERROR  DS    A                   ERROR MESSAGE ADDRESS
         SPACE
FAKECR   DC    X'0D'               CHARACTER TO BE USED AS FAKE CR
         SPACE
FLAGS    DC    X'00'               FLAGS FOR ATOM PROCESSING
NONUM    EQU   X'80'               1 = ESCAPE FOUND, ATOM NOT NUMERIC
INBAR    EQU   X'40'               1 = WITHIN VERTICAL BARS
SLASHED  EQU   X'20'               1 = PRECEDED BY BACKSLASH
SYNFLAGS DC    X'00'               FLAGS FOR ENTIRE S-EXPRESSION
SYNERROR EQU   X'80'               1 = SYNTAX ERROR ENCOUNTERED
DLM      DS    C                   DELIMITER CHARACTER
         SPACE
         DS    0H,XL1              Align string to non-halfword
ZIL2007  #SATM 'ZIL2007 READ: Not enough memory to build symbol name - X
               file '
         DS    0H,XL1              Align string to non-halfword
ZIL2022  #SATM 'ZIL2022 READ: Not enough vector/string space to build sX
               tring - file '
         SPACE
UPTBL    DC    256YL1(*-UPTBL)     TABLE TO FOLD TO UPPER CASE
         ORG   UPTBL+X'81'
         DC    C'ABCDEFGHI'
         ORG   UPTBL+X'91'
         DC    C'JKLMNOPQR'
         ORG   UPTBL+X'A2'
         DC    C'STUVWXYZ'
         ORG
         SPACE 1
         DROP  #12
         SPACE 1
         LTORG
         EJECT
***********************************************************************
*                                                                     *
* (tyi &optional file eofval newlineval)                              *
*  is sort of like                                                    *
* (zdread file #b1 nil eof-error-p eofval newlineval)                 *
*                                                                     *
* reads a character from file and returns eofval if EOF hit,          *
* newlineval if NEWLINE hit,                                          *
* and a character (fixnum) if a character hit.                        *
*                                                                     *
* The default value returned for eof is -1.                           *
*                                                                     *
* The default value returned for newline is X'0D' (#\CR).             *
*                                                                     *
* This is like the Maclisp syntax, but extended with an additional    *
* optional argument for ZIL, whose 370 environment has to worry       *
* about what to do with those pesky newline conditions.               *
*                                                                     *
***********************************************************************
*                                                                     *
*               0(#11) --> arg1                                       *
*               4(#11) --> arg2                                       *
*               8(#11) --> arg3    not used by TYI                    *
*              12(#11) --> arg4    eof-error-p                        *
*              16(#11) --> arg5    eofval                             *
*              20(#11) --> arg6    newlineval                         *
*                                                                     *
*               #7 already contains the input file pointer.           *
*                                                                     *
***********************************************************************
         SPACE
ZILTYI   DS    0D                  This is TYI
         SPACE
         ST    #12,36(,#11)        Save caller's regs
         ST    #14,40(,#11)
         LR    #12,#15
         USING ZILTYI,#12
         SPACE
*
* If there was a character restored by UNTYI, then return that char.
*
*                                  Check status of unread character
         CLI   ZLFUNRST,ZLFSTINV   If the unread character is invalid
         BE    TYNUNCH             then don't process it
         CLI   ZLFUNRST,ZLFSTVLD   If the unread character is invalid
         BE    TYRUNCH             then return unread character
******** CLI   ZLFUNRST,ZLFSTEOL   If the unread character is newline
******** BE    TYRUNEOL            then return newline
         CLI   ZLFUNRST,ZLFSTEOF   If the unread character is EOF
         BE    TYRUNEOF            then return EOF
TYRUNEOL DS    0H                  Return UNTYI'd newline
         L     #15,20(,#11)        Get newlineval
         B     TYUNRET             Return it
TYRUNEOF DS    0H                  Return UNTYI'd EOF
         L     #15,16(,#11)        Get eofval
         B     TYUNRET             Return it
TYRUNCH  DS    0H                  Return UNTYI'd character
         XR    #2,#2               Clear insert register
         IC    #2,ZLFUNRCH         Get character into register
         SLA   #2,3                Convert to index into fixnum table
         LA    #15,#SFT(#2)        Get address of fixnum from table
******** B     TYUNRET             Return it
TYUNRET  DS    0H                  Return unread stuff
         MVC   ZLFLSTST,ZLFUNRST   Last char status = this char status
         MVI   ZLFUNRST,ZLFSTINV   Invalidate unread character
         B     TYRETNOC            and return with it.
         SPACE
TYNUNCH  DS    0H                  Else no unread character valid...
         TM    ZLFFLAG1,ZLFEOF     IF END OF FILE ALREADY HIT
         BO    TYAFTEOF            THEN ERROR - READ AFTER EOF
         SPACE
         L     #3,ZLFCHAR          GET CURRENT POSITION
TYGOTINP DS    0H
         LTR   #3,#3               CHECK INPUT POINTER
         BP    TYINPTOK            IF POSITIVE, WE HAVE GOOD STUFF
         BM    TYINL               IF NEGATIVE, RETURN AS A NEWLINE
******** BZ    TYIEOF              IF ZERO, EOF ENCOUNTERED
         SPACE
TYIEOF   DS    0H                  EOF HIT ON LAST READ
         OI    ZLFFLAG1,ZLFEOF     INDICATE EOF FOR NEXT CALL
         NI    ZLFFLAG1,255-ZLFNEWLN TURN NEWLINE OFF
         MVI   ZLFLSTST,ZLFSTEOF   Indicate last char read was EOF
         L     #15,16(,#11)        Get eofval
         B     TYRETURN            and return it
         SPACE
TYINL    DS    0H                  NEWLINE HIT ON LAST READ
*
* THE FOLLOWING IS TO PREVENT AN EXTRA KEYBOARD UNLOCK WHEN THE
* INPUT FILE IS A TERMINAL AND END-OF-LINE HAS BEEN ENCOUNTERED.
* REMEMBER THAT "READ" IGNORES END-OF-LINE IT IT IS THE FIRST
* THING THAT IT SEES - IF THIS WERE NOT THE CASE, READ WOULD
* HAVE TO BE CHANGED AS WELL.
*
         TM    ZLFFLAG1,ZLFNEWLN   IF WE ALREADY RETURNED NEWLINE/NIL,
         BZ    TYNLNEW1            THEN...
         NI    ZLFFLAG1,255-ZLFNEWLN SET IT OFF AGAIN
         #GETC ,                    READ IN THE NEXT CHARACTER
         B     TYGOTINP             AND TRY TO PROCESS IT
TYNLNEW1 DS    0H                  ELSE...
         OI    ZLFFLAG1,ZLFNEWLN   INDICATE NEWLINE
         MVI   ZLFLSTST,ZLFSTEOL   Indicate last char read was newline
         L     #15,20(,#11)        Get newlineval
         B     TYRETURN            and return it
         SPACE
TYINPTOK DS    0H                  REG 3 LOCATES CURRENT CHARACTER
         SPACE
         NI    ZLFFLAG1,255-ZLFNEWLN TURN NEWLINE INDICATOR OFF
         LR    #4,#3               CONVERT RELATIVE COLUMN TO
         BCTR  #4,0                 ABSOLUTE LOCATION IN LINE
         A     #4,ZLFCARD          Get address of character
         XR    #2,#2               Clear insert register
         IC    #2,0(,#4)           Get character into register
         STC   #2,ZLFLSTCH         Set last-read-character
         SLA   #2,3                Convert to index into fixnum table
         LA    #15,#SFT(#2)        Get address of fixnum from table
         MVI   ZLFLSTST,ZLFSTVLD   Indicate last char read is valid
         L     #3,ZLFCHAR          RELOAD CHARACTER POINTER
         #GETC ,                   GET NEXT CHARACTER BEFORE RETURN
         SPACE
TYRETURN DS    0H
         ST    #3,ZLFCHAR          RESET CHARACTER POINTER
TYRETNOC DS    0H
         L     #12,36(,#11)        Restore caller's regs
         L     #14,40(,#11)
         BR    #14                 Return
         SPACE
TYAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2003 TYI: Read after end of file ',(#2),            X
               PREFIX=NO
         SPACE
         DROP  #12
         SPACE
         LTORG
         EJECT
***********************************************************************
*                                                                     *
* (tyipeek &optional junk file eofval newlineval)                     *
*  is sort of like                                                    *
* (zdread file #b11 junk eof-error-p eofval newlineval)               *
*                                                                     *
* peeks at a character from file and returns eofval if EOF hit,       *
* newlineval if NEWLINE hit,                                          *
* and a character (fixnum) if a character hit.                        *
*                                                                     *
* This is like the Maclisp syntax, but extended with an additional    *
* optional argument for ZIL, whose 370 environment has to worry       *
* about what to do with those pesky newline conditions.               *
*                                                                     *
***********************************************************************
*                                                                     *
*               0(#11) --> arg1                                       *
*               4(#11) --> arg2                                       *
*               8(#11) --> arg3    NIL, T, or a character             *
*              12(#11) --> arg4    eof-error-p                        *
*              16(#11) --> arg5    eofval                             *
*              20(#11) --> arg6    newlineval                         *
*                                                                     *
*               #7 already contains the input file pointer.           *
*                                                                     *
***********************************************************************
         SPACE 1
ZILTYIPK DS    0D                  This is TYIPEEK
         SPACE
         ST    #12,36(,#11)        Save caller's regs
         ST    #14,40(,#11)
         LR    #12,#15
         USING ZILTYIPK,#12
         SPACE
         L     #6,8(,#11)          Get arg 1 to TYIPEEK
         CR    #6,#10              If NIL
         BE    TPARGNIL            then OK
         CR    #6,#8               If T
         BE    TPARGT              then OK
         CLI   ##TYPE(#6),##FIXNUM If a character
         BNE   TPARG1ER            then
         L     #2,##CDR(,#6)        Get the character
         CL    #2,#SFW255           Must be between 0 and 255
         BH    TPARG1ER             otherwise error
         B     TPARG1OK            If not NIL, T or character, error
         SPACE
TPARGNIL DS    0H                  Arg 1 to TYIPEEK is NIL
TPARGT   DS    0H                  Arg 1 to TYIPEEK is T
TPARG1OK DS    0H                  #6 = NIL, T or pointer to fixnum
*
* If there was a character restored by UNTYI, then return that char.
*
*                                  Check status of unread character
         CLI   ZLFUNRST,ZLFSTINV   If the unread character is invalid
         BE    TPNUNCH             then don't process it
         MVC   ZLFLSTST,ZLFUNRST   Last char status = this char status
         CLI   ZLFUNRST,ZLFSTVLD   If the unread character is real
         BE    TPRUNCH             then return unread character
         CLI   ZLFUNRST,ZLFSTEOL   If the unread character is newline
         BE    TPCKEOL             then return newline
         CLI   ZLFUNRST,ZLFSTEOF   If the unread character is EOF
         BE    TPRETEOF            then return EOF
TPRUNCH  DS    0H                  Return UNTYI'd character
         XR    #2,#2               Clear insert register
         IC    #2,ZLFUNRCH         Get character into register
         B     TPCKCHAR            Go to check it
TPNUNCH  DS    0H                  Else no unread character valid...
         TM    ZLFFLAG1,ZLFEOF     IF END OF FILE ALREADY HIT
         BO    TPAFTEOF            THEN ERROR - READ AFTER EOF
TPCHKIT  DS    0H
         ICM   #3,15,ZLFCHAR       GET CURRENT POSITION
         BP    TPINPOK             IF POSITIVE, WE HAVE GOOD STUFF
         BM    TPEEKNL             IF NEGATIVE, RETURN AS A NEWLINE
******** BZ    TPEEKEOF            IF ZERO, EOF ENCOUNTERED
         SPACE 1
TPEEKEOF DS    0H
         MVI   ZLFLSTST,ZLFSTEOF   Indicate last char read was EOF
TPRETEOF DS    0H
         L     #15,16(,#11)        Get eofval
         B     TPRETURN            and return with it
         SPACE
TPEEKNL  DS    0H
*
* #3 is negative, meaning a newline condition.  If ZLFNEWLN has not
* been set on, this means that TYI has not yet seen a newline, so
* return the newline parameter.  Otherwise, TYI has already seen a
* newline, so get another character, bump the pointer back, and
* return that character.
*
         TM    ZLFFLAG1,ZLFNEWLN   If newline bit is already on,
         BZ    TPNNLYET            then...
         NI    ZLFFLAG1,255-ZLFNEWLN turn newline bit off
         #GETC ,                    get character from next line
         L     #6,8(,#11)           reload arg 1 to TYIPEEK
         B     TPCHKIT              and check it again. Else...
TPNNLYET DS    0H                  No newline yet, return newline parm
         MVI   ZLFLSTST,ZLFSTEOL   Indicate last char read was newline
TPCKEOL  DS    0H
         L     #15,20(,#11)        Get newlineval
         CR    #6,#10              If (TYIPEEK NIL ...)
         BE    TPRETURN            then accept this
         CR    #6,#8               If (TYIPEEK T ...)
         BE    TPSKIP              then always consider this whitespace
*                                  Else (TYIPEEK character ...)
         CLC   0(8,#6),0(#15)      If character not EQL to newlineval
         BNE   TPSKIP              then skip this character
         B     TPRETURN            else accept it.
         SPACE
TPINPOK  DS    0H                  REG 3 LOCATES CURRENT CHARACTER
         SPACE
         LR    #4,#3               CONVERT RELATIVE COLUMN TO
         BCTR  #4,0                 ABSOLUTE LOCATION IN LINE
         A     #4,ZLFCARD          Get address of character
         XR    #2,#2               Clear insert register
         IC    #2,0(,#4)           Get character into register
         STC   #2,ZLFLSTCH         Set last-read-character
         MVI   ZLFLSTST,ZLFSTVLD   Indicate last char read is valid
TPCKCHAR DS    0H
         CR    #6,#10              If (TYIPEEK NIL ...)
         BE    TPRETCHR            then accept this character
         CR    #6,#8               If (TYIPEEK T ...)
         BE    TPCKWSP             then do whitespace test
         C     #2,##CDR(,#6)       If character not EQL to UNTYI'd char
         BNE   TPSKIP              then skip this character
         B     TPRETCHR            else accept this character
TPCKWSP  DS    0H                  Do whitespace test for character
         L     #14,ZLCRDTBL        Get address of read table
         AR    #14,#2              Point to syntax bits for character
         CLI   0(#14),##BLANK      If this is a whitespace character
         BE    TPSKIP              then skip.
******** B     TPRETCHR            Else accept.
TPRETCHR DS    0H                  Return character in #2
         SLA   #2,3                Convert to index into fixnum table
         LA    #15,#SFT(#2)        Get address of fixnum from table
******** B     TPRETURN            and return with it
         SPACE
TPRETURN DS    0H                  #15 points to character
         L     #12,36(,#11)        Restore caller's regs
         L     #14,40(,#11)
         BR    #14                 Return
         SPACE 1
TPSKIP   DS    0H                  (TYIPEEK T/char ...) rejected this
         L     #3,ZLFCHAR          Reload current character pointer
         #GETC ,                   Get next character
         ST    #3,ZLFCHAR          Reload current character pointer
         L     #6,8(,#11)          Reload arg 1 to TYIPEEK
         B     TPCHKIT             Check it again
TPARG1ER DS    0H
         #ERR  'Argument 1 to TYIPEEK not NIL, T or a character - ',   X
               8(#11)
TPAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2003 TYIPEEK: Read after end of file ',(#2),        X
               PREFIX=NO
         SPACE 1
         DROP  #12
         SPACE
         LTORG
         EJECT
***********************************************************************
*                                                                     *
* (untyi char &optional file eofval newlineval)                       *
*  is sort of like                                                    *
* (zdread file #b10 char eof-error-p eofval newlineval)               *
*                                                                     *
* "unreads" a character from file.  If the last thing read from file  *
* was EOF, eofval is returned; if EOL, newlineval is returned;        *
* else a character (fixnum) if a character hit.                       *
*                                                                     *
* This is like the Maclisp syntax, but extended with an additional    *
* optional argument for ZIL, whose 370 environment has to worry       *
* about what to do with those pesky newline conditions.               *
*                                                                     *
***********************************************************************
*                                                                     *
*               0(#11) --> arg1                                       *
*               4(#11) --> arg2                                       *
*               8(#11) --> arg3    the character to be unread         *
*              12(#11) --> arg4    eof-error-p                        *
*              16(#11) --> arg5    eofval                             *
*              20(#11) --> arg6    newlineval                         *
*                                                                     *
*               #7 already contains the input file pointer.           *
*                                                                     *
***********************************************************************
         SPACE 1
ZILUNTYI DS    0D                  This is UNTYI
         SPACE
         ST    #12,36(,#11)        Save caller's regs
         ST    #14,40(,#11)
         LR    #12,#15
         USING ZILUNTYI,#12
         SPACE
         L     #5,8(,#11)          Get arg 1 to UNTYI
         CLI   ZLFUNRST,ZLFSTINV   If unread char is still valid
         BNE   TUTWICE             then error
         CLI   ZLFLSTST,ZLFSTEOF   If last char read was EOF,
         BE    TURETEOF            then return eofval
         CLI   ZLFLSTST,ZLFSTEOL   If last char read was newline,
         BE    TURETEOL            then return newlineval
         CLI   ZLFLSTST,ZLFSTVLD   If last-char-read is not valid
         BNE   TUBAD               then error
         CLI   ##TYPE(#5),##FIXNUM Check arg 1 to UNTYI
         BNE   TUERROR             Must be a fixnum
         L     #3,##CDR(,#5)       Get the character
         CL    #3,#SFW255          Must be between 0 and 255
         BH    TUERROR
         XR    #2,#2               Clear insert register
         IC    #2,ZLFLSTCH         Get last read char into register
         LR    #4,#2               Get last read char into register
         SLA   #2,3                Convert to index into fixnum table
         LA    #15,#SFT(#2)        Get address of fixnum from table
         CR    #3,#4               If last char read doesn't match
         BNE   TUWRONG             then error
         STC   #4,ZLFUNRCH         Set unread-character
         MVI   ZLFUNRST,ZLFSTVLD   Indicate unread char valid
         SPACE
TURETURN DS    0H                  #15 points to character
         L     #12,36(,#11)        Restore caller's regs
         L     #14,40(,#11)
         BR    #14                 Return
         SPACE 1
TURETEOF DS    0H                  Last char read was EOF
         L     #15,16(,#11)        Get eofval
         CLC   0(8,#5),0(#15)      If no match
         BNE   TUWRONG             then error
         MVI   ZLFUNRST,ZLFSTEOF   Indicate unread char is EOF
         B     TURETURN            else return with it.
TURETEOL DS    0H                  Last char read was newline
         L     #15,20(,#11)        Get newlineval
         CLC   0(8,#5),0(#15)      If no match
         BNE   TUWRONG             then error
         MVI   ZLFUNRST,ZLFSTEOL   Indicate unread char is newline
         B     TURETURN            else return with it.
         SPACE 1
TUERROR  DS    0H
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2003 UNTYI: Invalid character specified for file ', X
               (#2),' - ',(#5),PREFIX=NO
TUWRONG  DS    0H
         LR    #4,#15              Load true character pointer
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2003 UNTYI: Specified character ',(#5),' does not maX
               tch character ',(#4),' from file ',(#2),PREFIX=NO
TUBAD    DS    0H
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2003 UNTYI: Sequence error - no previously read charX
               acter ',(#5),' for file ',(#2),PREFIX=NO
         SPACE 1
TUTWICE  DS    0H
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2003 UNTYI: Sequence error - issued twice without reX
               ading another character from file ',(#2),PREFIX=NO
         SPACE 1
         DROP  #12
         SPACE
         LTORG
         EJECT
***********************************************************************
*                                                                     *
* (readch &optional file eofval newlineval)                           *
*  is sort of like                                                    *
* (zdread file #b100 nil eof-error-p eofval newlineval)               *
*                                                                     *
* reads a character from file and returns eofval if EOF hit,          *
* newlineval if NEWLINE hit,                                          *
* and an interned symbol if a character hit.                          *
*                                                                     *
* This is like the Maclisp syntax, but extended with an additional    *
* optional argument for ZIL, whose 370 environment has to worry       *
* about what to do with those pesky newline conditions.               *
*                                                                     *
***********************************************************************
*                                                                     *
*               0(#11) --> arg1                                       *
*               4(#11) --> arg2                                       *
*               8(#11) --> arg3    not used by READCH                 *
*              12(#11) --> arg4    eof-error-p                        *
*              16(#11) --> arg5    eofval                             *
*              20(#11) --> arg6    newlineval                         *
*                                                                     *
*               #7 already contains the input file pointer.           *
*                                                                     *
***********************************************************************
         SPACE
READCH   DS    0D                  This is READCH
         SPACE
         ST    #12,36(,#11)        Save caller's regs
         ST    #14,40(,#11)
         LR    #12,#15
         USING READCH,#12
         SPACE
         TM    ZLFFLAG1,ZLFEOF     IF END OF FILE ALREADY HIT
         BO    RCAFTEOF            THEN ERROR - READ AFTER EOF
         SPACE
         L     #3,ZLFCHAR          GET CURRENT POSITION
RCGOTINP DS    0H
         LTR   #3,#3               CHECK INPUT POINTER
         BP    RCINPOK             IF POSITIVE, WE HAVE GOOD STUFF
         BM    RCNL                IF NEGATIVE, RETURN AS A NEWLINE
******** BZ    RCEOF               IF ZERO, EOF ENCOUNTERED
         SPACE
RCEOF    DS    0H                  EOF HIT ON LAST READ
         OI    ZLFFLAG1,ZLFEOF     INDICATE EOF FOR NEXT CALL
         NI    ZLFFLAG1,255-ZLFNEWLN TURN NEWLINE OFF
         L     #15,16(,#11)        Get eofval
         B     RCRETURN            and return it
         SPACE
RCNL     DS    0H                  NEWLINE HIT ON LAST READ
*
* THE FOLLOWING IS TO PREVENT AN EXTRA KEYBOARD UNLOCK WHEN THE
* INPUT FILE IS A TERMINAL AND END-OF-LINE HAS BEEN ENCOUNTERED.
* REMEMBER THAT "READ" IGNORES END-OF-LINE IT IT IS THE FIRST
* THING THAT IT SEES - IF THIS WERE NOT THE CASE, READ WOULD
* HAVE TO BE CHANGED AS WELL.
*
         TM    ZLFFLAG1,ZLFNEWLN   IF WE ALREADY RETURNED NEWLINE/NIL,
         BZ    RCNLNEW1            THEN...
         NI    ZLFFLAG1,255-ZLFNEWLN SET IT OFF AGAIN
         #GETC ,                    READ IN THE NEXT CHARACTER
         B     RCGOTINP             AND TRY TO PROCESS IT
RCNLNEW1 DS    0H                  ELSE...
         OI    ZLFFLAG1,ZLFNEWLN   INDICATE NEWLINE
         L     #15,20(,#11)        Get newlineval
         B     RCRETURN            and return with it
         SPACE
RCINPOK  DS    0H                  REG 3 LOCATES CURRENT CHARACTER
         SPACE
         NI    ZLFFLAG1,255-ZLFNEWLN TURN NEWLINE INDICATOR OFF
         LR    #4,#3               CONVERT RELATIVE COLUMN TO
         BCTR  #4,0                 ABSOLUTE LOCATION IN LINE
         A     #4,ZLFCARD            AND PASS IT TO INTERN ROUTINE
*
* Since we are calling ZILINTN directly to intern the character,
* we MUST check for T ourselves.
*
         CLI   0(#4),C'T'          If character = T
         BNE   RCNOTT              then
         LR    #15,#8               return address of T
         B     RCGETNXT            else not T...
RCNOTT   DS    0H                  #4 points to print name text
         LR    #3,#7               Save file pointer across ZILINTN
         LA    #5,1                Get length of print name text
         XR    #7,#7               Indicate print name must be built
         L     #15,ZLCINTN         Get address of ZILINTN
         LA    #0,44(,#11)         Get current top-of-stack pointer
         #BASR #14,#15             Call ZILINTN to intern the symbol
         LR    #7,#3               Restore file pointer
RCGETNXT DS    0H                  Time to pre-read next character
         L     #3,ZLFCHAR          RELOAD CHARACTER POINTER
         #GETC ,                   GET NEXT CHARACTER BEFORE RETURN
         SPACE
RCRETURN DS    0H
         ST    #3,ZLFCHAR          RESET CHARACTER POINTER
         L     #12,36(,#11)        Restore caller's regs
         L     #14,40(,#11)
         BR    #14                 Return
         SPACE
RCAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2003 READCH: Read after end of file ',(#2),         X
               PREFIX=NO
         SPACE
         DROP  #12
         SPACE
         LTORG
         EJECT
***********************************************************************
*                                                                     *
* (peekch &optional file eofval newlineval)                           *
*  is sort of like                                                    *
* (zdread file #b110 nil eof-error-p eofval newlineval)               *
*                                                                     *
* peeks at a character from file and returns eofval if EOF hit,       *
* newlineval if NEWLINE hit,                                          *
* and an interned symbol if a character hit.                          *
*                                                                     *
* This is like the Maclisp syntax, but extended with an additional    *
* optional argument for ZIL, whose 370 environment has to worry       *
* about what to do with those pesky newline conditions.               *
*                                                                     *
***********************************************************************
*                                                                     *
*               0(#11) --> arg1                                       *
*               4(#11) --> arg2                                       *
*               8(#11) --> arg3    not used by PEEKCH                 *
*              12(#11) --> arg4    eof-error-p                        *
*              16(#11) --> arg5    eofval                             *
*              20(#11) --> arg6    newlineval                         *
*                                                                     *
*               #7 already contains the input file pointer.           *
*                                                                     *
***********************************************************************
         SPACE
PEEKCH   DS    0D                  This is PEEKCH
         SPACE
         ST    #12,36(,#11)        Save caller's regs
         ST    #14,40(,#11)
         LR    #12,#15
         USING PEEKCH,#12
         SPACE
         TM    ZLFFLAG1,ZLFEOF     IF END OF FILE ALREADY HIT
         BO    PCAFTEOF            THEN ERROR - READ AFTER EOF
PCCHKIT  DS    0H
         ICM   #3,15,ZLFCHAR       GET CURRENT POSITION
         BP    PCINPOK             IF POSITIVE, WE HAVE GOOD STUFF
         BM    PCPEEKNL            IF NEGATIVE, RETURN AS A NEWLINE
*                                  If zero, eof encountered
         L     #15,16(,#11)        Get eofval
         B     PCRETURN            and return with it
         SPACE
PCPEEKNL DS    0H
*
* #3 is negative, meaning a newline condition.  If ZLFNEWLN has not
* been set on, this means that TYI has not yet seen a newline, so
* return the newline parameter.  Otherwise, TYI has already seen a
* newline, so get another character, bump the pointer back, and
* return that character.
*
         TM    ZLFFLAG1,ZLFNEWLN   If newline bit is already on,
         BZ    PCNNLYET            then...
         NI    ZLFFLAG1,255-ZLFNEWLN turn newline bit off
         #GETC ,                    get character from next line
         B     PCCHKIT              and check it again. Else...
PCNNLYET DS    0H                  No newline yet, return newline parm
         L     #15,20(,#11)        Get newlineval
         B     PCRETURN            and return with it.
         SPACE
PCINPOK  DS    0H                  REG 3 LOCATES CURRENT CHARACTER
         SPACE
         LR    #4,#3               CONVERT RELATIVE COLUMN TO
         BCTR  #4,0                 ABSOLUTE LOCATION IN LINE
         A     #4,ZLFCARD            AND PASS IT TO INTERN ROUTINE
*
* Since we are calling ZILINTN directly to intern the character,
* we MUST check for T ourselves.
*
         CLI   0(#4),C'T'          If character = T
         BNE   PCNOTT              then
         LR    #15,#8               return address of T
         B     PCRETURN            else not T...
PCNOTT   DS    0H                  #4 points to print name text
         LA    #5,1                Get length of print name text
         XR    #7,#7               Indicate print name must be built
         L     #15,ZLCINTN         Get address of ZILINTN
         LA    #0,44(,#11)         Get current top-of-stack pointer
         #BASR #14,#15             Call ZILINTN to intern the symbol
         SPACE
PCRETURN DS    0H
         L     #12,36(,#11)        Restore caller's regs
         L     #14,40(,#11)
         BR    #14                 Return
         SPACE
PCAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT
         L     #2,ZLFATOM          Load file atom for error message
         #ERR  'ZIL2003 PEEKCH: Read after end of file ',(#2),         X
               PREFIX=NO
         SPACE
         DROP  #12
         SPACE
         LTORG
         EJECT
         SPACE
***********************************************************************
*                                                                     *
* READLINE - returns a line from an input file as a string.           *
*                                                                     *
***********************************************************************
         SPACE 1
***********************************************************************
*                                                                     *
*               0(#11) --> arg1                                       *
*               4(#11) --> arg2                                       *
*               8(#11) --> arg3    not used by READLINE               *
*              12(#11) --> arg4    eof-error-p                        *
*              16(#11) --> arg5    eofval                             *
*              20(#11) --> arg6    newlineval                         *
*                                                                     *
*               #7 already contains the input file pointer.           *
*                                                                     *
***********************************************************************
         SPACE 1
READLINE DS    0D                  This is READLINE
         SPACE
         ST    #12,36(,#11)        Save caller's regs
         ST    #14,40(,#11)
         LR    #12,#15
         USING READLINE,#12
         SPACE
         TM    ZLFFLAG1,ZLFEOF     IF END OF FILE ALREADY HIT
         BO    RLAFTEOF            THEN ERROR - READ AFTER EOF
         SPACE
         L     #3,ZLFCHAR          GET CURRENT CHARACTER POINTER
         LTR   #3,#3               TEST IT
         BZ    RLEOF               IF ZERO, END OF FILE
         BM    RLFORCNL            IF NEWLINE, FORCE ANOTHER READ
         TM    ZLFFLAG1,ZLFNEWLN   IF NEWLINE CONDITION CURRENT
         BZ    RLNNEWLN            THEN...
RLFORCNL XR    #3,#3                SET CHARACTER POINTER TO
         BCTR  #3,0                 FORCE A NEWLINE CONDITION TO
         #GETC ,                    FORCE A READ
RLNNEWLN DS    0H
         SPACE 1
         LTR   #3,#3               TEST CURRENT CHARACTER POINTER
         BZ    RLEOF               IF ZERO, END OF FILE
         XR    #3,#3               SET CHARACTER POINTER TO
         BCTR  #3,0                FORCE A NEWLINE FOR NEXT READ
         XR    #1,#1               ENTRY CODE FOR ZILVSS = 0
         LH    #2,ZLFLRECL         GET LENGTH OF INPUT DATA LINE
         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS
         LA    #0,16(,#11)         SET CURRENT STACK POINTER
         OI    ZLCGCFLG,ZLCGCBLD   Turn on trust-#0 flag for GC
         #BASR #14,#15             CALL ZILVSS TO GET SPACE
         NI    ZLCGCFLG,255-ZLCGCBLD Turn off trust-#0 flag for GC
         LTR   #15,#15             IF NO SPACE
         BZ    RLNOSPC             THEN ERROR
         LA    #0,##VECDAT(,#15)   DESTINATION ADDRESS = STRING TEXT
         LH    #1,ZLFLRECL         DESTINATION LENGTH = INPUT LRECL
         L     #4,ZLFCARD          SOURCE ADDRESS = INPUT RECORD
         LR    #5,#1               SOURCE LENGTH = INPUT LRECL
         MVCL  #0,#4               MOVE INPUT DATA TO STRING TEXT
         B     RLRETURN            RETURN WITH STRING
         SPACE
RLEOF    DS    0H                  EOF HIT ON LAST READ
         OI    ZLFFLAG1,ZLFEOF     INDICATE EOF FOR NEXT CALL
         NI    ZLFFLAG1,255-ZLFNEWLN TURN NEWLINE OFF
         L     #15,16(,#11)        Return eofval
         B     RLRETURN
         SPACE
RLAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT
         L     #2,ZLFATOM          Get file atom for error message
         #ERR  'ZIL2003 READLINE: Read after end of file ',(#2),       X
               PREFIX=NO
         SPACE
RLNOSPC  DS    0H
         #ERR  'ZIL4010 READLINE: Not enough vector/string space to buiX
               ld string.',PREFIX=NO
         SPACE
RLRETURN DS    0H
         ST    #3,ZLFCHAR          RESET CHARACTER POINTER
         L     #12,36(,#11)        Restore caller's regs
         L     #14,40(,#11)
         BR    #14                 Return
         SPACE
         DROP  #12
         SPACE
         LTORG
         EJECT
***********************************************************************
*                                                                     *
* RDRMACRO - takes two arguments, both required:                      *
*                                                                     *
*   (1) The single character to be defined as a reader macro.         *
*       This can be a string, symbol or character fixnum.             *
*   (2) The compiled code SUBR to be executed.                        *
*                                                                     *
* Note that (2) MUST be a SUBR!  Even a closure is not acceptable.    *
*                                                                     *
***********************************************************************
*                                                                     *
*               0(#11) --> arg1                                       *
*               4(#11) --> arg2                                       *
*               8(#11) --> arg3    character arg to RDRMACRO          *
*              12(#11) --> arg4    subr arg to RDRMACRO               *
*              16(#11) --> arg5    not used                           *
*              20(#11) --> arg6    not used                           *
*                                                                     *
*               #7 already contains the input file pointer.           *
*                                                                     *
***********************************************************************
         SPACE
RDRMACRO DS    0D                  This is RDRMACRO
         ST    #12,36(,#11)        Save caller's regs
         ST    #14,40(,#11)
         LR    #12,#15
         USING RDRMACRO,#12
         SPACE
         L     #4,ZLCRDTBL         Get readtable address
         LM    #2,#3,8(#11)        Get args: #2 = CHAR, #3 = SUBR
         CLI   ##TYPE(#2),##FIXNUM IF ARG1 IS A FIXNUM
         BE    RMA1CHAR            THEN OK (IT'S A CHARACTER)
         CLI   ##TYPE(#2),##STRING IF ARG1 IS A STRING
         BE    RMA1OK              THEN OK (AS LONG AS LENGTH = 1)
         CLI   ##TYPE(#2),##SYMBOL IF ARG1 IS NOT A SYMBOL
         BNE   RMERROR1            THEN ERROR
         L     #2,##PNAME(,#2)     ELSE GET SYMBOL PRINT NAME
RMA1OK   DS    0H
         XR    #6,#6               CLEAR INSERT REG
         CLC   1(3,#2),=AL3(1)     STRING/SYMBOL NAME LENGTH MUST BE 1
         BNE   RMERROR1            ELSE ERROR
         IC    #6,##VECDAT(,#2)    GET READER MACRO CHARACTER IN REG
         B     RMCKARG2
RMA1CHAR DS    0H                  IT'S A FIXNUM...
         L     #6,##CDR(,#2)       GET FIXNUM VALUE
         CL    #6,#SFW255          MUST BE BETWEEN 0 AND 255
         BH    RMERROR1            ELSE ERROR
RMCKARG2 DS    0H
         CR    #3,#10              IF ARG2 IS NIL
         BE    RMA2OK              THEN OK (MEANS DELETE THIS MACRO)
         CLI   ##TYPE(#3),##SUBR   IF ARG2 IS NOT A COMPILED SUBR
         BNE   RMERROR2            THEN ERROR
RMA2OK   DS    0H
*
* PREPARE TO BUILD NEW READER MACRO CELL.  FIRST SEARCH THE EXISTING
* CHAIN FOR (1) A CELL WITH OUR CHARACTER, OR (2) THE END.
*
         L     #1,ZLCRMCHN         PICK UP READER MACRO CHAIN
         LA    #5,ZLCRMCHN-##CDR   FAKE OUT INITIAL POINTER
RMLOOP   DS    0H
         LTR   #1,#1
         BZ    RMNOMAC
         LR    #5,#1
         CLM   #6,B'0001',0(#5)    SEE IF READER MACRO CHARACTERS MATCH
         BE    RMGOTMAC            IF SO, GO TO PROCESS
         L     #1,##CDR(,#5)       IF NOT, GET NEXT CELL IN CHAIN
         B     RMLOOP
RMNOMAC  DS    0H                  DOES NOT EXIST - CREATE NEW ONE
         SPACE 1
         CR    #3,#10              IF ARG2 IS NIL
         BE    RMRETURN            THEN DO NOTHING, NO MACRO TO DELETE
*
* CONS UP A NEW CELL
*
         XR    #1,#1               ARG1 TO CONS
         XR    #2,#2               ARG2 TO CONS
         L     #15,ZLCCONS         GET ADDRESS OF CONS
         LA    #0,44(,#11)         PASS CURRENT STACK POINTER TO CONS
         OI    ZLCGCFLG,ZLCGCBLD   Turn on trust-#0 flag for GC
         #BASR #14,#15             CALL CONS TO GET A CELL
         NI    ZLCGCFLG,255-ZLCGCBLD Turn off trust-#0 flag for GC
         STC   #6,##TYPE(,#15)     SET MACRO CHARACTER IN CELL
         ST    #15,##CDR(,#5)      CHAIN IT TO PREVIOUS CELL
         LR    #5,#15              SET POINTER TO IT
RMGOTMAC DS    0H                  NOW WE HAVE A CELL
         CR    #3,#10              IF ARG2 IS NIL
         BNE   RMNEWMAC            THEN...
         LA    #1,0(#6,#4)          POINT TO CHAR POS IN READTABLE
         NI    0(#1),X'7F'          RESTORE NON-MACRO STATUS FOR CHAR
         B     RMRETURN            ELSE...
RMNEWMAC DS    0H                  UPDATE READER MACRO CELL
         L     #1,##CAR(,#3)       GET COMPILED CODE PTR FOR SUBR ARG2
         STCM  #1,7,##CAR+1(#5)    SET SUBR PTR IN READER MACRO CELL
         LA    #1,0(#6,#4)         POINT TO CHARACTER POS IN READTABLE
         OI    0(#1),X'80'         SET CHARACTER TO BE A MACRO CHAR
         SPACE 1
RMRETURN DS    0H
         LR    #15,#10             RETURN NIL (WHAT ELSE IS THERE?)
         L     #12,36(,#11)        Restore caller's regs
         L     #14,40(,#11)
         BR    #14                 Return
         SPACE
RMERROR1 #ERR  'ZIL2030 RDRMACRO: Invalid reader macro character - ',  X
               8(#11),PREFIX=NO
RMERROR2 #ERR  'Argument 2 to RDRMACRO not a compiled code SUBR - ',   X
               12(#11)
         SPACE
         DROP  #12
         SPACE
         LTORG
         EJECT
***********************************************************************
*                                                                     *
* RMCHAR TAKES NO ARGUMENTS.                                          *
*                                                                     *
* THIS FUNCTION RETURNS THE CURRENT READER MACRO CHARACTER AS SET BY  *
* THE READ FUNCTION WHEN IT INVOKES A READER MACRO.                   *
*                                                                     *
* THE ATOM IS ALWAYS INTERNED, SINCE WHAT GOOD WOULD IT BE OTHERWISE? *
*                                                                     *
* THIS FUNCTION IS MEANT TO BE ISSUED BY READER MACRO FUNCTIONS.      *
* IF EXECUTED OTHERWISE, RESULT WILL BE UNPREDICTABLE.                *
*                                                                     *
***********************************************************************
*                                                                     *
*               0(#11) --> arg1                                       *
*               4(#11) --> arg2                                       *
*              18(#11) --> arg3    not used                           *
*              12(#11) --> arg4    not used                           *
*              16(#11) --> arg5    not used                           *
*              20(#11) --> arg6    not used                           *
*                                                                     *
*               #7 already contains the input file pointer.           *
*                                                                     *
***********************************************************************
         SPACE
RMCHAR   DS    0D                  This is RMCHAR
         ST    #12,36(,#11)        Save caller's regs
         ST    #14,40(,#11)
         LR    #12,#15
         USING RMCHAR,#12
         SPACE
         CLI   ZLCRMCHR,C'T'       If reader macro character is T
         BNE   RKNOTT              (not likely, but...) then...
         LR    #15,#8               return T
         B     RKRETURN            else..
RKNOTT   DS    0H
         LA    #5,1                Length of atom to be built = 1
         LA    #4,ZLCRMCHR         Get current reader macro character
         XR    #7,#7               Indicate print name must be built
         L     #15,ZLCINTN         Get address of ZILINTN
         LA    #0,44(,#11)         Get current top-of-stack pointer
         #BASR #14,#15             Call ZILINTN to intern the symbol
RKRETURN DS    0H
         L     #12,36(,#11)        Restore caller's regs
         L     #14,40(,#11)
         BR    #14                 Return
         SPACE
         DROP  #12
         SPACE
         LTORG
         END
