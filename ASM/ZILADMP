***********************************************************************
*                                                                     *
* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *
*                     All rights reserved.                            *
*                                                                     *
***********************************************************************
         TITLE 'ZILADMP - LOCAL MACRO DEFINITION'
         MACRO
&SYM     DMPER &MSG
&SYM     L     #1,=A(&MSG)
         LA    #0,L'&MSG
         B     SIGNALER
         MEND
         TITLE 'ZILADMP - ZIL 1.3 ATOM DECONSTRUCTOR MODULE'
***********************************************************************
*                                                                     *
* THIS MODULE IS INVOKED VIA BALR FROM ASSEMBLER LANGUAGE FUNCTIONS   *
* WHICH DESIRE TO DUMP ATOMS INTO IN-STORAGE CHARACTER AREAS, OR      *
* JUST RETURN THE ALPHA TEXT PORTION OF THE ATOM WHERE RELEVANT.      *
*                                                                     *
* THIS MODULE USES NO STACK SPACE,  SINCE IT'S NOT RECURSIVE.         *
*                                                                     *
* INPUTS ARE AS FOLLOWS:                                              *
*                                                                     *
* REGISTER 1 CONTAINS THE SLASHIFICATION INDICATOR:                   *
*   NIL - DON'T SLASHIFY.                                             *
*   OTHER - SLASHIFY.                                                 *
* REGISTER 2 POINTS TO THE ATOM TO BE DUMPED.                         *
*                                                                     *
* ALSO, THE CALLER MAY SET THE "ALWAYS-COPY" BIT ON IF DESIRED...     *
*       OI ZLCDFLGS,ZLCDCOPY                                          *
* IF IT IS REQUIRED THAT THE RETURNED TEXT NOT BE IN V/S SPACE.       *
* THIS IS USED BY EXPLODE.                                            *
*                                                                     *
* OUTPUTS ARE AS FOLLOWS:                                             *
*                                                                     *
* REGISTER 0 CONTAINS THE LENGTH OF THE DUMPED ATOM.                  *
* REGISTER 1 CONTAINS THE ADDRESS OF THE (DUMPED ATOM) TEXT.          *
* REGISTER 2 IS UNCHANGED.                                            *
*                                                                     *
* NON-ALPHA TYPE ATOMS WILL BE CONVERTED APPROPRIATELY.               *
* HOWEVER, LISTS ARE INVALID AS INPUT.                                *
*                                                                     *
***********************************************************************
*                                                                     *
* THE INTERFACE HAS CHANGED SLIGHTLY, IN THAT ZILADMP NOW RETURNS     *
* THE ADDRESS OF THE WORKAREA IN REGISTER 1.  THIS IS NECESSARY FOR   *
* STRINGS, WHICH HAVE THEIR ACTUAL DATA AREA RETURNED, NOT COPIED.    *
* THUS ALL CALLERS OF THIS MODULE MUST BE ALTERED TO USE THIS VALUE.  *
*                                                                     *
***********************************************************************
*                                                                     *
*                    BIGNUM DUMPING CODE BY KJELD HVATUM.             *
*                                                                     *
*  Binary to decimal conversion can be done by using the obvious      *
*  (from Knuth (vol 2, 2nd ed., page 302)                             *
*                                                                     *
*  ( {} is the integer function)                                      *
*                                                                     *
*                                                                     *
*       U  = u mod B                                                  *
*        0                                                            *
*                                                                     *
*       U  = {u/B} mod B                                              *
*        1                                                            *
*                                                                     *
*       U  = {{u/B}/B} mod B                                          *
*        2                                                            *
*                                                                     *
*       ...                                                           *
*                                                                     *
*                                                                     *
*  etc. stopping when {...{{u/B}B}.../B} = 0.                         *
*  This would be done in radix-b arithmetic.  The result in radix B   *
*                                                                     *
*  is (U ...U U ).                                                    *
*       M    0 1                                                      *
*                                          31           9             *
*  In our application the radices are b = 2   and B = 10 .            *
*  This will allow efficient use of machine instructions.  It implies *
*  that the binary to decimal conversion will use the bignum/fixnum   *
*  (bignum divided by fixnum) routine which is included inline        *
*  here.                                                              *
***********************************************************************
*                                                                     *
* Change activity:                                                    *
*                                                                     *
* 04/27/88 - Fixed bug with slashification not reset after error.     *
*                                                                     *
***********************************************************************
         EJECT 1
ZILADMP  #ZBEG NAME='ZILADMP'
         SPACE 1
         NI    ZLCDFLGS,255-ZLCDSLSH INITIALIZE SLASHIFICATION FLAG
         CR    #1,#10              IF SLASHIFICATION REQUESTED
         BE    DONTSLSH            OR
         CR    #1,#13              IF SLASHIFICATION REQUESTED
         BE    DONTSLSH            THEN...
         OI    ZLCDFLGS,ZLCDSLSH    INDICATE SLASHIFICATION REQUEST
DONTSLSH DS    0H
         SPACE 1
         TM    ZLCDFLGS,ZLCDCOPY+ZLCDSLSH IF SLASHIFY OR COPY REQUESTED
         BNZ   NOPRECHK            THEN NO PRE-CHECK IS POSSIBLE
*
* QUICK PRE-CHECK FOR STRING/SYMBOL IS POSSIBLE ONLY IF WE ARE NOT
* SLASHIFYING AND NOT ALWAYS-COPYING THE TEXT.
*
* QUICK PRE-CHECK FOR STRINGS.  WE WANT TO RETURN INFO FOR STRINGS
* WITH MAXIMUM SPEED AND EFFICIENCY AND LOWEST OVERHEAD.
*
         XR    #0,#0                  CLEAR INSERT REGISTER
         CLI   ##TYPE(#2),##STRING IF ARG IS A STRING
         BNE   NOTASTR               THEN...
         ICM   #0,7,1(#2)             SET STRING LENGTH
         LA    #1,##VECDAT(,#2)       SET STRING TEXT POINTER
         BR    #14                    RETURN
NOTASTR  DS    0H
*
* QUICK PRE-CHECK FOR SYMBOLS.
*
         CLI   ##TYPE(#2),##SYMBOL IF ARG IS A SYMBOL
         BNE   NOTASYM               THEN...
         L     #1,##PNAME(,#2)        GET POINTER TO PRINT NAME
         ICM   #0,7,1(#1)             SET STRING LENGTH
         LA    #1,##VECDAT(,#1)       SET STRING TEXT POINTER
         BR    #14                    RETURN
         SPACE 1
NOPRECHK DS    0H                  SLASHIFICATION OR COPY REQUESTED
         SPACE 1
         STM   #12,#7,ADMPSAVE     SAVE REGISTERS
         LR    #12,#15             SET UP BASE REGISTER
         SPACE 1
         DROP  #15
         USING ZILADMP,#12         ESTABLISH ADDRESSABILITY
         SPACE 1
         CLI   ##TYPE(#2),##STRING IF IT IS A STRING
         BE    SLSTRING            THEN GO TO SLASHIFY THE STRING
         CLI   ##TYPE(#2),##SYMBOL IF IT IS A SYMBOL
         BE    SLSYMBOL            THEN GO TO SLASHIFY THE SYMBOL
         B     CHKATOM             ELSE NOT STRING OR SYMBOL
         SPACE 1
DOCOPY   DS    0H
         SPACE 1
NOTASYM  DS    0H                  NOT STRING OR SYMBOL...
         SPACE 1
         DROP  #12
         USING ZILADMP,#15         ESTABLISH ADDRESSABILITY
         SPACE 1
         STM   #12,#7,ADMPSAVE     SAVE REGISTERS
         LR    #12,#15             SET UP BASE REGISTER
         SPACE 1
         DROP  #15
         USING ZILADMP,#12         ESTABLISH ADDRESSABILITY
         SPACE 1
CHKATOM  DS    0H
         EJECT
*
* CHECK INPUT PARAMETERS
*
         TM    ##TYPE(#2),##ATOM   IF INPUT IS NOT AN ATOM
         BZ    ERROR0              THEN ERROR
*
* BEGIN PROCESSING
*
         LA    #3,ATOMAREA         REG 3 --> CHARACTER BUFFER AREA
         LR    #4,#2               REG 4 --> ATOM TO BE DUMPED
         XR    #5,#5               CLEAR LENGTH REGISTER
         SPACE 1
         TM    ##TYPE(#4),##CCO    IF THIS IS A COMPILED CODE OBJECT
         BZ    NOTSUBR             THEN...
         XR    #1,#1
         ICM   #1,7,##CAR+1(#4)    GET POINTER TO COMPILED CODE
         LA    #2,0(,#3)           POINT TO OUTPUT AREA
         MVI   0(#2),C'#'
         MVI   1(#2),C'<'
         TM    ##TYPE(#4),##CLOS   IF THIS IS A CLOSURE
         BZ    NOTACLOS            THEN
         MVC   2(8,#2),=C'CLOSURE ' IDENTIFY AS CLOSURE
         LA    #2,2+8(,#2)          BUMP OUTPUT POINTER
         B     AFTACLOS
NOTACLOS DS    0H                  ELSE...
* IN FUTURE THIS COULD ALSO BE FSUBR, MSUBR, OR LSUBR...
         MVC   2(5,#2),=C'SUBR '    IDENTIFY AS SUBR
         LA    #2,2+5(,#2)          BUMP OUTPUT POINTER
AFTACLOS DS    0H
         XR    #6,#6               CLEAR INSERT REGISTER
         IC    #6,4(,#1)           GET LENGTH OF MODULE IDENTIFIER
         LA    #0,L'ATOMAREA(,#3)  POINT TO END OF OUTPUT WORKAREA
         SR    #0,#2               GET LENGTH OF REMAINING AREA
         CR    #6,#0               IF MODULE ID LENGTH EXCEEDS IT
         BNH   *+6                 THEN
         LR    #6,#0               USE SHORTER LENGTH
         BCTR  #6,0                REDUCE LENGTH FOR EXECUTE
         LTR   #6,#6               IF LENGTH WAS ZERO,
         BM    AFTAMOV             THEN SKIP MVC
         EX    #6,MOVID            ELSE MOVE MODULE ID TO OUTPUT AREA
AFTAMOV  LA    #2,1(#6,#2)         BUMP TO END OF MODULE ID OUTPUT
         MVI   0(#2),C'>'          FINISH UP
         LA    #0,1(,#2)           POINT TO END OF OUTPUT STUFF
         SR    #0,#3               GET THE LENGTH OF THE STUFF
         LR    #1,#3               GET THE ADDRESS OF THE STUFF
         B     RETURN              RETURN (IT'S DONE)
         SPACE 1
MOVID    MVC   0(*-*,#2),5(#1)     EXECUTED: MOVE MODULE ID TO OUTPUT
         EJECT
NOTSUBR  DS    0H                  ELSE (NOT CODE OBJECT)...
         SPACE 1
         TM    ##TYPE(#4),##FLOAT  IF A FLOATING POINT ATOM
         BZ    NOTFLOAT            THEN
         SPACE 1
         TM    ##TYPE(#4),##VSS    If double float
         BO    DFDUMP              then go to dump double float
         SPACE 1
***********************************************************************
*                                                                     *
* Single-precision floating point dump.                               *
*                                                                     *
* Two floating-point formats are possible: "human" format and         *
* scientific-notation E-format.                                       *
*                                                                     *
* If we can represent the absolute value of the flonum without loss   *
* of significance, we use human format.  Otherwise we use E format.   *
*                                                                     *
* In either case a leading plus sign is NOT output; a leading minus   *
* sign will be output whenever required.                              *
*                                                                     *
***********************************************************************
         SPACE 1
         LD    #F0,=D'0'            CLEAR FPR0
         LE    #F0,##CDR(,#4)       GET FLOAT VALUE (SINGLE PRECISION)
         LPDR  #F2,#F0              GET ABSOLUTE VALUE THEREOF
         BZ    PRINT0P0             IF ZERO, PRINT 0.0F0
         SPACE 1
         STE   #F0,ZLCWORK          Store flonum into workarea
         NI    ZLCWORK,X'7F'        Turn off sign bit
         XR    #6,#6                Clear insert register
         ST    #6,ZLCWORK+4         Clear right half of workarea
         IC    #6,ZLCWORK           Get characteristic
         SH    #6,=H'64'            Convert from excess-64 notation
         BP    GTZERO               If characteristic was X'40' or less
         MVI   1(#3),C'0'            Make integer part print as zero
         LA    #2,2(,#3)             Point to where to put decimal pt
         MVI   0(#2),C'.'            Move in decimal point
*
* In cases where the fractional part times 10¬9 is still less than 1,
* the only characteristics we can handle without loss of significance
* are as follows:
*
* Original characteristic  Value of #6   Possible flonum values
*
* 40                       0             40xxxxxx
* 3F                       -1            3Fxxxxx0
* 3E                       -2            3Exxxx00
* 3D                       -3            3Dxxx000
* 3C                       -4            3Cxx0000
* 3B                       -5            3Bx00000
*
* Anything else and we have to switch to E notation.
*
         LPR   #15,#6              Convert #6 to an index
         CH    #15,=H'5'           If characteristic just too small
         BH    EDUMP               then use E-format
         SLA   #15,2               Index into table of flonum masks
         L     #0,ZLCWORK           Get flonum contents
         N     #0,FRMASK(#15)       And it with mask
         BNZ   EDUMP                If any 1-bits in bad place, use E
         B     CVFRAC               Else go to convert fractional part
         SPACE 1
GTZERO   DS    0H                   Else flonum > 0
         CH    #6,=H'6'             If more than 6 hex positions
         BH    EDUMP                then give up - use E-notation
         XR    #4,#4                Set up register pair
         ICM   #5,15,ZLCWORK+1      Load integer part of flonum
         SLA   #6,2                 Multiply characteristic by 4
         SLDL  #4,0(#6)             Shift integer by # of hex places
* Now #4 contains the integer part of the flonum.
         CVD   #4,ZLCDBL            GET DECIMAL NUMERIC VALUE
         MVC   NUMAREA(12),PATTERN  INITIALIZE EDIT PATTERN
         LA    #1,NUMAREA+11        INITIALIZE MARK REGISTER
         EDMK  NUMAREA(12),ZLCDBL+2 EDIT PACKED DATA INTO PATTERN
         BNM   *+10                 IF RESULT IS NEGATIVE, THEN...
         BCTR  #1,0                 BUMP BACK TO PREVIOUS POSITION
         MVI   0(#1),C'-'           AND MOVE A MINUS SIGN IN FRONT.
         LA    #15,NUMAREA+12       COMPUTE LENGTH OF SIGNIFICANT PART
         SR    #15,#1               LENGTH OF CONVERTED INTEGER
         BCTR  #15,0                REDUCE FOR EXECUTE
         EX    #15,MVCNUMI          MOVE OUR DATA TO CALLER'S AREA
*
* Now the dumped integer part of the flonum is at #3%+1.
* #15 contains the length thereof minus 1.
*
         LA    #2,2(#15,#3)        Point past dumped integer part
         MVI   0(#2),C'.'          Move in a decimal point
         STCM  #5,14,ZLCWORK+1     Store fractional part back
         MVI   ZLCWORK,X'40'       Set characteristic of fraction
         SPACE 1
CVFRAC   DS    0H
         SPACE 1
*
* Convert fractional part of flonum to a decimal representation by
* multiplying it by 10000000.  If the fraction's magnitude is so small
* that this would result in loss of significance, then switch to
* E notation.
*
         SDR   #F4,#F4             Clear FP reg
         LE    #F4,ZLCWORK         Load fractional part of flonum
         LTER  #F4,#F4             If zero
         BZ    FRAC0               then print a zero fractional part
         BM    FLOBARF             If less than zero, error - lose
         MD    #F4,=D'10E7'        Multiply by 10**7 (for 8 places)
         AD    #F4,=D'5'           Add rounding factor
         CD    #F4,=D'10E7'        If this makes it too big
         BNL   EDUMP               then use E notation
         DD    #F4,=D'10'          Down to 10**7 for 8 places
*
* Now convert fraction to decimal following decimal point in workarea
*
         STD   #F4,ZLCWORK          Store flonum into workarea
         XR    #6,#6                Clear insert register
         IC    #6,ZLCWORK           Get characteristic
         SH    #6,=H'64'            Convert from excess-64 notation
         BM    FLOBARF              If frac lt 1, lose
         BP    FRGTZERO             If characteristic was X'40', then
         MVI   1(#2),C'0'            make fractional part zero
         LA    #4,1(,#2)             point to end of dumped value
         B     FLOREADY              go to finish up flonum
         SPACE 1
FRGTZERO DS    0H                   Else flonum > 0
         CH    #6,=H'6'             If more than 6 hex positions
         BH    EDUMP                then give up, use E notation
         XR    #4,#4                Set up register pair
         ICM   #5,15,ZLCWORK+1      Load integer part of flonum
         SLA   #6,2                 Multiply characteristic by 4
         SLDL  #4,0(#6)             Shift integer by # of hex places
* Now #4 contains the integer part of the flonum.
         CVD   #4,ZLCDBL            Get decimal numeric value
         UNPK  1(7,#2),ZLCDBL(8)    Unpack following decimal point
         OI    7(#2),X'F0'          Fix up zone
*
* Now the dumped fractional part of the flonum is at #2%+1.
* #15 contains the length thereof minus 1.
*
         LA    #4,7(,#2)           Point to last digit in dumped no.
         LA    #0,1(,#2)           Point to first digit following "."
FRBSLOOP DS    0H                  Back scan off trailing zeroes
         CR    #4,#0               Finished when hit first frac digit
         BNH   FRDONE
         CLI   0(#4),C'0'          If a nonzero digit found, done
         BNE   FRDONE
         BCT   #4,FRBSLOOP         Else continue backscan
FRDONE   DS    0H                  Now #4 points to last nonzero digit
*                                  (or single digit following ".")
         B     FLOREADY
         SPACE 1
FRAC0    DS    0H                  Here if fractional part is zero
         SPACE 1
         MVI   1(#2),C'0'          Make it xxx.0
         LA    #4,1(,#2)           Compute total length
******** B     FLOREADY
         SPACE 1
FLOREADY DS    0H                  Flonum converted except for sign
         SPACE 1
         MVC   1(2,#4),=C'F0'      Move in single-float marker
         LA    #4,2(,#4)
         SR    #4,#3               Compute length
* If it starts with a plus sign, remove the plus sign.
         LTER  #F0,#F0             If original number was negative
         BNM   FNMINUS             then
         MVI   0(#3),C'-'           add a minus sign
         LA    #0,1(,#4)            adjust length accordingly
         LR    #1,#3                point to minus sign
         B     RETURN
FNMINUS  DS    0H                  else
         LA    #1,1(,#3)            point to data
         LR    #0,#4                adjust length accordingly
         B     RETURN
         SPACE 1
PRINT0P0 DS    0H                  Print a floating-point zero
         LA    #1,=C'0.0F0'
         LA    #0,5
         B     RETURN
         SPACE 1
EDUMP    DS    0H                  Print flonum using E notation
*                                  FP reg 2 contains absolute value
         SPACE 1
         XR    #6,#6                INIT DECIMAL EXPONENT TO ZERO
COMP10   DS    0H                   MAKE IT BETWEEN 0.1 AND 1.0
         LTDR  #F2,#F2              IF ZERO,
         BZ    OKNOW                 OK FOR FORMATTING
         CD    #F2,=D'1.'           IF GREATER THAN 1
         BNL   GE1                   THEN MUST DIVIDE UNTIL < 1
         CD    #F2,=D'.1'           IF LESS THAN .1
         BL    LTP1                  THEN MUST MULTIPLY UNTIL >= .1
         B     OKNOW                ELSE OK FOR FORMATTING
GE1      DS    0H
         DD    #F2,=D'10'           DIVIDE UNTIL LT 1.0
         AH    #6,=H'1'             INCREMENT DECIMAL EXPONENT
         B     COMP10               CONTINUE TESTING
LTP1     DS    0H
         MD    #F2,=D'10'           MULTIPLY UNTIL GE 0.1
         BCTR  #6,0                 DECREMENT DECIMAL EXPONENT
         B     COMP10               CONTINUE TESTING
OKNOW    DS    0H                   NUMBER IS READY TO FORMAT
         MD    #F2,=D'10E8'         MULTIPLY BY 10**9 (FOR 9 PLACES)
         AD    #F2,=D'5'            ADD ROUNDING FACTOR (SHOW 8 PLACES)
         CD    #F2,=D'10E8'         IF THIS MAKES IT BIGGER AGAIN
         BL    RNDEDOK              THEN
         DD    #F2,=D'10'            DIVIDE BY 10 AGAIN
         AH    #6,=H'1'              AND ADJUST EXPONENT ACCORDINGLY.
RNDEDOK  DS    0H
         AW    #F2,=X'4E00000000000000' UNNORMALIZE TO GET INTEGER PART
         STD   #F2,ZLCDBL           STORE RESULT IN WORK AREA
         L     #1,ZLCDBL+4          PICK UP FIXED PORTION, NOW ISOLATED
         LTDR  0,0                  IF NUMBER WAS NEGATIVE
         BM    OUTMINUS             THEN PUT A MINUS SIGN
         MVI   0(#3),C'+'           ELSE PUT A PLUS SIGN
         B     AFTMINUS
OUTMINUS MVI   0(#3),C'-'
AFTMINUS DS    0H
*
* 10/87 - Convert representation from .mmmF+nn to m.mmF+(nn-1)
*
         BCTR  #6,0                 Adjust exponent for this rep.
******** MVI   1(#3),C'.'           DECIMAL POINT
         CVD   #1,ZLCDBL            MANTISSA OF DECIMAL NUMBER
         UNPK  2(9,#3),ZLCDBL       CONVERT INTO USER AREA
* IGNORE LAST DIGIT (USED FOR ROUNDING ONLY)
         MVC   1(1,#3),2(#3)        Slide leftmost digit over
         MVI   2(#3),C'.'           Insert decimal point
         LA    #1,3(,#3)            Point to digit following "."
         LA    #15,9(,#3)           Point to last dumped digit
EBS1     DS    0H                   Scan off trailing zeroes
         CR    #15,#1               Loop until we have to stop
         BNH   EBS2                  or
         CLI   0(#15),C'0'            until we find a nonzero digit
         BNE   EBS2                    at which point go finish up
         BCT   #15,EBS1             Decrement and continue
EBS2     DS    0H
         MVI   1(#15),C'F'          OVERLAY ROUNDING DIGIT WITH EXP CHR
         LTR   #6,#6                CHECK SIGN OF DECIMAL EXPONENT
         BM    EXPMINUS
         MVI   2(#15),C'+'
         B     AFTEXPMN
EXPMINUS MVI   2(#15),C'-'
AFTEXPMN DS    0H
         CVD   #6,ZLCDBL           DECIMAL CHARACTERISTIC
         UNPK  3(2,#15),ZLCDBL     CONVERT INTO USER AREA
         OI    4(#15),X'F0'
* If it starts with a plus sign, remove the plus sign.  This is the
* least we can do to make Macsyma users happy for now.
         CLI   0(#3),C'+'          IF STARTS WITH PLUS SIGN
         BNE   FNOTPLUS            THEN
         LA    #1,1(,#3)            POINT PAST PLUS SIGN
         B     FAFTPLUS             FLOAT NUMBER LOOKS LIKE ABOVE
FNOTPLUS DS    0H                  ELSE
         LR    #1,#3                GET POINTER TO THE STUFF
FAFTPLUS DS    0H
         LA    #0,5(,#15)          LENGTH OF DUMPED FLONUM
         SR    #0,#1               = END - START
         B     RETURN
         EJECT
DFDUMP   DS    0H                  Dump double float
         SPACE 1
***********************************************************************
*                                                                     *
* Double-precision floating point dump.                               *
*                                                                     *
* Two floating-point formats are possible: "human" format and         *
* scientific-notation E-format.                                       *
*                                                                     *
* If we can represent the absolute value of the flonum without loss   *
* of significance, we use human format.  Otherwise we use E format.   *
*                                                                     *
* In either case a leading plus sign is NOT output; a leading minus   *
* sign will be output whenever required.                              *
*                                                                     *
***********************************************************************
         SPACE 1
         LD    #F0,8(,#4)           Get value of double precision float
         LPDR  #F2,#F0              Get absolute value thereof
         BZ    DPRINT00             If zero, print 0.0
         SPACE 1
         STD   #F0,ZLCWORK          Store flonum into workarea
         NI    ZLCWORK,X'7F'        Turn off sign bit
         XR    #6,#6                Clear insert register
         IC    #6,ZLCWORK           Get characteristic
         SH    #6,=H'64'            Convert from excess-64 notation
         BP    DGTZERO              If GT X'40', go do integer part
*                                   Characteristic X'40' or less...
*                                   there is only a fractional part
         MVI   1(#3),C'0'            Make integer part print as zero
         LA    #2,2(,#3)             Point to where to put decimal pt
         MVI   0(#2),C'.'            Move in decimal point
*
* In cases where the fractional part times 10¬16 is still less than 1,
* the only characteristics we can handle without loss of significance
* are as follows:
*
* Original characteristic  Value of #6   Possible flonum values
*
* 40                       0             40xxxxxx xxxxxxxx
* 3F                       -1            3Fxxxxxx xxxxxxx0
* 3E                       -2            3Exxxxxx xxxxxx00
* 3D                       -3            3Dxxxxxx xxxxx000
* 3C                       -4            3Cxxxxxx xxxx0000
* 3B                       -5            3Bxxxxxx xxx00000
* 3A                       -6            3Axxxxxx xx000000
* 39                       -7            39xxxxxx x0000000
* 38                       -8            38xxxxxx 00000000
* 37                       -9            37xxxxx0 00000000
* 36                       -10           36xxxx00 00000000
* 35                       -11           35xxx000 00000000
* 34                       -12           34xx0000 00000000
* 33                       -13           33x00000 00000000
*
* Anything else and we have to switch to scientific notation.
*
* Some hacking required here.  More than just this test is required.
*
         LPR   #15,#6              Convert #6 to an index
         CH    #15,=H'12' <==      If characteristic just too small
         BH    DEDUMP              then use scientific notation
         SLA   #15,3               Index into table of flonum masks
         LA    #15,DFRMASK(#15)    Get address of appropriate mask
         MVC   DWORK(8),ZLCWORK    Move flonum contents to work area
         NC    DWORK(8),0(#15)     And it with mask
         BNZ   DEDUMP              If any 1-bits in bad place, use sci.
         B     DCVFRAC             Else go to convert fractional part
         SPACE 1
DGTZERO  DS    0H                   Else flonum > 0
         SPACE 1
         CH    #6,=H'14'            If more than 14 hex positions
         BH    DEDUMP               then give up - use sci-notation
         SPACE 1
***********************************************************************
*                                                                     *
* (1) Isolate integer part of flonum and convert to decimal.          *
*     #6 = adjusted characteristic (number of nibbles of integer)     *
*                                                                     *
* To do the conversion, we load the integer part of the flonum        *
* (isolated by the old trick of adding an unnormalized zero)          *
* into a register pair and do a fixed-point divide by 10¬9 to get the *
* left half of the converted decimal, then convert the remainder to   *
* get the right half.  Subsequently we scan off leading blanks.       *
*                                                                     *
***********************************************************************
         SPACE 1
         LDR   #F4,#F2             Get that (abs flonum) again
         AW    #F4,=X'4E00000000000000' Unnormalize to get integer part
         STD   #F4,DWORK            Store it
         CLI   DWORK,X'4E'          If characteristic isn't what we
         BNE   FLOBARF               expected, then go blow up.
         MVI   DWORK,X'00'          Clear characteristic
         LM    #4,#5,DWORK          Load integer part of flonum
         D     #4,=F'1000000000'    Divide by 10¬9
* We know that the quotient cannot be greater than 2147483647, so
* a program check is not possible.
*                                   #4 = remainder
*                                   #5 = quotient
         CVD   #5,ZLCDBL            Convert quotient to decimal
         UNPK  DNUMAREA(9),ZLCDBL   Get 9 digits of decimal number
         OI    DNUMAREA+8,X'F0'     Fix up sign
         CVD   #4,ZLCDBL            Convert remainder to decimal
         UNPK  DNUMAREA+9(9),ZLCDBL Get 9 digits of decimal number
         OI    DNUMAREA+9+8,X'F0'   Fix up sign
*
* Now the dumped integer part of the flonum is at DNUMAREA.
* We have 18 digits.  Now get rid of leading blanks.  We know
* that the entire number will not be zero.
*
         LA    #1,DNUMAREA         Start pointer at start of digits
         LA    #15,18              Set loop count
DLZLOOP  CLI   0(#1),C'0'          Loop until nonzero digit found
         BNE   DLZEND
         LA    #1,1(,#1)
         BCT   #15,DLZLOOP
DLZEND   DS    0H
*                                  #15 contains # of significant
*                                  decimal digits, #1 points to num
         BCTR  #15,0               Reduce length for execute
         EX    #15,MVCNUMI         Move dumped integer part
         LA    #2,2(#15,#3)        Point past dumped integer part
         MVI   0(#2),C'.'          Move in a decimal point
         SPACE 1
***********************************************************************
*                                                                     *
* (2) Isolate the fractional part of the flonum and convert that.     *
*     To get it, we simply subtract the integer part from the         *
*     original (abs flonum).                                          *
*                                                                     *
***********************************************************************
         SPACE 1
         AD    #F4,=D'0'           Normalize integer flonum
         SDR   #F2,#F4             Set FPR2 = fractional part
         STD   #F2,ZLCWORK         Store fractional part in workarea
         SPACE 1
DCVFRAC  DS    0H
         SPACE 1
*
* Convert fractional part of flonum to a decimal representation by
* multiplying it by 10¬15.  If the fraction's magnitude is so small
* that this would result in loss of significance, then switch to
* scientific notation.
*
         LTDR  #F2,#F2             If zero
         BZ    DFRAC0              then print a zero fractional part
         BM    FLOBARF             If less than zero, error - lose
         MD    #F2,=D'10E16'       Multiply by 10**16 (for 16 places)
         AD    #F2,=D'5'           Add rounding factor
         CD    #F2,=D'10E16'       If this makes it too big
         BNL   DEDUMP              then use scientific notation
         DD    #F2,=D'10'          Down to 10**15 for 16 places
*
* Now convert fraction to decimal following decimal point in workarea
*
         AW    #F2,=X'4E00000000000000' Unnormalize to get integer part
         STD   #F2,DWORK            Store it
         CLI   DWORK,X'4E'          If characteristic isn't what we
         BNE   FLOBARF               expected, go blow up.
         MVI   DWORK,X'00'          Clear characteristic
         LM    #4,#5,DWORK         Load integer part of flonum
         D     #4,=F'1000000000'   Divide by 10¬9
* We know that the quotient cannot be greater than 2147483647, so
* a program check is not possible.
*                                  #4 = remainder
*                                  #5 = quotient
         CVD   #5,ZLCDBL           Convert quotient to decimal
         UNPK  DNUMAREA(9),ZLCDBL  Get 9 digits of decimal number
         OI    DNUMAREA+8,X'F0'    Fix up sign
         CVD   #4,ZLCDBL           Convert remainder to decimal
         UNPK  DNUMAREA+9(9),ZLCDBL Get 9 digits of decimal number
         OI    DNUMAREA+9+8,X'F0'  Fix up sign
*
* Now the dumped fractional part of the flonum is at DNUMAREA.
* We have 18 digits.  However, we expect a maximum of 16 digits
* to be significant.  Plus, get rid of trailing blanks.  We know
* that the entire number will not be zero.
*
         LA    #1,DNUMAREA+9+8     Start pointer at end of digits
         LA    #15,16              Set loop count
DTZLOOP  CLI   0(#1),C'0'          Loop until nonzero digit found
         BNE   DTZEND
         BCTR  #1,0
         BCT   #15,DTZLOOP
DTZEND   DS    0H
*                                  #15 contains # of significant
*                                  decimal digits
         LA    #1,DNUMAREA+2
         BCTR  #15,0               Reduce length for execute
         EX    #15,MVCNUMF         Move dumped fractional part
         LA    #4,2(#15,#2)        Point to end of dumped value
         B     DFLORDY             Go to finish up flonum
         SPACE 1
DFRAC0   DS    0H                  Here if fractional part is zero
         SPACE 1
         MVI   1(#2),C'0'          Make it xxx.0
         LA    #4,2(,#2)           Point to the end
******** B     DFLORDY
         SPACE 1
DFLORDY  DS    0H                  Flonum converted except for sign
*                                  and double-float marker
*******  MVC   0(2,#4),=C'D0'      DON'T Move in double-float marker
*******  LA    #4,1(,#4)           Add to length
         BCTR  #4,0
         SR    #4,#3               Compute length
         LTER  #F0,#F0             If original number was negative
         BNM   DFNMINUS            then
         MVI   0(#3),C'-'           add a minus sign
         LA    #0,1(,#4)            adjust length accordingly
         LR    #1,#3                point to minus sign
         B     RETURN
DFNMINUS DS    0H                  else
         LA    #1,1(,#3)            point to data
         LR    #0,#4                adjust length accordingly
         B     RETURN
         SPACE 1
DPRINT00 DS    0H                  Print a double-float zero
         LA    #1,=C'0.0'
         LA    #0,3
         B     RETURN
         SPACE 1
DEDUMP   DS    0H                  Print flonum using sci. notation
*                                  FP reg 2 contains absolute value
         SPACE 1
         XR    #6,#6               Initial decimal exponent to zero
DCOMP10  DS    0H                  Make value between 0.1 and 1.0
         LTDR  #F2,#F2             If value is zero,
         BZ    DOKNOW               then it's ok for formatting
         CD    #F2,=D'1.'          If value greater than 1
         BNL   DGE1                 then we must divide until LT 1
         CD    #F2,=D'.1'          If less than 0.1
         BL    DLTP1                then we must multiply until GE 0.1
         B     DOKNOW              Else ok for formatting
DGE1     DS    0H
         DD    #F2,=D'10'          Divide until LT 1.0
         AH    #6,=H'1'            Increment decimal exponent
         B     DCOMP10             Continue testing
DLTP1    DS    0H
         MD    #F2,=D'10'          Multiply until GE 0.1
         BCTR  #6,0                Decrement decimal exponent
         B     DCOMP10             Continue testing
DOKNOW   DS    0H                  Now number is ready to format
         MD    #F2,=D'10E15'       Multiply by 10**15 (for 16 places)
         AD    #F2,=D'5'           Add rounding factor (show 16 places)
         CD    #F2,=D'10E15'       If this makes it bigger again
         BL    DRNDEDOK            then
         DD    #F2,=D'10'           divide by 10 again
         AH    #6,=H'1'             and adjust exponent accordingly.
DRNDEDOK DS    0H
         AW    #F2,=X'4E00000000000000' Unnormalize to get integer part
         STD   #F2,ZLCDBL          Store result in work area
         CLI   ZLCDBL,X'4E'        If characteristic isn't what we
         BNE   FLOBARF              expected, go blow up.
         MVI   ZLCDBL,X'00'        Clear characteristic
         LM    #4,#5,ZLCDBL        Pick up integer part, now isolated
         LTDR  #F0,#F0             If original flonum was negative
         BM    DOUTMNUS            then put a minus sign
         MVI   0(#3),C'+'          else put a plus sign
         B     DAFTMNUS
DOUTMNUS MVI   0(#3),C'-'
DAFTMNUS DS    0H
*
* 10/87 - Convert representation from .mmmF+nn to m.mmF+(nn-1)
*
         BCTR  #6,0                Adjust exponent for this rep.
******** MVI   1(#3),C'.'          Put decimal point
         D     #4,=F'1000000000'   Divide by 10¬9
* We know that the quotient cannot be greater than 2147483647, so
* a program check is not possible.
*                                  #4 = remainder
*                                  #5 = quotient
         CVD   #5,ZLCDBL           Convert quotient to decimal
         UNPK  2(7,#3),ZLCDBL      Get 9 digits of decimal number
         OI    8(#3),X'F0'         Fix up sign
         CVD   #4,ZLCDBL           Convert remainder to decimal
         UNPK  9(9,#3),ZLCDBL      Get 9 digits of decimal number
         OI    17(#3),X'F0'        Fix up sign
* Ignore last digit (used for rounding only)
         MVC   1(1,#3),2(#3)        Slide leftmost digit over
         MVI   2(#3),C'.'           Insert decimal point
         LA    #1,3(,#3)            Point to digit following "."
         LA    #15,16(,#3)          Point to last dumped digit
DBS1     DS    0H                   Scan off trailing zeroes
         CR    #15,#1               Loop until we have to stop
         BNH   DBS2                  or
         CLI   0(#15),C'0'            until we find a nonzero digit
         BNE   DBS2                    at which point go finish up
         BCT   #15,DBS1             Decrement and continue
DBS2     DS    0H
         MVI   1(#15),C'D'         Overlay rounding digit with exp chr
         LTR   #6,#6               Check sign of decimal exponent
         BM    DEXPMNUS
         MVI   2(#15),C'+'
         B     DAFTEXPM
DEXPMNUS MVI   2(#15),C'-'
DAFTEXPM DS    0H
         CVD   #6,ZLCDBL           Decimal characteristic
         UNPK  3(2,#15),ZLCDBL     Convert into user area
         OI    4(#15),X'F0'
* If it starts with a plus sign, remove the plus sign.
         CLI   0(#3),C'+'          If it starts with plus sign
         BNE   DFNPLUS             then
         LA    #1,1(,#3)            point past plus sign
         B     DFAPLUS
DFNPLUS  DS    0H                  else
         LR    #1,#3                get pointer to the stuff
DFAPLUS  DS    0H
         LA    #0,5(,#15)          Get length of dumped flonum
         SR    #0,#1               = end - start
         B     RETURN
         EJECT
NOTFLOAT DS    0H
         SPACE
         CLI   ##TYPE(#4),##FIXNUM IF FIXNUM
         BNE   NOTFIXED            THEN...
         SPACE
         L     #1,##CDR(,#4)       GET THE FIXED VALUE OF THE ATOM
         CVD   #1,ZLCDBL           GET DECIMAL NUMERIC VALUE
         MVC   NUMAREA(12),PATTERN INITIALIZE EDIT PATTERN
         LA    #1,NUMAREA+11       INITIALIZE MARK REGISTER
         EDMK  NUMAREA(12),ZLCDBL+2 EDIT PACKED DATA INTO PATTERN
         BNM   *+10                IF RESULT IS NEGATIVE, THEN...
         BCTR  #1,0                 BUMP BACK TO PREVIOUS POSITION
         MVI   0(#1),C'-'           AND MOVE A MINUS SIGN IN FRONT.
         LA    #0,NUMAREA+12       COMPUTE LENGTH OF SIGNIFICANT PART
         SR    #0,#1               LENGTH OF CONVERTED FIXNUM
         LR    #15,#0              SET LENGTH OF CONVERTED NUMBER
         BCTR  #15,0               REDUCE FOR EXECUTE
         EX    #15,MVCNUMA         MOVE OUR DATA TO CALLER'S AREA
         LR    #1,#3               GET POINTER TO THE STUFF
         B     RETURN
         SPACE
MVCNUMA  MVC   0(0,#3),0(#1)       MOVE CHAR TEXT TO USER AREA
MVCNUMI  MVC   1(0,#3),0(#1)       MOVE CHAR TEXT TO USER AREA
MVCNUMF  MVC   1(0,#2),0(#1)       MOVE CHAR TEXT TO USER AREA
         EJECT
NOTFIXED DS    0H                  IT'S NOT A FIXNUM
         SPACE
         CLI   ##TYPE(#4),##BIGNUM IF A BIGNUM
         BNE   NOTBIG              THEN...
         SPACE
***********************************************************************
*ON ENTRY                                                             *
*     R3 = POINTER TO SMALL WORK AREA                                 *
*     R4 = POINTER TO BIGNUM                                          *
***********************************************************************
*ON RETURN                                                            *
*     R4 = ACTUAL OBJECT ON RETURN (MUST INCLUDE MINUS SIGN, IF ANY)  *
*     R5 = IS LENGTH (EXACT NUMER OF BYTES)                           *
* POSITIVE BIGNUM RETURNED WITH A FEW LEADING ZEROS                   *
* NEGATIVE BIGNUM RETURNED WITH MINUS SIGN A POSSIBLE LEADING ZEROES  *
***********************************************************************
* REGISTER USAGE - DURING PROCESSING                                  *
*     R0 = 1,000,000,000                                              *
*     R1 = USED AS TEMPORARY JUNK REGISTER                            *
*     R2 = LENGTH OF BIGNUM, LENGTH OF BIGNUM - 1                     *
*     R3 = POINTER TO BEGINNING OF WORK AREA                          *
*     R4 = BIGNUM POINTER                                             *
*     R5 = -4 (SIZE OF WORD, GENERAL USE)                             *
*     R6 = UPPER DIVIDEND REGISTER, REMAINDER AFTER DIVIDE            *
*     R7 = LOWER DIVIDEND REGISTER, QUOTIENT AFTER DIVIDE             *
*     R14 = OFFSET POINTER WITHIN BIGNUM                              *
*     R15 = CVD RESULT POINTER (LONGBIG ONLY)                         *
***********************************************************************
         EJECT
         TM    3(#4),B'00000011'   TEST FOR UNMULTIPLE OF 4
         BNZ   NOMULT4             BIGNUM LENGTH IS NOT MULTIPLE OF 4
         XR    #2,#2               NEED 0 IN HIGH ORDER BYTE OF REG 2
         ICM   #2,7,1(#4)          GET THREE BYTE LENGTH OF BIGNUM
         LA    #5,4                BYTE SIZE OF ONE WORD
         SR    #2,#5               ZERO-ORIGIN THE BIGNUM BYTE-LENGTH
         CR    #2,#5               IS BIGNUM TWO WORDS LONG?
         BH    LONGBIG             TWO WORD BIGNUM -NO WORK AREA NEEDED
         BL    SIZEBAD             ****TAKE THIS OUT AFTER DEBUGGING
         L     #0,=F'1000000000'   ONE BILLION, DO TWO WORD BIGNUM
******** L     #6,8(,#4)           MS WORD INTO LS DIVIDEND
         ICM   #6,15,8(#4)         *** DELETE AFTER DEBUGGING
         BM    BIGBAD              *** DELETE AFTER DEBUGGING
         BZ    BADZERO             *** DELETE AFTER DEBUGGING
         CR    #6,#0               MS WORD GREATER THAN BILLION (RARE)?
         BNL   BIG2                NEED TWO DIVIDES FOR TWO WORD BIGNUM
         CLC   0(12,#4),BADTWO31   IS BIGNUM -2**31 ?
         BE    BAD31MSG            YES, ISSUE MESSAGE
         L     #7,4(,#4)           MS WORD OF 2-WORD BIGNUM
         SLL   #7,1                MASH OUT SIGN BIT (31-BIT-RADIX)
         SRDL  #6,1                SQUEEZE HIGHER WORD DOWN
         DR    #6,#0               DIVIDE TO GET REMAINDER
         CVD   #6,ZLCDBL           PACKED DECIMAL INTO WORK AREA
         UNPK  11(9,#3),ZLCDBL+3(5) UNPACK LS 9 DIGITS
         OI    19(#3),X'F0'        GET RID OF DUMB UNPK SIGN
         CVD   #7,ZLCDBL           DECIMALIZE QUOT. TO GIVE MS 10 DIG
         UNPK  1(10,#3),ZLCDBL+2(6) UNPACK MS 10 DIGS,19TH=0,1,2
         OI    10(#3),X'F0'        GET RID OF DUMB UNPK SIGN
         LR    #1,#3               POINTER TO BEGINNING OF STRING
         LA    #15,20(,#3)         POINTER PAST END OF TEXT
         B     BIGDONE             GO SCAN FOR LEADING ZEROES
*
BIG2     SRDL  #6,32               DIV IN RIGHT REG, CLEAR LEFT
         DR    #6,#0               DIVIDE MS WORD BY BILLION
         LR    #15,#7              STORE QUOTIENT (CAN ONLY BE 1 OR 2)
         L     #7,4(,#4)           MS WORD OF 2-WORD BIGNUM
         SLL   #7,1                MASH OUT SIGN BIT (31-BIT-RADIX)
         SRDL  #6,1                SQUEEZE HIGHER WORD DOWN
         DR    #6,#0               DIVIDE TO GET REMAINDER
         CVD   #6,ZLCDBL           PACKED DECIMAL INTO WORK AREA
         UNPK  11(9,#3),ZLCDBL+3(5) UNPACK LS 9 DIGITS
         OI    19(#3),X'F0'        GET RID OF DUMB UNPK SIGN
         LR    #6,#15
         SLL   #7,1                MASH OUT JUNK BIT (31-BIT-RADIX)
         SRDL  #6,1                SQUEEZE HIGHER WORD DOWN
         DR    #6,#0
         CVD   #6,ZLCDBL           DECIMALIZE QUOT. TO GIVE MS 10 DIG
         UNPK  2(9,#3),ZLCDBL+3(5) UNPACK 9 DIGITS
         OI    10(#3),X'F0'         GET RID OF DUMB UNPK SIGN
         CR    #7,#5               ****DELETE AFTER DEBUGGING
         BH    DIG19ERR            ****DELETE AFTER DEBUGGING
         LA    #7,C'0'(,#7)        19TH DIGIT IS 2,3,4, PREP FOR EBCDIC
         STC   #7,1(,#3)           STORE 19TH DIGIT IN EBCDIC
         LR    #1,#3               POINTER TO BEGINNING TEXT
         LA    #15,20(,#3)         POINTER PAST END OF TEXT
         B     BIGDONE             GO SCAN FOR LEADING ZEROES
         SPACE 1
LONGBIG  DS    0H
         LA    #7,24(#2,#2)        R7 = 24 + 2*R2
         AR    #7,#2               NOW R7 = 24 + 3*R2
         C     #7,ZLCDWALN         IF IT IS TOO BIG FOR CURRENT W/A
         BNH   WALENOK             THEN
         ICM   #1,15,ZLCDWA         GET CURRENT WORKAREA ADDRESS
         BZ    NOFREE               IF NONE, SKIP FREEMAIN
         L     #0,ZLCDWALN          GET LENGTH OF CURRENT WORKAREA
         FREEMAIN R,LV=(0),A=(1)    FREE IT
NOFREE   DS    0H                  NOW PREPARE TO GET A BIGGER ONE
******** LA    #7,7(,#7)           ROUND (DOWN) TO DOUBLEWORD BOUNDARY
         N     #7,=X'FFFFFFF8'     (IT'S ALREADY >=4 MORE THAN WE NEED)
         #GETMAIN RC,LV=(#7),LOC=BELOW GET NEW WORKAREA
         LTR   #15,#15             IF STORAGE NOT AVAILABLE
         BNZ   ERROR2              THEN ERROR
         ST    #7,ZLCDWALN         SAVE NEW WORKAREA LENGTH
         ST    #1,ZLCDWA           SAVE NEW WORKAREA ADDRESS
WALENOK  L     #3,ZLCDWA           OK, GET WORKAREA ADDRESS
         LCR   #5,#5               GENERATE -4
         L     #0,=F'1000000000'   ONE BILLION
*
         LR    #14,#3              START AT NEXT LEAST SIG WORD
         LA    #15,4(,#2)          PREP TO COPY WHOLE LENGTH OF BIGNUM
         LA    #6,##VECDAT(,#4)    START AT LEAST SIGNFICANT WORD
         LR    #7,#15              LENGTH OF BIGNUM
         MVCL  #14,#6              MOVE BIGNUM TO WORK AREA
*                                  THE SIGN WILL GET SQUEEZED OUT
*
         L     #1,ZLCDWALN         GET LENGTH OF WORKAREA
         AR    #1,#3               POINT PAST END OF WORKAREA
         AR    #2,#5               #2 IS 8 LESS THAN DIVIDEND LENGTH
         LR    #15,#1              SAVE POINTER PAST END OF WORKAREA
*
CVDLOOP  LA    #14,4(,#2)          #14 SHOULD ONLY BE 4 LESS THAN LEN
         LA    #6,9                WE DO 9 DECIMAL DIGITS AT A TIME
         SR    #1,#6               BUMP DOWN THE UNPACK POINTER
*
         L     #6,0(#14,#3)        GET MS WORD OF DIVIDEND
         LTR   #6,#6               *** DELETE AFTER DEBUGGING
         BM    BIGBAD              *** DELETE AFTER DEBUGGING
         BZ    BADZERO             *** DELETE AFTER DEBUGGING
         CR    #6,#0               LESS THAN A BILLION?
         BL    NODIV               YUP, WE KNOW QUOTIENT WILL BE 0
         SRDL  #6,32               NOP, PUT IT IN #7 AND CLEAR #6
         DR    #6,#0               DIVIDE BY A BILLION
         ST    #7,0(#14,#3)        STORE QUOTIENT IN SAME PLACE
         SR    #2,#5               BUMP UP SO IT'S SAME AFTER BXH
*
NODIV    DS    0H
         AR    #14,#5              DECREMENT TO NEXT DIVIDEND WORD
*
DIVLOOP  L     #7,0(#14,#3)        GET NEXT DIVIDEND WORD
         SLL   #7,1                MASH OUT SIGN BIT
         SRDL  #6,1                MASH BOTH WORDS RIGHT
         DR    #6,#0               DIVIDE BY A BILLION
         ST    #7,0(#14,#3)        STORE QUOTIENT IN SAME PLACE
         BXH   #14,#5,DIVLOOP      DO WE HAVE ANOTHER DIVIDEND WORD?
*
         CVD   #6,ZLCDBL           CONVERT REMAINDER TO GEN 9 DIGITS
         UNPK  0(9,#1),ZLCDBL+3(5) UNPACK INTO EBCDIC
         OI    8(#1),X'F0'         STAMP OUT DUMB SIGN CODE
         BXH   #2,#5,CVDLOOP       IS THE QUOTIENT 2 OR MORE WORDS?
*
         LA    #6,11               ROOM FOR 10 DIGITS AND 1 SIGN
         SR    #1,#6               BUMP DOWN POINTER BY THAT AMOUNT
*
         CVD   #7,ZLCDBL           LAST ONE, SIMPLY CVD QUOTIENT
         UNPK  1(10,#1),ZLCDBL+2(6) UNPACK INTO EBCDIC
         OI    10(#1),X'F0'        STAMP OUT DUMB SIGN CODE
*
******** B     BIGDONE             GO SCAN FOR LEADING ZEROES
         SPACE 1
BIGDONE  DS    0H                  OK, NOW CHOP OFF LEADING ZEROES
*                                  #1 POINTS TO SIGN + CVD'D STRING
*                                  #15 POINT PAST END OF STRING
LZLOOP   CLI   1(#1),C'0'          IS IT A ZERO CHARACTER?
         BNE   GOTFNZ              NOP, WE GOT THE FIRST REAL DIGIT
         LA    #1,1(,#1)           BUMP UP THE POINTER
         B     LZLOOP              GO BACK AND SEE IF THIS IS ZERO
GOTFNZ   DS    0H
         TM    ##VECDAT(#4),X'80'  WHAT'S THE SIGN OF THE BIGNUM?
         BZ    BNOTM               IT'S NOT MINUS
         MVI   0(#1),C'-'          IT'S MINUS, PUT IN THE MINUS SIGN
         LR    #0,#15              POINTER PAST END OF STRING
         SR    #0,#1               SUBTRACT BEGINNING TO GET LENGTH
         B     RETURN
BNOTM    DS    0H
         LR    #0,#15              POINTER PAST END OF STRING
         LA    #1,1(,#1)           NO SIGN, BUMP UP BEGINNING POINTER
         SR    #0,#1               SUBTRACT BEGINNING TO GET LENGTH
         B     RETURN
         SPACE 1
***********************************************************************
         EJECT
NOTBIG   DS    0H                  ELSE NOT A BIGNUM...
         SPACE 1
         TM    ##TYPE(#4),##VEC    IF THIS IS A VECTOR-TYPE OBJECT
         BO    ERRORV              (VECTOR, FUNARG OR STRUCTURE), ERROR
*                                  ELSE NONE OF THE ABOVE
         LA    #1,DUMPUNK          POINT TO UNKNOWN-OBJECT IDENTIFIER
         LA    #0,L'DUMPUNK        SET LENGTH
         B     RETURN
         EJECT
SLSTRING DS    0H                  SLASHIFY OR COPY A STRING
         SPACE 1
         #BAS  #14,GETSLWA         GET SLASHIFICATION WORK AREA
         TM    ZLCDFLGS,ZLCDSLSH   IF SLASHIFICATION NOT REQUESTED
         BZ    STRCOPY             THEN JUST DO STRING COPY
*                                  ELSE SLASHIFY THE STRING
         MVI   0(#3),C'"'          START OUT WITH A DOUBLE QUOTE
         LA    #14,1(,#3)          BUMP OUTPUT POINTER
         LTR   #7,#7               GET LENGTH OF STRING DATA
         BZ    SLSTREND            SKIP DUMP IF NULL STRING
         LA    #15,##VECDAT(,#4)   POINT TO PRINT NAME TEXT
SLSTRLOP DS    0H
         CLI   0(#15),C'"'         IF THIS CHARACTER NEEDS TO BE
         BE    SLSTRBS              SLASHED BECAUSE IT IS A
         CLI   0(#15),C'\'           DOUBLE QUOTE OR A BACKSLASH,
         BNE   SLSTRNS                THEN...
SLSTRBS  MVI   0(#14),C'\'          ADD A BACKSLASH (SINGLE ESCAPE)
         LA    #14,1(,#14)          AND BUMP OUTPUT POINTER
SLSTRNS  MVC   0(1,#14),0(#15)     MOVE STRING CHARACTER
         LA    #14,1(,#14)         BUMP OUTPUT POINTER
         LA    #15,1(,#15)         BUMP INPUT POINTER
         BCT   #7,SLSTRLOP         CONTINUE UNTIL STRING LENGTH ZERO
SLSTREND DS    0H
         MVI   0(#14),C'"'         END UP WITH A DOUBLE QUOTE
         LR    #1,#3               GET POINTER TO START OF OUTPUT TEXT
         LA    #0,1(,#14)          GET POINTER TO END OF OUTPUT TEXT
         SR    #0,#1               DIFFERENCE GIVES LENGTH OF TEXT
         B     RETURN
         EJECT
SLSYMBOL DS    0H                  SLASHIFY OR COPY A SYMBOL
         SPACE 1
         L     #2,##PNAME(,#2)     GET PRINT NAME OF SYMBOL
         LA    #2,0(,#2)           CLEAR HIGH ORDER BITS
         #BAS  #14,GETSLWA         GET SLASHIFICATION WORK AREA
         TM    ZLCDFLGS,ZLCDSLSH   IF SLASHIFICATION NOT REQUESTED
         BZ    STRCOPY             THEN JUST DO SYMBOL COPY
*                                  ELSE SLASHIFY THE STRING
*
* SLASHIFY THE ATOM TEXT.  POTENTIALLY PUT VERTICAL BARS AROUND IT.
*
         LTR   #7,#7               CHECK LENGTH OF PRINT NAME
         BZ    SLSYM               IF NULL PRINT NAME, GO SLASHIFY IT
         LA    #14,##VECDAT(,#4)   POINT TO BEGINNING OF STRING TEXT
         LR    #15,#7              GET SYMBOL PRINT NAME LENGTH
         LA    #5,256
SCANLOOP DS    0H
         CR    #15,#5              IF LENGTH IS 256 OR LESS
         BNH   DOTRT               THEN WE CAN SCAN EASILY
         TRT   0(256,#14),SYMTR0   ELSE SCAN FIRST 256 CHARACTERS
         BNZ   SLSYM               IF WE GOT ANY, PREPARE TO SLASHIFY
         SR    #15,#5              BUMP LENGTH DOWN
         BNP   TRTCHAR1            IF ALL SCANNED OK, GO CK 1ST CHAR
         LA    #14,256(,#14)       BUMP UP POINTER TO DATA TO SCAN
         B     SCANLOOP
DOTRT    DS    0H
         BCTR  #15,0               REDUCE LENGTH FOR EXECUTE
         EX    #15,SYMTR           SCAN FOR FUNNY CHARACTERS
         BNZ   SLSYM               IF WE GOT ANY, PREPARE TO SLASHIFY
TRTCHAR1 DS    0H
         TRT   ##VECDAT(1,#4),SYMTR1 SCAN FIRST CHAR FOR FUNNINESS
         BZ    NOSLSYM             IF NOT FUNNY, NO NEED TO SLASHIFY
* AT THIS POINT ALL CHARACTERS ARE OK BUT FIRST MAY SIGNAL NUMERIC.
* IF THIS IS STILL OK, WE MAY NOT HAVE TO SLASHIFY.
         CH    #7,=H'1'            IF LENGTH OF ATOM IS 1
         BH    CHECK$              THEN
         CLI   ##VECDAT(#4),C'0'    IF OFFENDING 1ST/ONLY CHAR NUMERIC
         BNL   SLSYM                 OR
         CLI   ##VECDAT(#4),C'.'      IT IS A PERIOD
         BE    SLSYM                   THEN WE MUST SLASHIFY
         B     NOSLSYM              ELSE NO NEED TO SLASHIFY
CHECK$   DS    0H                  ELSE LENGTH OF ATOM GREATER THAN 1
         CLI   ##VECDAT(#4),C'$'   IF STARTS WITH $,
         BNE   SL1NOT$             THEN...
         CLI   ##VECDAT+1(#4),C'$' IF STARTS WITH $$,
         BE    SLSYM               THEN MUST SLASHIFY
         B     NOSLSYM             ELSE $X, DON'T HAVE TO SLASHIFY
SL1NOT$  DS    0H
         CLI   ##VECDAT+1(#4),C'+' IF _+, NO NEED TO SLASHIFY
         BE    NOSLSYM
         CLI   ##VECDAT+1(#4),C'-' IF _-, NO NEED TO SLASHIFY
         BE    NOSLSYM
SLSYM    DS    0H                  SLASHIFY THE SYMBOL PRINT NAME
         MVI   0(#3),C'|'          START OUT WITH A DOUBLE ESCAPE
         LA    #14,1(,#3)          BUMP OUTPUT POINTER
         LTR   #7,#7               GET LENGTH OF STRING DATA
         BZ    SLSYMEND            SKIP DUMP IF NULL PRINT NAME
         LA    #15,##VECDAT(,#4)   POINT TO PRINT NAME TEXT
SLSYMLOP DS    0H
         CLI   0(#15),C'|'         IF THIS CHARACTER NEEDS TO BE
         BE    SLSYMBS              SLASHED BECAUSE IT IS A
         CLI   0(#15),C'\'           DOUBLE OR SINGLE ESCAPE,
         BNE   SLSYMNS                THEN...
SLSYMBS  MVI   0(#14),C'\'          ADD A BACKSLASH (SINGLE ESCAPE)
         LA    #14,1(,#14)          AND BUMP OUTPUT POINTER
SLSYMNS  MVC   0(1,#14),0(#15)     MOVE PRINT NAME CHARACTER
         LA    #14,1(,#14)         BUMP OUTPUT POINTER
         LA    #15,1(,#15)         BUMP INPUT POINTER
         BCT   #7,SLSYMLOP         CONTINUE TILL PRINT NAME LENGTH ZERO
SLSYMEND DS    0H
         MVI   0(#14),C'|'         END UP WITH A DOUBLE ESCAPE
         LR    #1,#3               GET POINTER TO START OF OUTPUT TEXT
         LA    #0,1(,#14)          GET POINTER TO END OF OUTPUT TEXT
         SR    #0,#1               DIFFERENCE GIVES LENGTH OF TEXT
         B     RETURN
         SPACE 1
NOSLSYM  DS    0H                  STRING IS NOT TO BE SLASHIFIED
         SPACE 1
         LA    #1,##VECDAT(,#4)    POINT TO STRING TEXT
         XR    #0,#0
         ICM   #0,7,1(#4)          GET STRING LENGTH
         B     RETURN
         SPACE 1
SYMTR    TRT   0(*-*,#14),SYMTR0   SCAN SYMBOL PRINT NAME
         EJECT
STRCOPY  DS    0H                  COPY STRING OR SYMBOL PRINT NAME
         SPACE 1
         LA    #14,##VECDAT(,#4)   SOURCE ADDRESS = STRING TEXT
         XR    #15,#15
         ICM   #15,7,1(#4)         SOURCE LENGTH = STRING TEXT LEN
         LR    #0,#3               DESTINATION ADDRESS = SL WORK AREA
         LR    #1,#15              DESTINATION LENGTH = STRING TEXT LEN
         MVCL  #0,#14              MOVE STRING TEXT TO WORK AREA
         LR    #1,#3               GET POINTER TO START OF OUTPUT TEXT
         SR    #0,#1               COMPUTE LENGTH OF OUTPUT TEXT
         B     RETURN
         EJECT
GETSLWA  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* THIS ROUTINE INSURES A WORKAREA FOR THE STRING POINTED TO BY #4.    *
* THE ADDRESS OF THE WORKAREA IS RETURNED IN #3 AND THE LENGTH OF     *
* THE INPUT STRING IS IN #7.  THE ADDRESS OF THE INPUT STRING IS      *
* PUT IN #4.                                                          *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    #4,#2               GET STRING ADDRESS
         XR    #7,#7
         ICM   #7,7,1(#4)          GET STRING LENGTH
         LR    #6,#7               COMPUTE MAXIMUM LENGTH OF
         SLA   #6,2                 SLASHIFIED STRING =
         LA    #6,2(,#6)             (2 * LENGTH) + 2
         C     #6,ZLCDWALN         IF LENGTH NOT AVAILABLE
         BNH   SLWALOK             THEN
         ICM   #1,15,ZLCDWA         GET CURRENT WORKAREA ADDRESS
         BZ    NOSLFREE             IF NONE, SKIP FREEMAIN
         L     #0,ZLCDWALN          GET LENGTH OF CURRENT WORKAREA
         FREEMAIN R,LV=(0),A=(1)    FREE IT
NOSLFREE DS    0H                  NOW PREPARE TO GET A BIGGER ONE
         LA    #6,7(,#6)           ROUND UP TO DOUBLEWORD BOUNDARY
         N     #6,=X'FFFFFFF8'
         #GETMAIN RC,LV=(#6),LOC=BELOW GET NEW WORKAREA
         LTR   #15,#15             IF STORAGE NOT AVAILABLE
         BNZ   ERROR8              THEN ERROR
         ST    #6,ZLCDWALN         SAVE NEW WORKAREA LENGTH
         ST    #1,ZLCDWA           SAVE NEW WORKAREA ADDRESS
SLWALOK  L     #3,ZLCDWA           OK, GET WORKAREA ADDRESS
         BR    #14
         EJECT
RETURN   DS    0H
*
* AT THIS POINT #1 POINTS TO THE TEXT TO BE RETURNED, #0 IS ITS LENGTH
*
         NI    ZLCDFLGS,255-ZLCDCOPY-ZLCDSLSH  TURN OFF FLAGS
         LM    #2,#7,ADMPSAVE+24   RESTORE REGISTERS
         LM    #12,#15,ADMPSAVE    RESTORE REGISTERS
         BR    #14                 RETURN TO CALLER
         EJECT
BAD31MSG DS    0H                  ILLEGAL BIGNUM DETECTED -2**31
         DMPER ERR2209              SHOULD BE A FIXNUM
         SPACE 2
ERROR0   DS    0H                  ERROR - A LIST
         DMPER ERR2200
         SPACE 2
ERRORV   DS    0H                  ERROR - A VECTOR
         DMPER ERR2201
         SPACE 2
ERROR2   DS    0H                  ERROR - NOT ENOUGH MEMORY
         XR    #0,#0               CLEAR WORK AREA FIELDS
         ST    #0,ZLCDWA           SO THAT NEXT ATTEMPT GETS NEW W/A
         ST    #0,ZLCDWALN
         DMPER ERR2202
         SPACE 2
ERROR8   DS    0H                  ERROR - NOT ENOUGH MEMORY
         XR    #0,#0               CLEAR WORK AREA FIELDS
         ST    #0,ZLCDWA           SO THAT NEXT ATTEMPT GETS NEW W/A
         ST    #0,ZLCDWALN
         DMPER ERR2208
         SPACE 2
NOMULT4  DS    0H                  BUG - BIGNUM LENGTH IS NOT MULTIPLE
         DMPER ERR2210             OF 4
         SPACE 2
SIZEBAD  DS    0H                  BUG - BIGNUM LENGTH LESS THAN 2
         DMPER ERR2203
         SPACE 2
DIG19ERR DS    0H                  BUG - 1ST DD OF 2WD BIG > 4Q
         DMPER ERR2204
         SPACE 2
BIGBAD   DS    0H                  BUG - WORD OTHER THAN LSW NOT +
         DMPER ERR2205
         SPACE 2
BADZERO  DS    0H                  BUG - WORD OTHER THAN LSW NOT +
         DMPER ERR2206
         SPACE 2
FLOBARF  DS    0H                  BUG - FLONUM FRACTIONAL PART BAD
         DMPER ERR2211
         SPACE 2
SIGNALER DS    0H
         TM    ZLCPFLGS,ZLCPRINT   IF CALLED BY ZILPRIN
         BZ    ZERROR              THEN...
         #TPUT 2,(1),(0)            DISPLAY ERROR MESSAGE
         LA    #1,DUMPERR           POINT TO ERROR-OBJECT IDENTIFIER
         LA    #0,L'DUMPERR         SET LENGTH
         B     RETURN               RETURN WITH UNKNOWN OBJECT
ZERROR   L     #15,ZLCERR          ELSE ERROR OUT
         BR    #15                 BY BRANCHING TO ZILERR
         SPACE 2
ADMPSAVE DS    12A                 SAVE AREA FOR REGISTERS
         SPACE
ATOMAREA DS    CL64                AREA TO DUMP NON-STRING ATOMS
         SPACE
DUMPUNK  DC    C'#<?>'             HOW TO DUMP UNKNOWN ATOMS
DUMPERR  DC    C'#<ERROR>'         HOW TO DUMP ERRORS
         SPACE
PATTERN  DC    X'F02020202020202020202020'  PATTERN MASK FOR EDITS
NUMAREA  DS    CL12                TEMP TO HOLD CONVERTED NUMBER
DNUMAREA DS    CL40                Temp to hold converted doubles
         SPACE
DWORK    DS    D                   Area for double float conversions
         SPACE
SYMTR0   DC    256YL1(0)           TABLE TO SCAN FOR SLASHIFIABILITY
         ORG   SYMTR0+C' '
         DC    YL1(1)              INVALID - MUST BE SLASHED
         ORG   SYMTR0+C','
         DC    YL1(1)              INVALID - MUST BE SLASHED
         ORG   SYMTR0+C'`'
         DC    YL1(1)              INVALID - MUST BE SLASHED
         ORG   SYMTR0+C'|'
         DC    YL1(1)              INVALID - MUST BE SLASHED
         ORG   SYMTR0+C'#'
         DC    YL1(1)              INVALID - MUST BE SLASHED
         ORG   SYMTR0+C'('
         DC    YL1(1)              INVALID - MUST BE SLASHED
         ORG   SYMTR0+C')'
         DC    YL1(1)              INVALID - MUST BE SLASHED
         ORG   SYMTR0+C'\'
         DC    YL1(1)              INVALID - MUST BE SLASHED
         ORG   SYMTR0+C';'
         DC    YL1(1)              INVALID - MUST BE SLASHED
         ORG   SYMTR0+C'"'
         DC    YL1(1)              INVALID - MUST BE SLASHED
         ORG   SYMTR0+C''''
         DC    YL1(1)              INVALID - MUST BE SLASHED
         ORG   SYMTR0+C'¢'
         DC    YL1(1)              INVALID - MUST BE SLASHED
*
* The following 2 table entries are to be activated when
* packages and rationals (respectively) are implemented.
*
*        ORG   SYMTR0+C':'         (for packages)
*        DC    YL1(1)              INVALID - MUST BE SLASHED
*        ORG   SYMTR0+C'/'         (for rationals)
*        DC    YL1(1)              INVALID - MUST BE SLASHED
*
         ORG   SYMTR0+C'A'-X'40'
         DC    9YL1(1)             INVALID - MUST BE SLASHED
         ORG   SYMTR0+C'J'-X'40'
         DC    9YL1(1)             INVALID - MUST BE SLASHED
         ORG   SYMTR0+C'S'-X'40'
         DC    8YL1(1)             INVALID - MUST BE SLASHED
         ORG
         SPACE
SYMTR1   DC    256YL1(0)           TRANSLATE TABLE TO SCAN FOR FIRST CH
         ORG   SYMTR1+C'+'
         DC    1YL1(1)             BEGINS WITH PLUS SIGN - SUSPICIOUS
         ORG   SYMTR1+C'-'
         DC    1YL1(1)             BEGINS WITH MINUS SIGN - SUSPICIOUS
         ORG   SYMTR1+C'.'
         DC    1YL1(1)             BEGINS WITH PERIOD - SUSPICIOUS
         ORG   SYMTR1+C'$'
         DC    1YL1(1)             BEGINS WITH DOLLAR SIGN - SUSPICIOUS
         ORG   SYMTR1+C'0'
         DC    10YL1(1)            BEGINS WITH NUMERIC - SUSPICIOUS
         ORG
         SPACE
BADTWO31 DC    YL1(##BIGNUM),AL3(8),X'80000000',F'1'
         SPACE
FRMASK   DS    0F
         DC    X'00000000'         40xxxxxx
         DC    X'0000000F'         3Fxxxxx0
         DC    X'000000FF'         3Exxxx00
         DC    X'00000FFF'         3Dxxx000
         DC    X'0000FFFF'         3Cxx0000
         DC    X'000FFFFF'         3Bx00000
         SPACE 1
DFRMASK  DS    0F
         DC    X'0000000000000000' 40xxxxxx xxxxxxxx
         DC    X'000000000000000F' 3Fxxxxxx xxxxxxx0
         DC    X'00000000000000FF' 3Exxxxxx xxxxxx00
         DC    X'0000000000000FFF' 3Dxxxxxx xxxxx000
         DC    X'000000000000FFFF' 3Cxxxxxx xxxx0000
         DC    X'00000000000FFFFF' 3Bxxxxxx xxx00000
         DC    X'0000000000FFFFFF' 3Axxxxxx xx000000
         DC    X'000000000FFFFFFF' 39xxxxxx x0000000
         DC    X'00000000FFFFFFFF' 38xxxxxx 00000000
         DC    X'0000000FFFFFFFFF' 37xxxxx0 00000000
         DC    X'000000FFFFFFFFFF' 36xxxx00 00000000
         DC    X'00000FFFFFFFFFFF' 35xxx000 00000000
         DC    X'0000FFFFFFFFFFFF' 34xx0000 00000000
         DC    X'000FFFFFFFFFFFFF' 33x00000 00000000
         SPACE 1
         LTORG
         SPACE 1
ERR2200  DC    C'ZIL2200 ZILADMP: OBJECT TO BE DUMPED IS A LIST, NOT ANX
                ATOM.'
ERR2201  DC    C'ZIL2201 ZILADMP: OBJECT TO BE DUMPED IS A VECTOR, FUNAX
               RG (LEXICAL CLOSURE) OR STRUCTURE.'
ERR2202  DC    C'ZIL2202 ZILADMP: NOT ENOUGH MEMORY TO DUMP BIGNUM.'
ERR2203  DC    C'ZIL2203 ZILADMP: BIGNUM LENGTH LESS THAN 2 WORDS.'
ERR2204  DC    C'ZIL2204 ZILADMP: SEVERE LOSSAGE IN 2-WORD BIGNUM CODE.X
               '
ERR2205  DC    C'ZIL2205 ZILADMP: A WORD OTHER THAN THE LEAST SIGNIFICAX
               NT WORD OF A BIGNUM IS NEGATIVE.'
ERR2206  DC    C'ZIL2206 ZILADMP: THE MOST SIGNIFICANT WORD OF A BIGNUMX
                IS ZERO (I.E. NOT NORMALIZED).'
ERR2208  DC    C'ZIL2208 ZILADMP: NOT ENOUGH MEMORY TO DUMP STRING TEXTX
               .'
ERR2209  DC    C'ZIL2209 ZILADMP: THE MOST NEGATIVE FIXNUM, -2**31, WASX
                REPRESENTED AS A BIGNUM - SERIOUS BUG, PLEASE REPORT.'
ERR2210  DC    C'ZIL2210 ZILADMP: BIGNUM LENGTH NOT A MULTIPLE OF 4.'
ERR2211  DC    C'ZIL2211 ZILADMP: INTERNAL ERROR FORMATTING FLONUM.'
         SPACE
         END
