         TITLE 'ZILINIT - ZIL 1.3 INITIALIZATION MODULE'
***********************************************************************
*                                                                     *
* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *
*                     All rights reserved.                            *
*                                                                     *
***********************************************************************
*                                                                     *
* THIS MODULE IS INVOKED VIA LINK FROM THE MAINLINE MODULE ZILMAIN    *
* WHENEVER A COMPILED ZIL MODULE IS STARTED.  IT ALLOCATES STORAGE    *
* FOR ALL REQUIRED USAGES, PROCESSES OPTION SPECIFICATIONS IF ANY,    *
* AND HANDLES THE OPENING OF ANY RELEVANT FILES.  NOTE THAT ZILTERM   *
* UNDOES ALL THESE THINGS.                                            *
*                                                                     *
***********************************************************************
*                                                                     *
* MODIFIED 09/84 SO THAT IT DOES NOT OPEN ALL FILES.  IT STILL LOOKS  *
* FOR ALL FILE NAMES OF THE ZIL FORMAT, SO THAT IT KNOWS HOW MUCH     *
* SYSTEM MEMORY TO RESERVE, BUT IT DOES NOT ACTUALLY OPEN THEM.       *
* THE ZILFGETI/ZILFGETO ROUTINE DOES THE ACTUAL OPEN WHEN ACCESS TO   *
* THE FILE IS REQUESTED (VIA READ, PRINT, ETC.).                      *
*                                                                     *
***********************************************************************
*                                                                     *
* MODIFIED 11/86.  CONS SPACE SIZE MINIMUM IS NOW IN FIELD MINCSS,    *
* WHICH IS CURRENTLY SET TO 12K TO ALLOW FOR OPTIMAL CODING OF THE    *
* VECTORIZED GARBAGE COLLECTOR.  ALSO, THE CONS SPACE SIZE IS ROUNDED *
* UP TO THE NEXT 4K BOUNDARY, NOT THE NEXT DOUBLEWORD AS BEFORE;      *
* HOWEVER, CODE TO INSURE THAT WE REALLY END UP WITH A MULTIPLE OF    *
* 4K FOR CONS SPACE HAS NOT BEEN ADDED YET.                           *
*                                                                     *
***********************************************************************
*                                                                     *
* 06/01/88 - Added ZILVALS.  See #ZCOM and #ZSUB.                     *
* 11/23/88 - New file block support for UNTYI-stuff.  See #ZCOM.      *
* 05/22/89 - Package cell defaults to NIL for uninterned symbols.     *
*                                                                     *
***********************************************************************
         GBLB  &ZILXA,&ZILVF,&ZILTSO
         #ZSYS
         EJECT
         #ZEQU ,                   DEFINE ALL EQUATES HERE
         EJECT
ZILINIT  CSECT
         AIF   (NOT &ZILXA).NOMODES
ZILINIT  RMODE 24
ZILINIT  AMODE 31
.NOMODES ANOP
         B     ZLAROUND-*(,#15)
         DC    YL1(ZLAR-*-1),C'ZILINIT &SYSDATE &SYSTIME'
ZLAR     EQU   *                   END OF IDENTIFIER
ZLAROUND DS    0H                  START OF CODE
         USING ZILINIT,#12
         USING ZLHEADER,#11
         USING ZLHOPTS,#2
         USING ZLFILBLK,#7
         STM   #14,#12,12(#13)     SAVE REGISTERS
         LR    #12,#15             SET UP BASE REGISTER
         LA    #11,4(,#1)          INPUT PARM +4 --> HEADER OF POINTERS
         L     #2,ZLHOPTA          POINT TO OPTIONS LIST
         ST    #11,HDRPTR          SAVE ADDRESS OF PROGRAM HEADER
         ST    #2,OPTPTR           SAVE ADDRESS OF OPTIONS
         ST    #1,MODPTR           SAVE ADDRESS OF MAIN MODULE
         EJECT
*
* SET UP A TEMPORARY SAVE AREA FOR SYSTEM FUNCTIONS
*
         LA    #1,TEMPSAVE
         ST    #1,8(,#13)
         ST    #13,4(,#1)
         LR    #13,#1
         EJECT
***********************************************************************
*                                                                     *
* MAP OF 24-BIT STORAGE IS AS FOLLOWS:                                *
*                                                                     *
*        ....................................................         *
*        .                                                  .         *
*        . AREA RETURNED TO OPERATING SYSTEM                .         *
*        .                                                  .         *
*        |==================================================|         *
*        |                                                  |         *
*        | THE PRINT NAME OF THE ATOM "NIL" (8 BYTES)       |         *
*        |                                                  |         *
*        |--------------------------------------------------|         *
*        |                                                  |         *
*        | THE PRINT NAME OF THE ATOM "T" (8 BYTES)         |         *
*        |                                                  |         *
*        |==================================================|         *
*        |                                                  |         *
*        | COMMON AREA (ADDRESSED BY REG 13, INCLUDES SA)   |         *
*        |                                                  |         *
* #13 -->|--------------------------------------------------|         *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
* MAP OF 31-BIT STORAGE IS AS FOLLOWS:                                *
*                                                                     *
*                                                                     *
*        |==================================================|         *
*        |                                                  |         *
*        | OBLIST HASH ARRAY                                |         *
*        |                                                  |         *
*        |==================================================|         *
*        |                                                  |         *
*        | PRINT STACK                                      |         *
*        |                                                  |         *
*        |==================================================|         *
*        |                                                  |         *
*        | THE SYMBOL "NIL" (24 BYTES RESERVED FOR IT)      |         *
*        |                                                  |         *
* #10 -->|==================================================|         *
*        |                                                  |         *
*        | CONS SPACE (REG 9 FLOATS AROUND IN HERE)         |         *
*        |                                                  |         *
*        |==================================================|         *
*        |                                                  |         *
*        | STRING AND VECTOR SPACE SECOND AREA (FOR GC)     |         *
*        |__________________________________________________|         *
*        |                                                  |         *
*        | STRING AND VECTOR SPACE (ADDRESSED BY ZLCVSADR)  |         *
*        |                                                  |         *
*        |==================================================|         *
*        |                                                  |         *
*        | SMALL FIXNUM TABLE (256*8=2048 BYTES)            |         *
*        |                                                  |         *
*        |==================================================|         *
*        |                                                  |         *
*        | THE SYMBOL "T" (24 BYTES RESERVED FOR IT)        |         *
*        |                                                  |         *
*  #8 -->|==================================================|         *
*        |                                                  |         *
*        | PUSH DOWN STACK (REG 11 FLOATS AROUND IN HERE)   |         *
*        |                                                  |         *
*        |--------------------------------------------------|         *
*                                                                     *
***********************************************************************
         SPACE 1
***********************************************************************
*                                                                     *
* NOTE:  ALL STORAGE IS ACQUIRED ONLY AFTER SPACE NEEDS HAVE BEEN     *
* DETERMINED FOR ALL FILES.  IN THIS WAY THE STORAGE REQUIREMENTS     *
* FOR I/O ARE INDEPENDENT OF THE MAIN PROGRAM'S SPECIFICATIONS.       *
*                                                                     *
***********************************************************************
         EJECT
*
* LOCATE ALL USER SPECIFIED FILE ALLOCATIONS AND RESERVE 32K FOR
* EACH OF THEM.  THEY WILL NOT BE OPENED AT THIS TIME:  THE FILE ACCESS
* ROUTINES WILL OPEN THEM WHEN THEY ARE REFERENCED.  IN THIS WAY WE
* AVOID CLOBBERING UNUSED OUTPUT FILES, AND ALSO PROVIDE A KLUDGEY
* MECHANISM FOR RESERVING CHUNKS OF 32K SYSTEM STORAGE.
*
* *** Eliminate this code as soon as we can get major spaces like VSS
*     above the line and we overhaul the ancient file system! ***
*
* SEARCH THE TASK INPUT/OUTPUT TABLE (TIOT) FOR FILE ALLOCATIONS OF
* THE DDNAME ZILI____ (FOR INPUT FILES) AND ZILO____ (FOR OUTPUT FILES)
*
         XR    #6,#6               INITIALIZE I/O MEMORY SIZE REQUIRED
         XR    #4,#4               CLEAR INSERT REGISTER
         L     #3,540              TCB ADDRESS
         L     #3,12(,#3)          TIOT ADDRESS
         LA    #3,24(,#3)          POINT TO FIRST TIOT ENTRY
TIOTLOOP DS    0H
         TM    1(#3),X'80'         IF THIS ENTRY IS NOT IN USE
         BO    TIOTNEXT            THEN SKIP IT
         CLC   4(4,#3),=C'ZILI'    IF THIS IS A ZIL INPUT FILE
         BE    TIOTFILE            THEN PROCESS IT
         CLC   4(4,#3),=C'ZILO'    IF THIS IS A ZIL OUTPUT FILE
         BE    TIOTFILE            THEN PROCESS IT
         CLC   4(8,#3),DRIBLDD     IF THIS IS THE ZIL DRIBBLE FILE
         BE    DRIBLFIL            THEN PROCESS IT
TIOTNEXT IC    #4,0(,#3)           ELSE GET LENGTH OF THIS ENTRY
         ALR   #3,#4               BUMP TO NEXT ENTRY
         CLI   0(#3),0             IF END OF TIOT
         BE    TIOTEND             THEN WE'RE THROUGH (NO MORE FILES)
         B     TIOTLOOP            ELSE CONTINUE LOOPING THRU TIOT
TIOTFILE DS    0H                  WE FOUND A FILE TO PROCESS
         CLI   8(#3),C' '          IF NOT DDNAMES "ZILI" AND "ZILO"
         BNE   ADD32K              (STANDARD FILES), RESERVE STORAGE
         CLI   7(#3),C'I'          IF THIS IS DDNAME ZILI
         BNE   NOTZILI             THEN
         ST    #3,TIOTZILI          SAVE TIOT ENTRY POINTER FOR ZILI
         B     TIOTNEXT
NOTZILI  DS    0H
         CLI   7(#3),C'O'          IF THIS IS DDNAME ZILO
         BNE   TIOTNEXT            THEN
         ST    #3,TIOTZILO          SAVE TIOT ENTRY POINTER FOR ZILO
         B     TIOTNEXT
         SPACE 1
DRIBLFIL DS    0H                  IF THIS IS THE DRIBBLE DDNAME
         ST    #3,TIOTDRIB         INDICATE DRIBBLE FILE PRESENT
******** B     ADD32K              AND RESERVE STORAGE TO PROCESS IT
         SPACE 1
ADD32K   DS    0H                  OTHERWISE NOT A STANDARD FILE...
         A     #6,=F'32768'        ADD APPROXIMATE MEMORY REQUIRED
         B     TIOTNEXT            GO GET THE NEXT DD ENTRY
         SPACE 2
TIOTEND  DS    0H                  ALL DDNAMES PROCESSED
         EJECT
*
* INITIALIZE FILE BLOCKS FOR ZILIN AND ZILOUT
*
         SPACE 1
*
* OPEN THE STANDARD OUTPUT FILE
*
         LA    #0,ZLFBLEN          GET LENGTH OF AN INPUT FILE BLOCK
         #GETMAIN RU,LV=(0),LOC=BELOW
         LR    #7,#1
         ST    #7,OFPTR            STORE PTR TO FIRST OUTPUT FILE BLOCK
         XC    ZLFILBLK(ZLFBLEN),ZLFILBLK
         OI    ZLFFLAG,ZLFSYSPR
         MVC   ZLFPDDN(8),OUTDD
         LA    #1,1
         ST    #1,ZLFCHAR          CHARACTER POSITION = 1
         MVC   ZLFDCB(96),OUTDDDCB SET UP DCB
         ICM   #15,15,TIOTZILO     GET ADDRESS OF TIOT ENTRY FOR ZILO
         BZ    TERMZILO            IF NONE, USE TERMINAL OUTPUT
         TM    3(#15),X'20'        IF TIOT ENTRY SAYS IT'S A TERMINAL
         BO    TERMZILO            IF NONE, USE TERMINAL OUTPUT
         LA    #1,ZLFDCB
         ST    #1,OPENL
         MVI   OPENL,X'8F'         OPEN FOR OUTPUT
         AIF   (NOT &ZILXA).SKIP1
*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24
         LA    #1,OPENO24          ADDRESS OF THIS CODE
         LA    #2,OPENO24E         RETURN ADDRESS
         BSM   #2,#1
OPENO24  DS    0H
*---------------------------------THE AMODE IS NOW 24
.SKIP1   ANOP
         LA    #1,OPENL
         OPEN  MF=(E,(1))
         AIF   (NOT &ZILXA).SKIP2
*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE
         BSM   0,#2
OPENO24E DS    0H
*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY
.SKIP2   ANOP
         TM    ZLFDCB+X'30',X'10'
         BZ    OUTNOPEN
*                                  CHECK RECFM OF OPEN OUTPUT FILE
         TM    ZLFDCB+36,X'40'     IF RECFM = V....
         BZ    FNOUTOK             THEN...
         TM    ZLFDCB+36,X'80'
         BO    FNOUTOK
         OI    ZLFFLAG2,ZLFRECV     INDICATE SO IN FILE BLOCK
FNOUTOK  DS    0H
         AIF   (NOT &ZILXA).SKIP3
*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24
         LA    #1,PUTO24           ADDRESS OF THIS CODE
         LA    #2,PUTO24E          RETURN ADDRESS
         BSM   #2,#1
PUTO24   DS    0H
*---------------------------------THE AMODE IS NOW 24
.SKIP3   ANOP
         LA    #1,ZLFDCB
         PUT   (1)                 DO THE INITIAL PUT LOCATE
         AIF   (NOT &ZILXA).SKIP4
*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE
         BSM   0,#2
PUTO24E  DS    0H
*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY
.SKIP4   ANOP
         LH    #0,ZLFDCB+82        GET DCB LRECL
         TM    ZLFFLAG2,ZLFRECV    IF RECFM=V FILE
         BZ    NOTRECVO            THEN...
         TM    ZLFDCB+36,X'04'      IF RECFM = V.A
         BZ    NOTRECVA             THEN...
         STH   #0,0(,#1)            INITIALIZE RDW
         XC    2(2,#1),2(#1)
         MVI   4(#1),C'1'           INITIALIZE PRINT CONTROL CHAR
         LA    #1,5(,#1)            BUMP PAST RDW TO TEXT
         SH    #0,=H'5'             SET LENGTH OF ACTUAL TEXT
         B     NOTRECFA
NOTRECVA DS    0H                  RECFM = V(B), NOT A
         STH   #0,0(,#1)            INITIALIZE RDW
         XC    2(2,#1),2(#1)
         LA    #1,4(,#1)            BUMP PAST RDW TO TEXT
         SH    #0,=H'4'             SET LENGTH OF ACTUAL TEXT
         B     NOTRECFA
NOTRECVO DS    0H
         TM    ZLFDCB+36,X'04'     IF RECFM = F.A
         BZ    NOTRECFA            THEN...
         MVI   0(#1),C'1'           INITIALIZE PRINT CONTROL CHAR
         LA    #1,1(,#1)            BUMP POINTER PAST CONTROL CHAR
         BCTR  #0,0                 SUBTRACT 1 FOR PRINT CONTROL CHAR
NOTRECFA DS    0H
         ST    #1,ZLFCARD          STORE CURRENT RECORD ADDRESS
         STH   #0,ZLFLRECL         STORE RECORD LENGTH
         B     CLEAROUT
TERMZILO DS    0H                  (STANDARD OUTPUT FROM THE TERMINAL)
         L     #15,X'224'          ASCB ADDRESS
         ICM   #15,15,X'3C'(#15)   TSB ADDRESS
         BZ    OUTNOPEN            IF NO TSB, NOT UNDER TSO, NEED FILE
         OI    ZLFFLAG,ZLFTERM     INDICATE SO IN FILE BLOCK
         OI    ZLFFLAG2,ZLFTABS    SET TABS MODE ON FOR FILE
         LA    #1,ZLFLINE          (NO PRINT CONTROL CHARACTER)
         ST    #1,ZLFCARD          RESET ADDRESS OF RECORD
         LA    #0,78               RESET RECORD LENGTH TO 78
         STH   #0,ZLFLRECL         RESET LINE LENGTH
CLEAROUT DS    0H
         ALR   #1,#0               ZLFCARD + ZLFLRECL ...
         ST    #1,ZLFEND           RESET END-OF-RECORD POINTER
         LA    #15,X'40'           SOURCE LENGTH = 0
         SLL   #15,24              FILL = BLANK
         XR    #14,#14             SOURCE = NULL
         L     #0,ZLFCARD          TARGET = OUTPUT AREA
         LH    #1,ZLFLRECL         LENGTH = LENGTH OF OUTPUT AREA
         MVCL  #0,#14              CLEAR OUTPUT AREA TO BLANKS
STDOUNT  DS    0H
         OI    ZLFFLAG2,ZLFOPEN    MARK FILE OPEN
         EJECT
*
* OPEN THE STANDARD INPUT FILE
*
         LA    #0,ZLFBLEN          GET LENGTH OF AN INPUT FILE BLOCK
         #GETMAIN RU,LV=(0),LOC=BELOW
         LR    #7,#1
         ST    #7,IFPTR            STORE PTR TO FIRST INPUT FILE BLOCK
         XC    ZLFILBLK(ZLFBLEN),ZLFILBLK
         OI    ZLFFLAG,ZLFINPUT+ZLFSYSIN
         MVC   ZLFPDDN(8),INDD
         XR    #1,#1               TO ENABLE ZILGETC TO READ THE
         BCTR  #1,0                FIRST RECORD WHEN CALLED FIRST,
         ST    #1,ZLFCHAR          SET CHARACTER POSITION = -1
         MVC   ZLFDCB(96),INDDDCB  SET UP DCB
         ICM   #15,15,TIOTZILI     GET ADDRESS OF TIOT ENTRY FOR ZILI
         BZ    TERMZILI            IF NONE, USE TERMINAL INPUT
         TM    3(#15),X'20'        IF TIOT ENTRY SAYS IT'S A TERMINAL
         BO    TERMZILI            IF NONE, USE TERMINAL INPUT
         LA    #1,ZLFDCB
         ST    #1,OPENL
         MVI   OPENL,X'80'         OPEN FOR INPUT
         AIF   (NOT &ZILXA).SKIP5
*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24
         LA    #1,OPENI24          ADDRESS OF THIS CODE
         LA    #2,OPENI24E         RETURN ADDRESS
         BSM   #2,#1
OPENI24  DS    0H
*---------------------------------THE AMODE IS NOW 24
.SKIP5   ANOP
         LA    #1,OPENL
         OPEN  MF=(E,(1))
*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE
         AIF   (NOT &ZILXA).SKIP6
         BSM   0,#2
OPENI24E DS    0H
*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY
.SKIP6   ANOP
         TM    ZLFDCB+X'30',X'10'
         BNO   INNOPEN
         LH    #0,ZLFDCB+82        SET LINE LENGTH TO DCB LRECL - 8
         SH    #0,=H'8'            SUBTRACT 8 FOR LINE NUMBER FIELD
*                                  (ZLFCARD/ZLFEND NOT SET UNTIL READ)
         B     STDINNT
TERMZILI DS    0H                  (STANDARD INPUT IS TO THE TERMINAL)
         L     #15,X'224'          ASCB ADDRESS
         ICM   #15,15,X'3C'(#15)   TSB ADDRESS
         BZ    INNOPEN             IF NO TSB, NOT UNDER TSO, NEED FILE
         OI    ZLFFLAG,ZLFTERM     INDICATE SO IN FILE BLOCK
         LA    #0,80               SET LINE LENGTH TO 80
         LA    #1,ZLFLINE          FOR TERMINAL, RECORD AREA EXISTS
         ST    #1,ZLFCARD          SO POINT TO RECORD AREA
         ALR   #1,#0               ADD LINE LENGTH
         ST    #1,ZLFEND           SET END-OF-RECORD POINTER
STDINNT  DS    0H
         STH   #0,ZLFLRECL         SET RECORD LENGTH FOR FILE
         OI    ZLFFLAG2,ZLFOPEN    MARK FILE OPEN
         EJECT
*
* OPEN THE DRIBBLE FILE IF PRESENT
*
         ICM   #1,15,TIOTDRIB      IF THERE IS A DRIBBLE FILE,
         BZ    NODRIB              THEN...
         LA    #0,96               GET LENGTH OF A DCB
         #GETMAIN RU,LV=(0),LOC=BELOW
         ST    #1,TIOTDRIB         SAVE DCB ADDRESS
         MVC   0(96,#1),DRIBLDCB   SET UP DCB
         ST    #1,OPENL
         MVI   OPENL,X'8F'         OPEN FOR OUTPUT
         AIF   (NOT &ZILXA).SKIP7
*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24
         LA    #1,DRIB24           ADDRESS OF THIS CODE
         LA    #2,DRIB24E          RETURN ADDRESS
         BSM   #2,#1
DRIB24   DS    0H
*---------------------------------THE AMODE IS NOW 24
.SKIP7   ANOP
         LA    #1,OPENL
         OPEN  MF=(E,(1))
         AIF   (NOT &ZILXA).SKIP8
*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE
         BSM   0,#2
DRIB24E  DS    0H
*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY
.SKIP8   ANOP
         SPACE 1
NODRIB   DS    0H
         SPACE 1
         L     #13,4(,#13)         RELEASE TEMPORARY SAVEAREA
         EJECT
***********************************************************************
*                                                                     *
* COMPUTE THE AMOUNT OF STORAGE NEEDED FOR THE FOLLOWING AREAS:       *
*    PUSH-DOWN STACK                                                  *
*    CONS SPACE                                                       *
*    VECTOR/STRING SPACE                                              *
*    OTHER MISCELLANEOUS SPACES (FIXED IN SIZE)                       *
* LEAVE SOME OVER FOR THE OPERATING SYSTEM (AT LEAST 32K)             *
*                                                                     *
* FIRST, AS MUCH STORAGE AS WILL BE NEEDED IS ALLOCATED BELOW 16MB.   *
* THIS STORAGE IS DIVIDED UP AS FOLLOWS:                              *
*    (1) COMMON AREA - LENGTH IS THE CONSTANT VALUE "ZLCCOMLN"        *
*    (2) THE PRINT NAME OF THE ATOM "T" - LENGTH IS 8 BYTES           *
*    (3) THE PRINT NAME OF THE ATOM "NIL" - LENGTH IS 8 BYTES         *
*    (4) AREA RETURNED TO OPERATING SYSTEM - MINIMUM LENGTH IS 32K    *
*   THE VALUE IN (4) IS SUBTRACTED FROM THE TOTAL GETMAINED LENGTH    *
* AND FREEMAINED.  THEN THE LENGTHS OF THE COMMON AREA AND THE PRINT  *
* NAMES ARE SUBTRACTED FROM THE REMAINING TOTAL AND ADDRESSES ARE     *
* ASSIGNED.  THE REMAINDER IS THE LENGTH OF VECTOR/STRING SPACE.      *
*                                                                     *
* THEN, AS MUCH STORAGE AS WILL BE NEEDED IS ALLOCATED ABOVE 16MB.    *
* THIS STORAGE IS DIVIDED UP AS FOLLOWS:                              *
*    (1) PUSH DOWN STACK - LENGTH IS FROM OPTIONS, DEFAULT IS (DEFPDS)*
*    (2) THE SYMBOL "T" - WE RESERVE (TSIZE) BYTES                    *
*    (3) CONS SPACE - MINIMUM LENGTH IS (MINCSS), DEFAULT IS (DEFCSS) *
*    (4) THE SYMBOL "NIL" - WE RESERVE (##SYMLEN) BYTES               *
*    (5) PRINT STACK - LENGTH IS VALUE OF "PSSIZE"                    *
*    (6) OBLIST HASH ARRAY - LENGTH IS 64K*4 = 256K                   *
*    (7) SMALL FIXNUM TABLE - LENGTH IS 256*8 = 2048 (2K)             *
*    (8) VECTOR/STRING SPACES (2) - MINIMUM LENGTH OF EACH IS 4K      *
* THEN THE LENGTHS OF THE PUSH DOWN STACK AND THE FIXED-SIZE AREAS    *
* ARE SUBTRACTED FROM THE REMAINING TOTAL AND ADDRESSES ARE ASSIGNED. *
* THE REMAINDER IS THE LENGTH OF CONS SPACE, WHICH IS NOT             *
* INITIALIZED UNTIL GARBAGE COLLECTION TIME.                          *
*                                                                     *
* NOTE THAT THE LENGTH OF ALL AREAS MUST BE ROUNDED UP TO MULTIPLES   *
* OF 8 TO INSURE A VALID FREE LIST.                                   *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
* PROCESS INITIALIZATION SPECS FROM PARM FIELD                        *
*                                                                     *
***********************************************************************
         SPACE 1
         L     #1,4(,#13)          GET ADDRESS OF ZILMAIN'S SAVE AREA
         L     #1,24(,#1)          GET ORIGINAL PARM POINTER
         AIF   (NOT &ZILTSO).PGMCALL
*----------------------------------------------------------------------
* TSO ONLY
*----------------------------------------------------------------------
         TM    0(#1),X'80'         IF THERE IS 1 PARAMETER
         BO    PGMCALL              THEN WE WERE CALLED AS A PROGRAM
         TM    4(#1),X'80'         IF THERE ARE 2 PARAMETERS
         BO    PGMCALL              THEN WE WERE CALLED AS A PROGRAM
         TM    8(#1),X'80'         IF THERE ARE 3 PARAMETERS
         BO    PGMCALL              THEN WE WERE CALLED AS A PROGRAM
*                                  ELSE WE WERE CALLED AS A COMMAND
         USING CPPL,#1
         L     #2,CPPLCBUF         GET ADDRESS OF COMMAND BUFFER
         LH    #0,0(,#2)           GET LENGTH OF COMMAND BUFFER
         AR    #0,#2               POINT TO END OF COMMAND BUFFER
         LH    #1,2(,#2)           GET OFFSET OF COMMAND TEXT
         LA    #1,4(#1,#2)         POINT TO START OF COMMAND TEXT
         SR    #0,#1               GET LENGTH OF COMMAND TEXT
         B     GOTIT
*----------------------------------------------------------------------
* END TSO ONLY
*----------------------------------------------------------------------
.PGMCALL ANOP
PGMCALL  DS    0H
         L     #1,0(,#1)           GET ADDRESS OF PARM STRING
         LH    #0,0(,#1)           GET LENGTH OF PARM STRING
         LA    #1,2(,#1)           POINT TO TEXT OF PARM
GOTIT    DS    0H                  #1 = ADDRESS, #0 = LENGTH
* GET THE TRUE PARM, NOT INCLUDING LEADING DATA ENCLOSED IN BACKSLASHES
         LTR   #0,#0               IF PARM LENGTH IS ALREADY ZERO
         BZ    NOPARM              THEN NOTHING TO PROCESS
         CLI   0(#1),C'\'          IF PARM DOESN'T BEGIN WITH BACKSLASH
         BNE   NOPARM              THEN NOTHING TO PROCESS
         AR    #0,#1               MAKE #0 POINT TO END OF PARM STRING
         LA    #1,1(,#1)           POINT TO FIRST CHARACTER IN SPECS
         LR    #2,#1               SET KEYWORD POINTER
         XR    #3,#3               SET KEYWORD LENGTH TO ZERO
         XR    #4,#4               SET VALUE POINTER TO ZERO
         XR    #5,#5               SET VALUE LENGTH TO ZERO
         SPACE 1
***********************************************************************
*                                                                     *
* START SCANNING FOR INITIALIZATION PARAMETERS.                       *
*                                                                     *
* NOTE: DON'T USE REGISTER 6!                                         *
*                                                                     *
***********************************************************************
         SPACE 1
PLOOP    DS    0H
         CR    #1,#0               IF END OF PARM STRING
         BNL   PFINISH             THEN GO TO FINISH UP PARM SPECS
         CLI   0(#1),C'\'          IF END OF PARM
         BE    PFINISH             THEN GO TO FINISH UP PARM SPECS
         CLI   0(#1),C','          IF COMMA
         BE    PCOMMA              THEN PROCESS COMMA
         CLI   0(#1),C'='          IF EQUAL SIGN
         BE    PEQUAL              THEN PROCESS EQUAL SIGN
         CH    #3,=Y(L'PKEY)       IF KEYWORD LENGTH EXCEEDS MAX
         BH    PERROR              THEN ERROR
         LA    #3,1(,#3)            INCREMENT KEYWORD LENGTH
         LA    #1,1(,#1)
         B     PLOOP               CONTINUE SCAN
PEQUAL   DS    0H                  EQUAL SIGN - PROCESS VALUE
         LTR   #3,#3               IF KEYWORD LENGTH IS ZERO (NO KWD)
         BZ    PERROR              THEN SYNTAX ERROR
         BCTR  #3,0                ELSE REDUCE LENGTH FOR EXECUTE
         MVI   PKEY,C' '           CLEAR KEYWORD AREA TO BLANKS
         MVC   PKEY+1(L'PKEY-1),PKEY
         EX    #3,MVCPKEY          MOVE KEYWORD FROM PARM FIELD TO OURS
         LA    #14,PTABLE          POINT TO KEYWORD TABLE
PTLOOP   DS    0H
         CLI   0(#14),X'FF'        IF KEYWORD NOT FOUND IN TABLE
         BE    PERROR              THEN SYNTAX ERROR
         EX    #3,CLCPKEY          COMPARE KEYWORD WITH TABLE ENTRY
         BE    PKGOT               IF MATCH, THEN GOT IT
         LA    #14,12(,#14)        ELSE TRY NEXT TABLE ENTRY
         B     PTLOOP
PKGOT    DS    0H                  FOUND THE RIGHT KEYWORD
         L     #14,8(,#14)         LOAD POINTER TO WHERE TO STORE VAL
         LA    #1,1(,#1)           POINT TO CHARACTER FOLLOWING =
         XR    #2,#2               CLEAR KEYWORD POINTER
         XR    #3,#3               CLEAR KEYWORD LENGTH
         LR    #4,#1               SET VALUE POINTER
         XR    #5,#5               SET VALUE LENGTH
PLOOP2   DS    0H                  NOW SCAN VALUE
         CR    #1,#0               IF END OF PARM STRING
         BNL   PFINISH             THEN GO TO FINISH UP PARM SPECS
         CLI   0(#1),C'\'          IF END OF PARM
         BE    PFINISH             THEN GO TO FINISH UP PARM SPECS
         CLI   0(#1),C','          IF COMMA
         BE    PCOMMA              THEN PROCESS COMMA
         CH    #5,=Y(L'PVAL)       IF VALUE LENGTH EXCEEDS MAX
         BH    PERROR              THEN ERROR
         LA    #5,1(,#5)           ELSE INCREMENT LENGTH
         LA    #1,1(,#1)
         B     PLOOP2              CONTINUE SCAN
PFINISH  DS    0H
         LR    #1,#0               MAKE IT LOOK LIKE WE'RE FINISHED
PCOMMA   DS    0H                  COMMA - PROCESS KEYWORD=VALUE PAIR
         LTR   #3,#3               IF WE ARE CURRENTLY IN A KEYWORD
         BNZ   PERROR              THEN SYNTAX ERROR - K W/O VALUE
         LTR   #5,#5               IF THERE IS NO VALUE
         BZ    PAFTCOM             THEN JUST SKIP THIS
         BCTR  #5,0                ELSE REDUCE LENGTH FOR EXECUTE
         MVI   PVAL,C' '           CLEAR VALUE AREA TO BLANKS
         MVC   PVAL+1(L'PVAL-1),PVAL
         EX    #5,MVCPVAL          MOVE VALUE FROM PARM FIELD TO OURS
         XR    #3,#3               SET MULTIPLIER SHIFT TO 0: 2**0=1
         LA    #15,PVAL+1-1(#5)    POINT TO LAST CHARACTER OF VALUE
         CLI   0(#15),C'K'         IF VALUE ENDS IN K
         BNE   PNOTK               THEN
         LA    #3,10               SET MULTIPLIER SHIFT TO 10: 2**10=1K
         BCTR  #5,0                DECREMENT LENGTH
         B     PAFTM               ELSE
PNOTK    CLI   0(#15),C'M'         IF VALUE ENDS IN M
         BNE   PAFTM               THEN
         LA    #3,20               SET MULTIPLIER SHIFT TO 20: 2**20=1M
         BCTR  #5,0                DECREMENT LENGTH
         B     PAFTM               ELSE
PAFTM    DS    0H                  #5 = LENGTH OF ACTUAL NUM LESS 1
         LTR   #5,#5               GET (LENGTH-1) OF NUMERIC
         BM    PERROR              IF LESS THAN ZERO, ERROR
         CH    #5,=H'9'            IF GREATER THAN 2**31-1, ERROR
         BH    PERROR
         BL    PNCHECK
         CLC   PVAL(10),=C'2147483647'
         BH    PERROR
PNCHECK  EX    #5,TRTVAL           CHECK FOR ALL NUMERICS
         BNZ   PERROR
         EX    #5,PACKVAL          CONVERT TO PACKED DECIMAL
         CVB   #4,PDBL             AND THEN TO BINARY
         SLA   #4,0(#3)            SHIFT FOR POSSIBLE K OR M MULTIPLIER
         BO    PERROR              IF OVERFLOW, ERROR
         ST    #4,0(,#14)          SET XXSIZE VALUE ACCORDING TO TABLE
PAFTCOM  DS    0H                  FINISHED PROCESSING COMMA, PROCEED
         LA    #2,1(,#1)           SET KEYWORD POINTER
         XR    #3,#3               CLEAR KEYWORD LENGTH
         MVI   PVAL,C' '           CLEAR VALUE AREA TO BLANKS
         MVC   PVAL+1(L'PVAL-1),PVAL
         LA    #4,PVAL             SET VALUE POINTER
         XR    #5,#5               SET VALUE LENGTH
         B     PNEXT               CONTINUE SCAN
PNEXT    DS    0H                  CONTINUE SCAN
         CR    #1,#0               IF AT END
         BNL   NOPARM              THEN FINISHED
         LA    #1,1(,#1)           ELSE GET NEXT CHARACTER
         B     PLOOP
         SPACE 1
PERROR   DS    0H                  ERROR IN PARM FIELD
         L     #1,=A(ZIL0002)
         WTO   MF=(E,(1)),ROUTCDE=11
         B     NOPARM
         SPACE 2
MVCPKEY  OC    PKEY(*-*),0(#2)     MOVE KEYWORD FROM PARM FIELD TO OURS
MVCPVAL  OC    PVAL(*-*),0(#4)     MOVE VALUE FROM PARM FIELD TO OURS
CLCPKEY  CLC   PKEY(*-*),0(#14)    COMPARE KEYWORD WITH TABLE ENTRY
TRTVAL   TRT   PVAL(*-*),PTRTTBL   EXECUTED: SCAN FOR ALL NUMERICS
PACKVAL  PACK  PDBL(8),PVAL(*-*)   EXECUTED: CONVERT TO PACKED DECIMAL
         SPACE 2
PDBL     DS    D                   PLACE TO CONVERT NUMERICS
PKEY     DS    CL8                 PLACE TO STORE KEYWORD
PVAL     DS    CL11                PLACE TO STORE VALUE
         SPACE 1
PTABLE   DS    0A                  TABLE OF KEYWORDS
         DC    C'PDSIZE  ',A(PDSIZE)
         DC    C'CSSIZE  ',A(CSSIZE)
         DC    C'VSSIZE  ',A(VSSIZE)
         DC    C'ACSIZE  ',A(ACSIZE)
         DC    X'FF'               END OF TABLE
         SPACE 2
PTRTTBL  DC    256YL1(1)
         ORG   PTRTTBL+C'0'
         DC    10YL1(0)
         ORG   ,
NOPARM   DS    0H
         EJECT
***********************************************************************
* COMPUTE STORAGE FOR:  AREA24 = COMMON + PNAME(T) + PNAME(NIL)       *
*                       AREA31 = STACK + SYMBOL(T) + CONS + FIXNUMS + *
*                                VSS(1) + VSS(2) +                    *
*                                SYMBOL(NIL) + PRINTSTACK + OBHASH    *
***********************************************************************
         SPACE 1
         A     #6,=F'32768'        TOTAL AMOUNT RESERVED FOR OS
         L     #2,OPTPTR           GET ADDRESS OF OPTIONS
         LA    #8,COMLEN           GET LENGTH OF COMMON AREA
         LA    #4,LMODELT+LMODELNL(#6,#8) ADD LENGTHS OF T/NIL PNAMES
*                                  PLUS OS SIZE
*                                  THAT GIVES THE LENGTH OF AREA24
         SPACE 1
         #GETMAIN RC,LV=(#4),LOC=BELOW GET 24-BIT STORAGE
         LTR   #15,#15
         BNZ   ERR0001
         ST    #1,AREA24A          STORE ADDRESS OF 24-BIT AREA
         ST    #4,AREA24L          STORE ADDRESS OF 24-BIT AREA
         LR    #9,#1               SAVE ADDRESS OF 24-BIT AREA (COMMON)
         LR    #14,#4              PICK UP LENGTH OF 24-BIT AREA
         SR    #14,#6              SUBTRACT AMOUNT RESERVED FOR OS
         AR    #1,#14              POINT TO AREA TO BE GIVEN BACK TO OS
         LR    #0,#6               LOAD LENGTH TO BE FREED
         FREEMAIN RU,LV=(0),A=(1)  FREE THE AREA FOR THE OS
         ST    #14,AREA24L         ADJUST LENGTH, NO MORE OS MEM ALLOC
*
* CLEAR THE COMMON AREA TO ZEROES
*
         LR    #14,#9              MVCL ADDRESS OF COMMON AREA
         LR    #15,#8              MVCL LENGTH OF COMMON AREA
         XR    #0,#0               MVCL ADDRESS OF DATA TO MOVE (NONE)
         XR    #1,#1               MVCL LENGTH OF DATA TO MOVE (NONE)
         MVCL  #14,#0              MOVE HEX ZEROES TO COMMON AREA
*
* CHAIN THE COMMON AREA SAVE AREA.   NOW WE CAN CALL SYSTEM FUNCTIONS
*
         ST    #9,8(,#13)          CHAIN SAVE AREAS TOGETHER
         ST    #13,4(,#9)
         LR    #13,#9
         USING ZLCOMMON,#13
*
* NOW GET AREA31: MINIMUM SIZE = PDSIZE + 16 + MINCSS + PRINTSTACKSIZE
*                                + VSSIZE
*                                + 256K FOR OBLIST HASH ARRAY
*                                + 2K FOR SMALL FIXNUM TABLE
*                 MAXIMUM SIZE = PDSIZE + 16 + CSSIZE + PRINTSTACKSIZE
*                                + VSSIZE
*                                + 256K FOR OBLIST HASH ARRAY
*                                + 2K FOR SMALL FIXNUM TABLE
*
         ICM   #6,15,PDSIZE        GET INIT PUSH DOWN STACK SIZE
         BNZ   USEPD               IF SPECIFIED, USED IT
         ICM   #6,15,ZLHPDSIZ      ELSE GET MODULE PUSH DOWN STACK SIZE
         BNZ   USEPD               IF SPECIFIED, USED IT
         L     #6,DEFPDS           ELSE USE DEFAULT FOR PDSIZE
USEPD    LA    #6,7(,#6)           ROUND UP TO DOUBLEWORD BOUNDARY
         N     #6,=X'FFFFFFF8'
         LA    #3,##SYMLEN+TSIZE(,#6) STACK SIZE + LENGTHS OF T, NIL
         A     #3,PSSIZE            + PRINT STACK SIZE
         A     #3,OHSIZE            + OBLIST HASH ARRAY SIZE
         A     #3,SFSIZE            + SMALL FIXNUM TABLE SIZE
*
* NOW COMPUTE MINIMUM AND MAXIMUM BY ADDING VSSIZE AND CSSIZE...
*
         L     #4,MINVSS           ADD 2 TIMES 4K FOR MINIMUM VSS
         A     #4,MINCSS           ADD MINIMUM CONS SPACE SIZE
         AR    #4,#3               THAT'S MINIMUM LEN OF AREA31
*
* ADD REQUESTED VSSIZE AND CSSIZE TO AMOUNT SO FAR TO GET MAXIMUM
*
         ICM   #1,15,VSSIZE        GET INIT VECTOR/STRING SPACE SIZE
         BNZ   USEVS               IF SPECIFIED, USED IT
         ICM   #1,15,ZLHVSSIZ      ELSE GET MODULE VECTOR/STRING SIZE
         BNZ   USEVS               IF SPECIFIED, USED IT
         L     #1,=A(1024*1024)    ELSE USE DEFAULT OF 1M
USEVS    LA    #14,7(,#1)          ROUND UP TO DOUBLEWORD BOUNDARY
         N     #14,=X'FFFFFFF8'
         SLA   #14,1               MULTIPLY BY 2 FOR TWO SPACES
         AR    #3,#14              ADD TO TOTAL SIZE SO FAR
         SRA   #14,1               GET LENGTH OF SINGLE V/S SPACE
         ST    #14,VSSIZE          SET TOTAL VECTOR/STRING SPACE SIZE
         ICM   #1,15,CSSIZE        GET INIT CONS SPACE SIZE
         BNZ   USECS               IF SPECIFIED, USED IT
         ICM   #1,15,ZLHCSSIZ      ELSE GET MODULE CONS SPACE SIZE
         BNZ   USECS               IF SPECIFIED, USED IT
         L     #1,DEFCSS           ELSE USE DEFAULT FOR CSSIZE
USECS    LA    #1,4095(,#1)        ROUND UP TO 4K BOUNDARY
         N     #1,=F'-4096'
         LA    #5,0(#1,#3)         SET MAX LEN OF AREA31
         #GETMAIN VRC,LV=((#5),(#4)),LOC=ANY GET STORAGE ABOVE 16MB
         LTR   #15,#15
         BNZ   ERR0001
         ST    #1,AREA31A          SAVE ADDRESS OF 31-BIT AREA
         ST    #0,AREA31L          SAVE LENGTH OF 31-BIT AREA
         LR    #3,#0               COMPUTE SIZE LEFT FOR CONSES =
         SR    #3,#6               AREA31 LENGTH MINUS STACK SIZE
         SH    #3,=Y(##SYMLEN+TSIZE) MINUS LENGTHS OF SYMBOLS T, NIL
         S     #3,PSSIZE            MINUS LENGTH OF PRINT STACK
         S     #3,OHSIZE            MINUS LENGTH OF OBLIST HASH ARRAY
         S     #3,SFSIZE            MINUS LENGTH OF SMALL FIXNUM TABLE
         S     #3,VSSIZE            MINUS LENGTH OF V/S SPACE REQUESTED
         S     #3,VSSIZE            (TWO TIMES, ONE FOR EACH SPACE)
*
* NOW #3 CONTAINS WHATEVER IS LEFT OVER FOR CSSIZE.
*
* IF THE LENGTH OF CONS SPACE (AFTER ALL THE OTHER LENGTHS HAVE BEEN
* SUBTRACTED) IS NOT A MULTIPLE OF 4K, THEN WE MUST ADJUST IT TO A
* MULTIPLE OF 4K (REQUIRED BY VECTOR GC ALGORITHM).  THEREFORE, WE
* REMOVE THE EXCESS AND GIVE IT TO SOMEONE ELSE - NAMELY,
* THE CONTROL STACK.
*
         LR    #14,#3              SAVE UNROUNDED CSSIZE
         N     #3,=F'-4096'        ROUND CSSIZE DOWN TO 4K BOUNDARY
         SR    #14,#3              GET THE EXCESS AMOUNT (USUALLY ZERO)
         AR    #6,#14              ADD IT TO PUSH DOWN STACK SIZE
*
* NOW #3 CONTAINS CSSIZE ROUNDED DOWN TO MULTIPLE OF 4K.
*
* MAKE SURE TRUE CSSIZE IS ENOUGH.  AS LONG AS IT IS, STORE IT.
*
         C     #3,MINCSS           IF THIS IS LESS THAN MINIMUM LEN
         BL    ERR0001             THEN ERROR
         ST    #3,CSSIZE           ELSE SAVE TRUE CONS SPACE SIZE
*
* CLEAR PUSH DOWN STACK- NEEDED TO PREVENT POTENTIAL GC ANOMALIES
*
         DROP  #2,#11
         LR    #11,#1              ADDRESS OF 31-BIT AREA = STACK ADDR
         LR    #14,#1              MVCL ADDRESS OF PUSHDOWN STACK
         LR    #15,#6              MVCL LENGTH OF PUSHDOWN STACK
         XR    #0,#0               MVCL ADDRESS TO MOVE FROM = NONE
         XR    #1,#1               MVCL LENGTH TO MOVE = ZERO
         MVCL  #14,#0              SET PUSH DOWN STACK TO ZEROES
*
* NOW THAT WE KNOW WHERE THE COMMON AREA IS, STORE ALL OUR VALUES THERE
*
         L     #2,HDRPTR           GET ADDRESS OF HEADER
         ST    #2,ZLCHDADR         STORE ADDRESS OF HEADER
         L     #2,OPTPTR           GET ADDRESS OF OPTIONS
         ST    #2,ZLCOPADR         STORE ADDRESS OF OPTIONS
         LM    #0,#1,AREA24A       GET ADDRESS & LENGTH OF 24-BIT AREA
         STM   #0,#1,ZLC24ADR      STORE IN COMMON AREA
         LM    #0,#1,AREA31A       GET ADDRESS & LENGTH OF 31-BIT AREA
         STM   #0,#1,ZLC31ADR      STORE IN COMMON AREA
         ST    #13,ZLCCMADR        STORE ADDRESS OF COMMON AREA
         ST    #8,ZLCCMSIZ         STORE SIZE OF COMMON AREA
         ST    #6,ZLCPDSIZ         STORE SIZE OF PUSH DOWN STACK
         ST    #11,ZLCPDADR        STORE ADDRESS OF PUSH DOWN STACK
*
* HAVING STORED REGISTERS, WE CAN NOW SET ADDRESSES OF STANDARD ATOMS
*
         LA    #8,0(#11,#6)        COMPUTE ADDRESS OF ATOM T =
*                                   PUSH DOWN ADDR + PUSH DOWN SIZE
         LA    #7,TSIZE(,#8)       COMPUTE ADDRESS OF FIXNUM TABLE =
*                                   ADDRESS OF T + LENGTH OF T + JUNK
         LR    #1,#7               COMPUTE ADDRESS OF VSS #1 =
         A     #1,SFSIZE            ADDRESS OF SMALL FIXNUM TABLE
         ST    #1,ZLCVSADR          + LENGTH OF SMALL FIXNUM TABLE
         ST    #1,ZLCVSNXT         SET PTR TO FIRST AVAILABLE SLOT
         L     #0,VSSIZE           GET LENGTH OF ONE HALF OF IT
         ST    #0,ZLCVSLEN         SET LENGTH
         AR    #1,#0               COMPUTE ADDRESS OF VSS #2 =
         ST    #1,ZLCVSOTH          ADDRESS OF VSS #1 +
         AR    #1,#0                + LENGTH OF VSS #1
         LR    #9,#1               COMPUTE ADDRESS OF CONS SPACE =
*                                   ADDRESS OF VSS #2 +
*                                   + LENGTH OF VSS #2
         LA    #10,0(#9,#3)        COMPUTE ADDRESS OF ATOM NIL =
*                                   ADDRESS OF CONS SPACE + ITS LENGTH
         ST    #7,ZLCSFTBL         STORE ADDRESS OF SMALL FIXNUM TABLE
         ST    #8,ZLCT             STORE ADDRESS OF ATOM T
         ST    #9,ZLCCSADR         STORE ADDRESS OF CONS SPACE
         ST    #10,ZLCNIL          STORE ADDRESS OF ATOM NIL
*
* SET OTHER STUFF
*
         LA    #1,##SYMLEN(,#10)   POINT TO JUST ABOVE NIL
         ST    #1,ZLCPSADR         THAT'S ADDRESS OF PRINT STACK
         L     #1,PSSIZE           GET LENGTH OF PRINT STACK
         ST    #1,ZLCPSSIZ         THAT'S SIZE OF PRINT STACK
         A     #1,ZLCPSADR         ADD IN THE ADDRESS
         ST    #1,ZLCPSEND         THAT'S THE END OF THE PRINT STACK
         ST    #1,ZLCOBHSH         AND THE @ OF THE OBLIST HASH ARRAY
         L     #1,OHSIZE           GET SIZE OF OBLIST HASH ARRAY
         SRA   #1,2                DIVIDE BY 4 TO GET...
         ST    #1,ZLCOBDIM         COUNT OF ENTRIES IN OBHASH
         ST    #3,ZLCCSSIZ         STORE SIZE OF CONS SPACE
         SRA   #3,3                DIVIDE BY 8 TO GET...
         ST    #3,ZLCNFREE         TOTAL CONS CELL COUNT
*
* CLEAR OBLIST HASH ARRAY
*
         L     #14,ZLCOBHSH        MVCL ADDRESS OF OBLIST HASH ARRAY
         L     #15,OHSIZE          MVCL LENGTH OF OBLIST HASH ARRAY
         XR    #0,#0               MVCL ADDRESS TO MOVE FROM = NONE
         XR    #1,#1               MVCL LENGTH TO MOVE = ZERO
         MVCL  #14,#0              SET OBLIST HASH ARRAY TO ZEROES
*
* Initialize small fixnum table
*
         USING #SFTD,#8
*----------------------------------------------------------------------
         AIF   (&ZILVF).VFIX
*----------------------------------------------------------------------
         LA    #14,##FIXNUM        Get fixnum type bit code
         SLL   #14,24              Shift into high-order byte
         LA    #0,1                Get BXLE increment
         XR    #15,15              Initialize fixnum value to zero
         ST    #15,ZLCSFTLO        Save lowest value
         LA    #7,#SFTPFX          Get address of fixnum before table
         BCTR  #15,0               Initialize fixnum value to -1
         LA    #1,255              Get highest fixnum to be generated
SFLOOP   DS    0H
         STM   #14,#15,0(#7)       Store fixnum words into table
         LA    #7,8(,#7)           Bump fixnum table pointer
         BXLE  #15,#0,SFLOOP       Do for I = 0 to 255
         ST    #1,ZLCSFTHI         Save highest value
*----------------------------------------------------------------------
         AGO   .VFIXEND
*----------------------------------------------------------------------
.VFIX    ANOP
*----------------------------------------------------------------------
         SPACE 1
*
* This code initializes the small fixnum table with a series of
* contiguous fixnums (8-byte entries) from -1 to 255.  The code
* assumes a section size of 128, meaning that the process takes
* 2 vector operations (if the section size were 256, we could do
* it in 1 vector operation).  Fixnums -1 through 254 are created
* through vector operations (making use of the VLINT instruction
* to create a vector of consecutive integer values), and fixnum
* 255 is created scalarly afterward.
*
         SPACE 1
         VLVCA 128                 Section size to 128 (not maximum)
         LA    #14,##FIXNUM        Get fixnum type bit code
         SLL   #14,24              Shift into high-order byte
         XR    #15,15              Initialize fixnum value to zero
         ST    #15,ZLCSFTLO        Save lowest value
         BCTR  #15,0               Make first fixnum value = -1
         LA    #7,#SFTPFX          Address table location for -1
         VLQ   #V0,#14             Left vector = all fixnum left halves
         VLINT #V1,#15             Right vector = integers -1 thru 126
         VSTD  #V0,#7              Store vector doublewords in table
*                                  #7 now points to next part of table
*                                  #15 now contains (-1+128) = 127
         VLINT #V1,#15             Right vector = integers 127 thru 254
         VSTD  #V0,#7              Store the next 128 table doublewords
*                                  #7 now points to next slot in table
*                                  #15 now contains (127+128) = 255
         STM   #14,#15,0(#7)       Store last entry in fixnum table
         ST    #15,ZLCSFTHI        Save highest fixnum value
*----------------------------------------------------------------------
.VFIXEND ANOP
*----------------------------------------------------------------------
*
* THE FREE LIST IS INITIALIZED ONLY WHEN A GARBAGE COLLECTION OCCURS.
* OTHERWISE IT IS ACCESSED SEQUENTIALLY BY CONS.
* THIS ELIMINATES THE FIRST-TIME OVERHEAD OF CHAINING CELLS TOGETHER.
*
* INITIALIZE FILE BLOCK POINTERS
* (NOTE INPUT AND OUTPUT TERMINAL FILE BLOCK POINTERS REMAIN ZERO)
*
         L     #7,OFPTR            GET ADDRESS OF STD OUTPUT FILE BLOCK
         ST    #7,ZLCSTDOU         SET ADDRESS OF STD OUTPUT FILE BLOCK
         L     #7,ZLFCHAIN         GET ADDRESS OF FIRST OUTPUT FILE BLK
         ST    #7,ZLCOFBAD         SET ADDRESS OF FIRST OUTPUT FILE BLK
         L     #7,IFPTR            GET ADDRESS OF STD INPUT FILE BLOCK
         ST    #7,ZLCSTDIN         SET ADDRESS OF STD INPUT FILE BLOCK
         L     #7,ZLFCHAIN         GET ADDRESS OF FIRST INPUT FILE BLK
         ST    #7,ZLCIFBAD         SET ADDRESS OF FIRST INPUT FILE BLK
         L     #7,ZLCSTDIN         GET ADDR OF STANDARD INPUT FILE BLK
         TM    ZLFFLAG1,ZLFTERM    IF STANDARD INPUT IS A TERMINAL FILE
         BZ    *+8                 THEN
         ST    #7,ZLCIFTRM          SET INPUT TERMINAL FILE BLK PTR
         L     #7,ZLCSTDOU         GET ADDR OF STANDARD OUTPUT FILE BLK
         TM    ZLFFLAG1,ZLFTERM    IF STANDARD OUTPUT IS A TERM FILE
         BZ    *+8                 THEN
         ST    #7,ZLCOFTRM          SET OUTPUT TERMINAL FILE BLK PTR
         SPACE 1
***********************************************************************
*                                                                     *
* The following section of code has been removed, because we think    *
* that we WILL be able to run ZIL applications under themselves       *
* (e.g. via the TSO function) if we omit this check.                  *
*                                                                     *
***********************************************************************
         SPACE 1
         AGO   .NCKSUBS
*----------------------------------------------------------------------
         SPACE 1
*
* SEE IF ZILSUBS IS ALREADY LOADED.  IF SO, ZIL ALREADY ACTIVE
*
* NOTE: THIS WON'T WORK IF ZILSUBS IS IN THE LPA, WHICH IT CAN'T BE
*       'CAUSE IT'S NOT REENTRANT ANYHOW.
*
         L     #15,X'21C'          ADDRESS OF CURRENT TCB
         L     #15,X'7C'(,#15)     TCBJSTCB: CURRENT JOB STEP TCB
         ICM   #14,15,X'2C'(#15)   TCBJPQ: ADDRESS OF JOB PACK QUEUE
JPQLOOP  DS    0H                  IF NO MORE JOB PACK ENTRIES
         BZ    NOTLDED             THEN ZILSUBS IS NOT IN STORAGE
         CLC   8(8,#14),$ZILSUBS   IF CDE NAME IS ZILSUBS
         BE    INSTOR              THEN ZILSUBS IS ALREADY IN STORAGE
         ICM   #14,15,0(#14)       ELSE GET NEXT JOB PACK QUEUE ENTRY
         B     JPQLOOP             AND CONTINUE SEARCH
NOTLDED  DS    0H                  ZILSUBS NOT LOADED...
         SPACE 1
*----------------------------------------------------------------------
.NCKSUBS ANOP  ,
         SPACE 1
*
* SET UP INTERFACES TO RESIDENT ROUTINES
*
         LOAD  EPLOC=$ZILSUBS      LOAD SUBROUTINE MODULE
         ST    #0,ZLCSUBS          SAVE ITS ADDRESS
         LR    #15,#0
         L     #15,0(,#15)         GET POINTER TO SUBROUTINE ADDRESSES
         USING ZSASUBS,#15
         L     #0,ZSACONS          CONS PLUS GARBAGE COLLECTOR
         ST    #0,ZLCCONS
         L     #0,ZSAFGETI         INPUT FILE BLOCK ACCESSOR
         ST    #0,ZLCFGETI
         L     #0,ZSAFGETO         OUTPUT FILE BLOCK ACCESSOR
         ST    #0,ZLCFGETO
         L     #0,ZSAPDSO          STACK OVERFLOW ERROR ROUTINE
         ST    #0,ZLCPDSO
         L     #0,ZSAERR           GENERAL ERROR ROUTINE
         ST    #0,ZLCERR
         L     #0,ZSATHROW         THROW PROCESSOR
         ST    #0,ZLCTHROW
         L     #0,ZSATPUT          TPUT PROCESSOR
         ST    #0,ZLCTPUT
         L     #0,ZSABIG           BIGNUM ALLOCATION ROUTINE
         ST    #0,ZLCBIG
         L     #0,ZSAINTN          SYMBOL INTERNMENT ROUTINE
         ST    #0,ZLCINTN
         L     #0,ZSAABLD          ATOM BUILDING ROUTINE
         ST    #0,ZLCABLD
         L     #0,ZSAADMP          ATOM DUMPING ROUTINE
         ST    #0,ZLCADMP
         L     #0,ZSAVSS           VECTOR/STRING SPACE ALLOCATOR
         ST    #0,ZLCVSS
         L     #0,ZSAGETC          CHARACTER INPUT ROUTINE
         ST    #0,ZLCGETC
         L     #0,ZSAPRIN          PRINT ROUTINE
         ST    #0,ZLCPRIN
         L     #0,ZSATERP          TERPRI ROUTINE
         ST    #0,ZLCTERP
         L     #0,ZSAFINT          FORTRAN INTERFACE ROUTINE
         ST    #0,ZLCFINT
         L     #0,ZSAKERR          &KEY KEYWORD ERROR HANDLER
         ST    #0,ZLCKERR
         L     #0,ZSACVBF          BIGNUM-TO-FLOAT CONVERSION
         ST    #0,ZLCCVBF
         L     #0,ZSASINT          COMPILED CODE OBJECT INITIALIZATION
         ST    #0,ZLCSINT
         L     #0,ZSASBND          SPECIAL VARIABLE BINDING
         ST    #0,ZLCSBND
         L     #0,ZSAFBND          LEXICAL VARIABLE BINDING
         ST    #0,ZLCFBND
         L     #0,ZSAMDF           DOUBLE FLOAT CONSING
         ST    #0,ZLCMDF
         L     #0,ZSAVALS          Multiple value returning
         ST    #0,ZLCVALS
         DROP  #15
*
* SET UP INTERFACE TO PUSHDOWN STACK OVERFLOW ROUTINE
*
         MVC   0(4,#13),PDSCODE1
         MVC   ZLCCALPO(ZLCCALPL),PDSCODE2
*
* SET UP INTERFACE TO ZIL MODULES TABLE
*
         L     #15,HDRPTR
         USING ZLHEADER,#15
         L     #15,ZLHMODS         GET ADDRESS OF ZILMODS
         DROP  #15
         ST    #15,ZLCMODS         STORE ADDRESS OF ZILMODS
*
* DEFINE DEFAULTS FOR DISPLAYING SQUARE BRACKETS WHEN PRINC IS DONE
* TO A FILE IN TABS MODE.  USED BY MACSYMA.
*
         MVI   ZLCLB,X'C0'         USE LEFT CURLY BRACE "{"
         MVI   ZLCRB,X'D0'         USE RIGHT CURLY BRACE "}"
*
* THE TRANSLATION POINTS DEFINED IN THE TABLE BELOW ARE USED WHEN A
* PRIN1 IS DONE TO THE TERMINAL, OR WHEN A PRINC IS DONE TO THE
* TERMINAL AND TABS MODE HAS BEEN TURNED OFF.
*
* ALLOCATE THE TERMINAL OUTPUT TRANSLATE TABLE
*
         LA    #0,256              GET A 256-BYTE BUFFER
         GETMAIN R,LV=(0)
         LR    #14,#1
         ST    #14,ZLCTRMTR        SET ADDRESS OF TRANSLATE TABLE
         MVC   0(256,#14),TRMTRTBL SET UP THE DEFAULT TRANSLATE TABLE
         MVI   X'AD'(#14),X'41'     DISPLAY LEFT BRACKET AS HEX 41
         MVI   X'BD'(#14),X'42'     DISPLAY RIGHT BRACKET AS HEX 42
         GTSIZE ,                  GET TERMINAL LINE SIZE
         LTR   #15,#15             SKIP TRANSLATE TABLE ALTERATION IF
         BNZ   NOTRCHG              SVC 94 CALL FAILED
         CH    #0,=H'32'           IF THIS IS A 32-LINE TERMINAL
         BNE   NOTRCHG             THEN (ASSUME 3179, NOT 3279)
         MVI   X'AD'(#14),X'BA'     DISPLAY LEFT BRACKET AS HEX BA
         MVI   X'BD'(#14),X'BB'     DISPLAY RIGHT BRACKET AS HEX BB
NOTRCHG  DS    0H
*
* CREATE THE "RMNIL" OBJECT RETURNED BY THE (RMNIL) FUNCTION
*
         LA    #15,ZLCRMNIL
         LR    #0,#15
         STM   #15,#0,ZLCRMNIL     (CAR(RMNIL))=(CDR(RMNIL))=(RMNIL)
*
* CREATE THE "UNBOUND" OBJECT
*
         LA    #15,ZLCUNBND
         LR    #0,#15
         STM   #15,#0,ZLCUNBND     (CAR(UNBND))=(CDR(UNBND))=(UNBND)
*
* INITIALIZE GARBAGE COLLECTION FLAGS
*
         MVI   ZLCGCFLG,ZLCGCINT+ZLCGCMSG
*
* INITIALIZE OTHER COMMON AREA FIELDS
* NOTE THAT ZLCMSLVL (MESSAGE LEVEL) IS INITIALLY ONE
* (I.E. INITIALLY DISPLAY ALL BUT INFORMATIONAL MESSAGES)
*
         MVI   ZLCMSLVL,1          SET MSGLEVEL TO 1
         L     #1,TIOTDRIB
         ST    #1,ZLCDRIBL         SET ADDRESS OF DRIBBLE DCB IF ANY
         ST    #10,ZLCGCEND        SET END-OF-FREE-LIST POINTER
         L     #1,X'21C'           GET CURRENT TCB ADDRESS
         L     #1,0(,#1)           GET CURRENT PRB ADDRESS
         ST    #1,ZLCZILRB         SAVE RB ADDRESS (USED BY ATTN EXIT)
         AIF   (&ZILXA).IPM
*
* In a non-XA system there is no IPM instruction, so to access the
* program mask we just look at the PSW.
*
         BALR  #1,0                INSERT PROGRAM MASK FROM PSW
         AGO   .AFTIPM
.IPM     ANOP
*
* In an XA system BALR won't get the PSW, but we have this neat
* instruction to access the program mask.
*
         IPM   #1                  INSERT PROGRAM MASK FROM PSW
.AFTIPM  ANOP
         STCM  #1,8,ZLCPMASK       SAVE INITIAL PROGRAM MASK
         MVC   ZLCOBCNT,OBTHRESH   INITIALIZE OBHASH THRESHOLD COUNT
         LA    #1,ZLFBLEN          GET LENGTH OF A FILE BLOCK
         STH   #1,ZLCFBLEN         STORE FILE BLOCK LENGTH
*
* DETERMINE THE VALUE OF ACTIVE CONS SPACE SIZE TO USE
*
*
         L     #2,OPTPTR           ADDRESS ZIL HEADER OPTIONS
         USING ZLHOPTS,#2
         ICM   #6,15,ACSIZE        GET INIT ACTIVE CONS SPACE SIZE
         BNZ   USEAC               IF SPECIFIED, USED IT
         ICM   #6,15,ZLHACSIZ      ELSE GET MODULE ACTIVE CONS SIZE
         BNZ   USEAC               IF SPECIFIED, USED IT
         L     #6,DEFACS           ELSE USE DEFAULT FOR ACSIZE
USEAC    LA    #6,7(,#6)           ROUND UP TO DOUBLEWORD BOUNDARY
         N     #6,=X'FFFFFFF8'
         C     #6,ZLCCSSIZ         IF ACSIZE EXCEEDS TOTAL CSSIZE
         BNH   ACSIZOK             THEN
         L     #6,ZLCCSSIZ          SET ACSIZE TO TOTAL CSSIZE
ACSIZOK  DS    0H
         DROP  #2
*
* RESET #9 TO POINT TO BOTTOM OF ACTIVE CONS SPACE RATHER THAN
* BOTTOM OF TOTAL CONS SPACE.  ALSO SET OTHER FIELDS RELATING TO
* DYNAMICALLY EXPANDING CONS SPACE.
*
         LR    #9,#10              GET NIL, WHICH IS AT TOP OF CONS SP
         SR    #9,#6               BUMP DOWN TO BOTTOM OF ACTIVE CONSES
         C     #9,ZLCCSADR         IF THIS PASSES BOTTOM OF TOTAL CS
         BNL   CSGE1M              THEN
         L     #9,ZLCCSADR          USE TOTAL CSSIZE BOTTOM POINTER
CSGE1M   ST    #9,ZLCGCACP         THAT'S NOW POINTER TO FIRST FREE
         LR    #0,#6               GET INITIAL ACTIVE CONS SPACE SIZE
         SRL   #0,3                MINIMUM NUMBER OF CONS CELLS
         ST    #0,ZLCGCACD         STORE MINIMUM NUMBER OF DOUBLEWORDS
         ST    #0,ZLCGCACF         THIS IS ALSO THE FREE COUNT
         EJECT
*
* INITIALIZE NEW-SYMBOL TEMPLATE
*
* ##PNAME IS NOT SET - MUST ALWAYS BE FILLED BY CREATOR
*
         MVI   ZLCNSYM+##TYPE,##SYMBOL SET SYMBOL TYPE BITS
         MVI   ZLCNSYM+3,##SYMLEN      SET SYMBOL LENGTH (REST IS X'')
         ST    #10,ZLCNSYM+##PLIST     SET PROPERTY LIST TO NIL
         LA    #0,ZLCUNBND             GET THE UNBOUND OBJECT
         ST    #0,ZLCNSYM+##PVALUE     SET VALUE CELL TO UNBOUND
         ST    #0,ZLCNSYM+##PFUNC      SET FUNCTION CELL TO UNBOUND
*                                      DEFAULT PACKAGE = UNINTERNED
         ST    #10,ZLCNSYM+##PPKG      SET PACKAGE CELL TO NIL
*
* BUILD ATOMS T AND NIL
*
         MVC   PNAMET(LMODELT,#13),MODELT       BUILD T'S PRINT NAME
         MVC   PNAMENIL(LMODELNL,#13),MODELNIL  BUILD NIL'S PRINT NAME
         MVC   0(##SYMLEN,#8),ZLCNSYM MOVE NEW SYMBOL TEMPLATE TO T
         MVC   0(##SYMLEN,#10),ZLCNSYM MOVE NEW SYMBOL TEMPLATE TO NIL
         LA    #0,PNAMET(,#13)     POINT TO WHERE T'S PRINT NAME'LL BE
         ST    #0,##PNAME(,#8)     SET PRINT NAME POINTER OF T
         LA    #0,PNAMENIL(,#13)   POINT TO WHERE NIL'S PNAME WILL BE
         ST    #0,##PNAME(,#10)    SET PRINT NAME POINTER OF NIL
*
* VERY IMPORTANT THAT ##PVALUE AND ##CDR ARE IDENTICAL, BECAUSE IN THE
* CASE OF NIL BOTH (SYMBOL-VALUE NIL) AND (CDR NIL) MUST BE NIL!!!!!!!
*
         ST    #10,##PVALUE(,#10)  VALUE CELL OF NIL POINTS TO NIL
         ST    #8,##PVALUE(,#8)    VALUE CELL OF T POINTS TO T
* T and NIL are interned - set package cell to T for now (see ZILSPKG)
         ST    #8,##PPKG(,#8)      SET T'S PACKAGE CELL
         ST    #8,##PPKG(,#10)     SET NIL'S PACKAGE CELL
*
*
* SET FILE ATOMS TO NIL FOR STANDARD INPUT AND OUTPUT
*
         L     #7,ZLCSTDIN
         ST    #10,ZLFATOM
         L     #7,ZLCSTDOU
         ST    #10,ZLFATOM
*
* INITIALIZE STANDARD VARIABLES
*
         ST    #10,ZLCSALST        SET INITIAL SPECIAL ALIST TO NIL
         ST    #10,ZLCFALST        SET INITIAL LEXICAL ALIST TO NIL
         ST    #10,ZLCOBLST        SET INITIAL OBLIST TO NIL
         LR    #6,#10              GET ADDRESS OF OBLIST
         EJECT
*
* OBJECT LIST INITIALIZATION
*
* NOTE THAT ALTHOUGH WE ARE ADDING SYMBOLS TO THE OBLIST, THESE
* SYMBOLS DO NOT GET ENTERED IN THE HASH TABLE.  THIS MUST BE
* TAKEN INTO ACCOUNT WHEN USING THE VALUE IN ZLCOBCNT, WHICH
* REPRESENTS THE MAXIMUM NUMBER OF HASH ENTRIES AVAILABLE FOR
* INTERNING MORE SYMBOLS.
*
* (SETQ OBLIST (CONS NIL OBLIST)
*
         LR    #1,#10              GET ADDRESS OF NIL
         LR    #2,#6               GET ADDRESS OF OBLIST
         L     #15,ZLCCONS
         #BASR #14,#15
         LTR   #6,#15              LOAD NEW OBLIST POINTER
         BZ    IACONSNG
*
* (SETQ OBLIST (CONS T OBLIST)
*
         LR    #1,#8               GET ADDRESS OF T
         LR    #2,#6               GET ADDRESS OF OBLIST
         L     #15,ZLCCONS
         #BASR #14,#15
         LTR   #6,#15              LOAD NEW OBLIST POINTER
         BZ    IACONSNG
         ST    #6,ZLCOBLST         SET NEW OBLIST POINTER
*
* Initialize the current ZIL printer to "ZDPRINT", the default
* ZIL printer, and the current ZIL reader to "ZDREAD", the default
* ZIL reader.
*
         L     #15,ZLCMODS         Get address of ZILMODS
         USING ZMOD,#15
         L     #14,Z@ZDPRIN        Get address of ZDPRINT pointer
         L     #14,0(,#14)         Get address of ZDPRINT
         ST    #14,ZLCCPRT         Set current printer address
         L     #14,Z@ZDREAD        Get address of ZDREAD pointer
         L     #14,0(,#14)         Get address of ZDREAD
         ST    #14,ZLCCRDR         Set current reader address
         DROP  #15
*
* INITIALIZE ALL OBJECT POINTERS IN THE LOAD MODULE.
*
* Note that since ZILSINT expects #12 to be the entry point of the
* module we're using to relocate objects, we must set #12 to be the
* entry point of the main program function.  This means that we can
* not use #12 as a base register in this segment of code.
*
         ST    #12,SAVEBASE        Save base register
         L     #12,MODPTR          Get address of code's entry point
         DROP  #12
         L     #1,ZLCHDADR         Get address of compiled code header
         L     #15,ZLCSINT         Get address of ZILSINT
         XR    #0,#0               Can't have CONS GC from this env.
         #BASR #14,#15             Call ZILSINT to init code objects
         USING *,#14               ON return #14 points here, right?
         L     #12,SAVEBASE        Restore base register
         DROP  #14
         USING ZILINIT,#12
*
* OBJECT LIST INITIALIZATION IS COMPLETE.
*
* IF THERE'S ANYTHING ELSE TO DO, DO IT HERE.
*
         NI    ZLCGCFLG,255-ZLCGCINT TURN OFF ZILINIT FLAG
*
* NOW PERFORM MISCELLANEOUS ZIL INITIALIZATION.
*
         L     #15,ZLCMODS         Get address of ZILMODS
         USING ZMOD,#15
         L     #15,Z@ZEVINI        Get address of ZEVINIT pointer
         DROP  #15
         L     #15,0(,#15)         Get address of ZEVINIT
         LA    #1,0(,#11)          Point to bottom of stack
         #BASR #14,#15             Call ZEVINIT
*
* ZIL INITIALIZATION IS COMPLETE.
*
         EJECT
ZLRETURN DS    0H                  RETURN TO MAIN LINE
         SPACE 1
         L     #13,4(,#13)         RESTORE SAVE AREA
         DROP  #13
         SAVE  (8,11)              STORE REQUIRED ZIL REGS IN SAVEAREA
         LM    #14,#12,12(#13)
         XR    #15,#15             SET RETURN CODE TO ZERO
         BR    #14                 RETURN WITH RC IN REG 15
         EJECT
IACONSNG DS    0H                  WHAT HAPPENS WHEN FREE LIST USED UP
ERR0001  DS    0H                  NOT ENOUGH STORAGE TO GET BY
         L     #1,=A(ZIL0001)
         WTO   MF=(E,(1)),ROUTCDE=11
         ABEND 0001,DUMP
         EJECT
OUTNOPEN DS    0H                  STANDARD OUTPUT (ZILO) NOT THERE
         SPACE 1
         L     #1,=A(ZIL0005)
         WTO   MF=(E,(1)),ROUTCDE=11
         ABEND 0005,DUMP
         SPACE 1
INNOPEN  DS    0H                  STANDARD INPUT (ZILI) NOT THERE
         L     #1,=A(ZIL0004)
         WTO   MF=(E,(1)),ROUTCDE=11
         ABEND 0004,DUMP
         SPACE 1
INSTOR   DS    0H                  ZILSUBS ALREADY LOADED...
         L     #1,=A(ZIL0003)
         WTO   MF=(E,(1)),ROUTCDE=11
         ABEND 0003,DUMP
         SPACE 1
         DROP  #12
         EJECT
OUTEXIT  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* DCB OPEN EXIT FOR ZIL OUTPUT FILE.  THIS FILLS IN DCB INFO.         *
*                                                                     *
* NOTE: THIS EXECUTES IN AMODE 24 (I THINK).                          *
*                                                                     *
***********************************************************************
         SPACE 1
         PUSH  USING
         USING DCBSTUFF,#1
DCBSTUFF DSECT
DSORG    EQU   DCBSTUFF+X'18',2,C'X'
RECFM    EQU   DCBSTUFF+X'24',1,C'X'
LRECL    EQU   DCBSTUFF+X'52',2,C'H'
BLKSIZE  EQU   DCBSTUFF+X'3E',2,C'H'
         SPACE 1
ZILINIT  CSECT
         SPACE 1
         USING OUTEXIT,#15
         OC    DSORG,DSORG         IF NO DSORG PRESENT
         BNZ   OXGOTDS             THEN
         MVI   DSORG,X'40'          SET DSORG = PS
OXGOTDS  DS    0H
         CLI   RECFM,X'00'         IF NO RECFM PRESENT
         BNE   OXGOTRF             THEN
         MVI   RECFM,X'94'          SET RECFM = FBA
         B     OXFIXED              AND PROCESS FIXED LRECL.
OXGOTRF  DS    0H                  ELSE THERE IS A RECFM
         TM    RECFM,X'80'         IF RECFM = V..
         BO    OXFIXED             THEN
         OC    LRECL,LRECL          IF THERE'S NO LRECL
         BNZ   OXGOTLR              THEN
         LA    #15,255               SET LRECL = 255
         STH   #15,LRECL
         LA    #15,3120              SET BLKSIZE = 3120
         STH   #15,BLKSIZE
         BR    #14                   AND RETURN.
OXFIXED  DS    0H
         OC    LRECL,LRECL         IF LRECL IS ZERO
         BZ    OXSETF              THEN SET LRECL AND BLKSIZE
OXGOTLR  OC    BLKSIZE,BLKSIZE     IF BLOCK SIZE EXISTS
         BNZR  #14                 THEN WE ARE ALL SET
         LA    #15,3120/80         ELSE GET DEFAULT BLOCKING FACTOR
         MH    #15,LRECL           MULTIPLY BY LRECL
         STH   #15,BLKSIZE         SET BLOCKSIZE
         BR    #14
OXSETF   DS    0H                  SET LRECL AND BLOCKSIZE
         TM    RECFM,X'04'         IF RECFM = ..A
         BO    OXSETFA             THEN GO TO SET VALUES FOR RECFM=FBA
         LA    #15,80              ELSE SET LRECL = 80
         STH   #15,LRECL
         LA    #15,3120            AND SET BLKSIZE = 3120
         STH   #15,BLKSIZE
         BR    #14
OXSETFA  DS    0H                  SET LRECL AND BLKSIZE FOR ASA CC
         LA    #15,81               SET LRECL = 81
         STH   #15,LRECL
         LA    #15,3078             SET BLKSIZE = 3078
         STH   #15,BLKSIZE
         BR    #14                  AND RETURN.
         SPACE 1
         POP   USING
         EJECT
*
* CONSTANTS, ETC.
*
PDSIZE   DC    A(0)                SIZE OF PUSH DOWN STACK
VSSIZE   DC    A(0)                SIZE OF EACH STRING/VECTOR SPACE
CSSIZE   DC    A(0)                SIZE OF CONS SPACE
ACSIZE   DC    A(0)                SIZE OF ACTIVE CONS SPACE
PSSIZE   DC    A(8192)             SIZE OF PRINT STACK
OHSIZE   DC    A(64*1024*4)        SIZE OF OBLIST HASH ARRAY, 64K WORDS
SFSIZE   DC    A(256*8)            SIZE OF SMALL FIXNUM TABLE, 256 #'S
OBTHRESH DC    A(50000)            MAX # OF SYMBOLS YOU CAN INTERN
MINCSS   DC    A(1024*1024)        MINIMUM CONS SPACE SIZE = 12K
MINVSS   DC    A(2*4096)           MINIMUM V/S SPACE SIZE * 2 = 2*4K
DEFCSS   DC    A(4*1024*1024)      DEFAULT CONS SPACE SIZE = 4M
DEFPDS   DC    A(64*1024)          DEFAULT PUSH DOWN STACK SIZE = 64K
DEFACS   DC    A(2*1024*1024)      DEFAULT ACTIVE CONS SIZE = 2M
IFPTR    DC    A(0)                ADDRESS OF INPUT FILE BLOCK CHAIN
OFPTR    DC    A(0)                ADDRESS OF OUTPUT FILE BLOCK CHAIN
HDRPTR   DS    A                   ADDRESS OF PROGRAM HEADER
OPTPTR   DS    A                   ADDRESS OF OPTIONS
MODPTR   DS    A                   ADDRESS OF MAIN MODULE
SAVEBASE DS    A                   Place to store base reg
TIOTZILI DC    A(0)                ADDRESS OF TIOT ENTRY FOR DD ZILI
TIOTZILO DC    A(0)                ADDRESS OF TIOT ENTRY FOR DD ZILO
TIOTDRIB DC    A(0)                ADDRESS OF TIOT ENTRY FOR DRIBBLE
AREA24A  DS    A                   ADDRESS OF 24-BIT MEMORY AREA
AREA24L  DS    A                   LENGTH OF 24-BIT MEMORY AREA
AREA31A  DS    A                   ADDRESS OF 31-BIT MEMORY AREA
AREA31L  DS    A                   LENGTH OF 31-BIT MEMORY AREA
$ZILSUBS DC    CL8'ZILSUBS'
         SPACE 1
         DS    0F                  Model print name string for T
MODELT   DC    YL1(##STRING),AL3(1),C'T',XL3'00'
LMODELT  EQU   *-MODELT            Length of model print name string
         SPACE 1
         DS    0F                  Model print name string for NIL
MODELNIL DC    YL1(##STRING),AL3(3),C'NIL',X'00'
LMODELNL EQU   *-MODELNIL          Length of model print name string
         SPACE 1
TNILLEN  EQU   LMODELT+LMODELNL
         SPACE 1
XLOUT    DC    0F'0',X'85',AL3(OUTEXIT) EXIT LIST FOR OUTPUT DCB
         SPACE 1
OPENL    OPEN  (*-*),MF=L
         SPACE 1
         USING ZLCOMMON,#13
PDSCODE1 B     ZLCCALPO            FIRST-LEVEL INTERFACE TO STACK OVFLO
PDSCODE2 L     #2,ZLCPDSO          SECOND-LEVEL INTERFACE TO
         BR    #2                   PUSH DOWN STACK OVERFLOW ROUTINE
         DROP  #13
         SPACE 1
         LTORG
         SPACE 1
TEMPSAVE DS    18F                 TEMPORARY SAVE AREA
         SPACE 1
*
* DEFAULT TERMINAL OUTPUT TRANSLATE TABLE
* NOTE: THIS IS COPIED INTO A BUFFER ACCESSIBLE FROM THE
* COMMON AREA. IT MAY BE MODIFIED AT ANY TIME.
*
TRMTRTBL DC    X'007A7A7A7A7A7A7A7A7A7A7A7A7A7A7A'
         DC    X'7A7A7A7A7A7A7A7A7A7A7A7A7A7A1E7A'
         DC    X'7A7A7A7A247A7A7A7A7A7A7A7A7A7A7A'
         DC    X'7A7A7A7A7A7A7A7A7A7A7A7A7A7A7A7A'
         DC    X'404142434445464748494A4B4C4D4E4F'
         DC    X'505152535455565758595A5B5C5D5E5F'
         DC    X'606162636465666768696A6B6C6D6E6F'
         DC    X'707172737475767778797A7B7C7D7E7F'
         DC    X'808182838485868788898A8B8C8D8E8F'
         DC    X'909192939495969798999A9B9C9D9E9F'
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCD7A7A'
         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDC7A7A7A'
         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBEC7A7A7A'
         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFD7A7A'
         SPACE 1
INDDDCB  DCB   DDNAME=ZILI,                                            X
               MACRF=GL,                                               X
               DSORG=PS,                                               X
               RECFM=FB
*                         NOTE - NO EODAD. THIS IS SET BY EXEC MODULES.
OUTDDDCB DCB   DDNAME=ZILO,                                            X
               MACRF=PL,                                               X
               DSORG=PS,                                               X
               EXLST=XLOUT
DRIBLDCB DCB   DDNAME=ZILDRIBL,                                        X
               MACRF=PL,                                               X
               DSORG=PS,                                               X
               RECFM=FB,                                               X
               LRECL=80,                                               X
               BLKSIZE=6160
INDD     EQU   INDDDCB+40,8,C'C'   DDNAME OF STANDARD INPUT FILE
OUTDD    EQU   OUTDDDCB+40,8,C'C'  DDNAME OF STANDARD OUTPUT FILE
DRIBLDD  EQU   DRIBLDCB+40,8,C'C'  DDNAME OF STANDARD DRIBBLE FILE
         SPACE 1
ZIL0001  WTO   ROUTCDE=11,MF=L,                                        X
               'ZIL0001 NO STORAGE AVAILABLE FOR ZIL INITIALIZATION.'
ZIL0002  WTO   ROUTCDE=11,MF=L,                                        X
               'ZIL0002 SYNTAX ERROR IN PARAMETER FIELD, INITIALIZATIONX
                PARAMETERS IGNORED.'
ZIL0003  WTO   ROUTCDE=11,MF=L,                                        X
               'ZIL0003 ZIL ALREADY LOADED, RECURSIVE INVOCATION NOT ALX
               LOWED.'
ZIL0004  WTO   ROUTCDE=11,MF=L,                                        X
               'ZIL0004 STANDARD INPUT FILE "ZILI" NOT AVAILABLE, CANNOX
               T BE OPENED.'
ZIL0005  WTO   ROUTCDE=11,MF=L,                                        X
               'ZIL0005 STANDARD OUTPUT FILE "ZILO" NOT AVAILABLE, CANNX
               OT BE OPENED.'
         SPACE 1
         #ZCOM   ,                 MAP THE COMMON AREA
         #ZSFT   ,                 MAP THE SMALL FIXNUM TABLE
         #ZHDR   ,                 MAP THE HEADER OF THE MAIN PROCEDURE
         #ZSUB   ,                 MAP THE SUBROUTINE POINTERS
         #ZMOD   ,                 MAP THE ZIL MODULES TABLE
         EJECT
* MORE EQUATES
COMLEN   EQU   (ZLCCOMLN+7)/8*8    LENGTH OF COMMON AREA UP TO DOUBLEWD
PNAMET   EQU   COMLEN              OFFSET OF PRINT NAME OF T
PNAMENIL EQU   PNAMET+LMODELT      OFFSET OF PRINT NAME OF NIL
VSSOFF   EQU   PNAMENIL+LMODELNL   OFFSET OF VECTOR/STRING SPACE
MIN24    EQU   VSSOFF+2*4096       MINIMUM LENGTH FOR 24-BIT STORAGE
TSIZE    EQU   #SFT-#SFTD          BETWEEN ADDR OF T AND SMALL FIXNUMS
         EJECT
         AIF   (NOT &ZILTSO).NOCPPL
         IKJCPPL ,
.NOCPPL  ANOP
         END
