         TITLE 'ZILPDSO - ZIL 1.3 MISCELLANEOUS ERROR HANDLER'
***********************************************************************
*                                                                     *
* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *
*                     All rights reserved.                            *
*                                                                     *
***********************************************************************
*                                                                     *
* PDSO originally stood for "PUSH DOWN STACK OVERFLOW".               *
*                                                                     *
* THIS MODULE IS INVOKED WHEN A COMPILED ZIL FUNCTION DISCOVERS THAT  *
* THERE IS NOT ENOUGH ROOM ON THE PUSH DOWN STACK TO EXECUTE.  THIS   *
* CATCHES INFINITE RECURSION ERRORS.                                  *
*                                                                     *
* NOTE: ENTRY TO THIS MODULE IS NOT VIA REGISTER 15, BUT VIA          *
*       REGISTER 2.  THIS INSURES THAT THE ENTRY POINT OF THE         *
*       FUNCTION WHICH DETECTED THE STACK OVERFLOW CONDITION          *
*       IS RETAINED.                                                  *
*                                                                     *
* THIS MODULE USES NO STACK SPACE,  SINCE IT'S NOT RECURSIVE.         *
*                                                                     *
***********************************************************************
*                                                                     *
* FOR ZIL 1.1, THIS MODULE TRAPS TWO KINDS OF ERRORS:                 *
*                                                                     *
*   IF REGISTER 1 IS NON-NIL, A PUSH-DOWN-STACK OVERFLOW ERROR.       *
*   IF REGISTER 1 IS NIL, AN UNBOUND-VARIABLE ERROR.                  *
*                                                                     *
* BOTH OF THESE ARE DETECTED BY CODE GENERATED BY THE COMPILER.       *
*                                                                     *
***********************************************************************
*                                                                     *
* FOR ZIL 1.2, THIS MODULE TRAPS THREE KINDS OF ERRORS - THE TWO      *
* DESCRIBED ABOVE, PLUS ATTENTION INTERRUPTS, WHICH ARE DETECTED BY   *
* VIRTUE OF THE ZLCIATTN BIT BEING ON.                                *
*                                                                     *
***********************************************************************
         SPACE 1
ZILPDSO  CSECT
         USING ZLCOMMON,#13
         BALR  #3,0                SET UP LOCAL BASE REGISTER
         USING *,#3
         SPACE 1
         TM    ZLCIFLGS,ZLCIATTN   IF CALLED FOR ATTENTION INTERRUPT
         BO    ATTN                THEN GO DEAL WITH IT
         SPACE 1
         LR    #2,#15              SAVE EP OF CALLER
         LR    #4,#1               SAVE REGISTER 1
         CR    #4,#10              IF REGISTER 1 = NIL
         BNE   EPIN15              THEN...
         LR    #2,#12               EP OF CALLER IS IN REG 2
EPIN15   DS    0H
         SPACE 1
*
* Extract function name for insertion into message
*
         SPACE 1
         XR    #1,#1               Clear insert register
         STCM  #1,7,FUNLEN         Initialize fake string length to 0
         IC    #1,4(,#2)           Get length of module identifier
         SH    #1,=H'16'           Subtract length of date/time info
         BNP   SKIPNAME            If no name, skip move
         CH    #1,=Y(L'FUNTEXT)    If longer than our maximum
         BNH   *+8                 then
         LA    #1,L'FUNTEXT         use our maximum length
         STCM  #1,7,FUNLEN         Store length into fake string
         BCTR  #1,0                Reduce for execute
         EX    #1,MVCNAME          Move function name to fake string
SKIPNAME DS    0H
*
* Determine what kind of error this was
*
         CR    #4,#10              IF REGISTER 1 IS ZERO
         BE    UVERROR             THEN THIS IS UNBOUND-VARIABLE ERROR
*                                  ELSE THIS IS STACK OVERFLOW ERROR
         #ERR  PREFIX=NO,          DISPLAY ERROR MESSAGE               X
               'ZIL1000 ',FUNSTR,': Control stack overflow.  Possible iX
               nfinite recursion.'
         SPACE 1
UVERROR  DS    0H                  UNBOUND VARIABLE ERROR
*                                  TRY TO FIND WHICH VARIABLE IT IS
*                                  #2 -> START OF MODULE CODE
         XR    #15,#15
         IC    #15,4(,#2)          GET LENGTH OF MODULE HEADER ID
         LA    #2,5+3(#15,#2)      POINT PAST MODULE HEADER
         N     #2,=X'FFFFFFFC'     ROUND UP TO FULLWORD BOUNDARY
         LA    #2,12(,#2)          POINT PAST ZINT INFO
         LA    #0,4
GETATOMS L     #15,0(,#2)          LOAD POSSIBLE POINTER TO ATOMS
         N     #15,=X'7FFFFFFF'    CLEAR HIGH ORDER BIT
         LTR   #15,#15             IF POINTER IS NONZERO,
         BNZ   GOTATOMS            THEN THIS POINTS TO SYMBOLS
         LA    #2,4(,#2)           ELSE TRY NEXT ONE
         BCT   #0,GETATOMS         OUT OF 4 POSSIBLE POINTERS
         B     GIVEUP              IF NONE, JUST GIVE UP
GOTATOMS DS    0H                  NOW #15 POINTS TO ATOM POINTERS
FINDSYM  DS    0H                  BUT WE GOTTA BUMP TO 1ST SYMBOL PTR
         L     #1,0(,#15)
         CLI   ##TYPE(#1),##SYMBOL
         BE    GOTSYM
         LA    #15,4(,#15)
         B     FINDSYM
GOTSYM   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* IT IS ASSUMED THAT THE SYMBOL POINTERS START OUT WITH THE SYMBOLS   *
* REPRESENTING FREE VARIABLES, IN THE SAME ORDER AS THE CODE TRIES    *
* TO FILL THEM IN.  THE COMPILER INSURES THIS.                        *
*                                                                     *
***********************************************************************
         SPACE 1
FINDXC   CR    #2,#15              GOT TO STOP SEARCHING SOMEWHERE
         BNL   GIVEUP              SO ABANDON ALL HOPE WHEN AT ZLBPTRS
         CLI   0(#2),X'D7'         WHEN WE FOUND ONE
         BE    GOTXC               THEN CHECK IT OUT
         LA    #2,2(,#2)           ELSE BUMP BY 2 EACH TIME
         B     FINDXC
GOTXC    DS    0H                  NOW #2 -> AN XC INSTRUCTION
         LA    #1,X'FFF'           EXTRACT THE DISPLACEMENT OF THE
         N     #1,0(,#2)           STACK POINTERS TO FREE VARIABLES
         AR    #1,#11              CONVERT TO POINTER TO STACK SLOTS
         XR    #0,#0
         IC    #0,1(,#2)           GET LENGTH OF STACK FROM XC INSTR
         AR    #0,#1               CONVERT TO END-1 OF STACK SLOTS
FINDUV   CR    #1,#0
         BNL   GIVEUP              IF NOT FOUND, GIVE UP
         ICM   #14,15,0(#1)        CHECK THIS STACK SLOT
         BZ    GOTUV               IF ZERO, THIS IS THE UNBOUND VAR
         LA    #15,4(,#15)         ELSE BUMP TO NEXT SYMBOL POINTER
         LA    #1,4(,#1)           TRY NEXT STACK SLOT
         B     FINDUV
GOTUV    DS    0H
         L     #6,0(,#15)          GET POINTER TO SYMBOL
GIVEUP   DS    0H
         #ERR  PREFIX=NO,          DISPLAY ERROR MESSAGE               X
               'ZIL1300 ',FUNSTR,': Unbound lexical variable - ',(#6)
         EJECT
MVCNAME  MVC   FUNTEXT(*-*),5(#2)  Executed: Move function name to str
         SPACE 1
         DS    0H,XL1              Align fake string to non-halfword
FUNSTR   DC    YL1(##STRING)
FUNLEN   DS    AL3
FUNTEXT  DS    CL64
         EJECT
ATTN     DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* THIS ROUTINE RECEIVES CONTROL WHEN THE ZIL USER HITS ATTENTION AND  *
* PROCESSING IS FORCED THROUGH THIS PATH VIA THE INSERTION OF A       *
* "BR 13" INSTRUCTION INTO THE CODE WHERE THE ATTENTION WAS DETECTED, *
* OR VIA AN EXPLICIT CHECK IN A LOW-LEVEL ZIL ROUTINE.  PROCESSING:   *
*                                                                     *
*     IF THE ZLCISYS BIT IS ON, INDICATING THAT ATTENTION WAS HIT     *
*     WHILE NON-ZIL CODE WAS RUNNING, THEN ZIL REGISTERS HAVE TO BE   *
*     RESTORED - AND REMEMBER TO SET ZLCISYS OFF.  OTHERWISE, IF      *
*     AN INSTRUCTION HAD TO BE OVERLAID TO GET US UP HERE, THEN       *
*     RESTORE THE ORIGINAL INSTRUCTION.  THEN ISSUE A NOP (BC 0,0)    *
*     TO SYNCHRONIZE THE PROCESSOR JUST IN CASE THE OVERLAID          *
*     INSTRUCTION WAS, LIKE, REAL CLOSE TO THIS CODE.  THEN PROCEED   *
*     TO THROW TO THE APPROPRIATE CATCH TAG (I.E. T) TO RETURN THE    *
*     ZIL USER TO PERCEIVED "TOP LEVEL".  WHILE AN INSTRUCTION IS     *
*     OVERLAID, BIT ZLCIOVER WILL BE ON TO INDICATE THIS; SET IT OFF  *
*     RIGHT AFTER RESTORING THE INSTRUCTION.  THIS BIT IS USED TO     *
*     PREVENT THE OVERLAYING OF CODE IN THIS RECOVERY ROUTINE ITSELF  *
*     IN CASE ATTENTION SHOULD BE HIT DURING IT.                      *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    ZLCIFLGS,ZLCISYS    IF NON-ZIL CODE WAS RUNNING
         BZ    NOTSYS              THEN...
         NI    ZLCIFLGS,255-ZLCISYS RESTORE THE BIT
         L     #8,ZLCT              RESTORE #8
         L     #9,ZLCISV09          RESTORE #9
         L     #10,ZLCNIL           RESTORE #10
         B     ATTNDOIT            ELSE...
NOTSYS   DS    0H                   (ZIL CODE WAS RUNNING)
         TM    ZLCIFLGS,ZLCISVD    IF CODE IN PROGRESS ZAPPED REGS 8-11
         BZ    REGSOK              THEN
         LM    #8,#10,ZLCISAVE      RESTORE THEM FROM WHERE THEY SAVED
         NI    ZLCIFLGS,255-ZLCISVD
REGSOK   DS    0H
         TM    ZLCIFLGS,ZLCIOVER   IF AN INSTRUCTION WAS OVERLAID
         BZ    ATTNDOIT            THEN...
         L     #1,ZLCINSTA         POINT TO OVERLAID INSTRUCTION
         LH    #0,ZLCINSTR         GET ORIGINAL PIECE OF INSTRUCTION
         STH   #0,0(,#1)           RESTORE ORIGINAL INSTRUCTION
         BC    0,0                 SYNCHRONIZE INSTRUCTION PREFETCH
         NI    ZLCIFLGS,255-ZLCIOVER RESET ZAPPED-INSTRUCTION FLAG
ATTNDOIT DS    0H
         NI    ZLCIFLGS,255-ZLCIATTN RESET ATTN-IN-PROGRESS FLAG
*
* WE DON'T REALLY NEED THIS DUMB MESSAGE, BUT...
*
         #TPUT *,ATTNMSG           ISSUE MESSAGE
         SPACE 1
         LR    #1,#8               SET THROW TAG TO T
         LR    #2,#10              SET THROW RESULT TO NIL
         L     #15,ZLCTHROW        GET ADDRESS OF THROW PROCESSOR
         BR    #15                 INVOKE THROW TO TAG T
         SPACE 1
ATTNMSG  DC    C'ZIL0054 ATTENTION ABORT TO TOP LEVEL.'
         SPACE
         LTORG
         SPACE
         #ZEQU
         SPACE
         #ZCOM
         SPACE
         #ZINT
         END
