***********************************************************************
*                                                                     *
* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *
*                     All rights reserved.                            *
*                                                                     *
***********************************************************************
         TITLE 'STRING-SCAN - MACROS'
         MACRO
&SYM     XTRT  &DATR,&TABLE,&LENR=,&F256=#0
         LCLC  &LBLA,&LBLB,&LBLC,&LBLX
&LBLA    SETC  'XTRA&SYSNDX'
&LBLB    SETC  'XTRB&SYSNDX'
&LBLC    SETC  'XTRC&SYSNDX'
&LBLX    SETC  'XTRX&SYSNDX'
&SYM     LA    &F256,256            Set up constant 256
&LBLC    CR    &LENR,&F256          If length greater than 256
         BNH   &LBLA                then...
         TRT   0(256,&DATR),&TABLE   scan for desired characters
         BNZ   &LBLB                 If we found something, exit
         AR    &DATR,&F256           Else increment text pointer by 256
         SR    &LENR,&F256           Decrement length by 256
         B     &LBLC                 Continue scanning.
&LBLX    TRT   0(*-*,&DATR),&TABLE  (Executed instruction)
&LBLA    DS    0H                  Else...
         BCTR  &LENR,0              Reduce length for execute
         EX    &LENR,&LBLX          Scan for desired characters
&LBLB    DS    0H
         MEND
         TITLE 'STRING-SCAN - BUILT-IN ZIL 1.3 SUBROUTINE'
***********************************************************************
*                       ZIL 1.3 MAR88 - S. BACHER                     *
***********************************************************************
*                                                                     *
* STRING-SCAN                                                         *
*                                                                     *
* This function takes (1) a string to be tokenized and returns a list *
* of strings, all of which are "words" in the string.  The string is  *
* parsed into words according to the following optional arguments:    *
*                                                                     *
* (2) the whitespace string, which is a "bag" of string characters    *
*     to act as whitespace (in other words, the occurrence of any     *
*     of the characters in the "whitespace bag" marks the end of a    *
*     word).                                                          *
*                                                                     *
* (3) the singleton string, which is a "bag" of string characters     *
*     to act as self-defined single characters.  Each of these gets   *
*     returned as a one-character string in the resulting list.       *
*                                                                     *
* (4) either a null string, a one-character string, or a              *
*     two-character string, which defines a "quote" character.  The   *
*     first character of the string defines the character to be used  *
*     to quote strings, and the second character determines the       *
*     convention for embedding the quote character in the string.     *
*     If a one-character string is specified, or the second character *
*     is the same as the first, the quote character is specified by   *
*     doubling it (e.g. 'don''t').  If the second character is a      *
*     different character from the first, it is a "single escape"     *
*     character, and any character following it is contained in the   *
*     quoted string (e.g. "don\"t").                                  *
*                                                                     *
*     The string is constructed including the enclosing quotes and    *
*     doubled embedded quotes or escape characters.  In this way the  *
*     caller can distinguish between quoted and unquoted strings,     *
*     but is responsible for unquoting the string him/herself.        *
*                                                                     *
*     An error is signalled if the ending quote of a string is not    *
*     found, or if the escape character is not followed by something. *
*                                                                     *
*     If a null string is specified, no quote character is used.      *
*     Only one quote character can be specified.                      *
*                                                                     *
* (5) a beginning-comment string (not a "bag") which signals the      *
*     beginning of a comment.  If "", there is no sequence which      *
*     starts a comment.  Comments are terminated by end-of-string     *
*     or the ending-comment string specified in...                    *
*                                                                     *
* (6) an ending-comment string (not a "bag") which signals the        *
*     end of a comment.  If "", only end-of-string can terminate      *
*     a comment.                                                      *
*                                                                     *
* (7) a list of multiple-character tokens (strings of length 2 or     *
*     more).   Default is the null list.                              *
*                                                                     *
* Syntax:                                                             *
*                                                                     *
*  (STRING-SCAN string &optional (whitespace-bag       " ")           *
*                                (singleton-bag        "" )           *
*                                (quote-spec           "" )           *
*                                (comment-start-string "" )           *
*                                (comment-end-string   "" )           *
*                                (token-list           NIL)           *
*  )                                                                  *
*                                                                     *
* Note:  If NIL is specified for any of the arguments other than the  *
*        last (token-list), it is treated like the string "NIL".      *
*        Therefore, do not specify NIL to mean a default or           *
*        unsupplied argument for any of those arguments!              *
*                                                                     *
***********************************************************************
         SPACE 1
SSCAN    #ZBEG MINARGS=1,MAXARGS=7,NAME='STRING-SCAN'
         #ZPDS 7*4+12+12 = 52      DEFINE STACK SIZE
         #ZSAV ,                   SAVE REGISTERS
         SPACE 1
         LM    #3,#7,0(#11)        Load args 1, 2, 3, 4, 5 (not 6 yet)
         XC    TRTDLM(256),TRTDLM  Init whitespace translate table
         MVI   TRTNDLM,4           Init non-whitespace translate table
         MVC   TRTNDLM+1(255),TRTNDLM
         XC    TRTQUOTE(256),TRTQUOTE Init quoted string translate tbl
         SPACE 1
***********************************************************************
*                                                                     *
* Process argument 1, the string                                      *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   ##TYPE(#3),##STRING IF ARGUMENT IS A STRING
         BE    ARG1OK              THEN OK
         CLI   ##TYPE(#3),##SYMBOL IF ARGUMENT IS A SYMBOL
         BNE   ERROR1              THEN
         L     #3,##PNAME(,#3)      TAKE THE PRINT NAME, ELSE ERROR
ARG1OK   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Process argument 2, the whitespace bag                              *
*                                                                     *
***********************************************************************
         SPACE 1
         CR    #4,#13              If arg 2 is unsupplied
         BNE   NOTDEF2             then...
         MVI   TRTDLM+X'40',4       set space as only delimiter
         MVI   TRTNDLM+X'40',0      set space as only delimiter
         B     BUILTTRT             and go to check arg 3
NOTDEF2  DS    0H                  Else...
         CLI   ##TYPE(#4),##STRING IF ARGUMENT IS A STRING
         BE    ARG2OK              THEN OK
         CLI   ##TYPE(#4),##SYMBOL IF ARGUMENT IS A SYMBOL
         BNE   ERROR2              THEN
         L     #4,##PNAME(,#4)      TAKE THE PRINT NAME, ELSE ERROR
ARG2OK   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Build translate table from argument 2                               *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    #14,#14             Clear insert register
         ICM   #14,7,1(#4)         Get length of argument 2
         BZ    BUILTTRT            If zero, finished
         LA    #1,##VECDAT(,#4)    Point to text of string arg 2
         XR    #15,#15             Clear insert register
         LA    #0,4                Set value to stick into table
         XR    #2,#2               Set value to stick into table
TBLDLOOP DS    0H
         IC    #15,0(,#1)          Get character from string arg 2
         STC   #0,TRTDLM(#15)      Set table char to flag as delimiter
         STC   #2,TRTNDLM(#15)     Set table char to bypass delimiters
         LA    #1,1(,#1)           Increment character pointer
         BCT   #14,TBLDLOOP        Continue until arg 2 exhausted
BUILTTRT DS    0H                  Now tables are built
         SPACE 1
***********************************************************************
*                                                                     *
* Process argument 3, the singleton bag                               *
*                                                                     *
***********************************************************************
         SPACE 1
         CR    #5,#13              If arg 3 is unsupplied
         BE    NOSINGLE            then do nothing.
         CLI   ##TYPE(#5),##STRING IF ARGUMENT IS A STRING
         BE    ARG3OK              THEN OK
         CLI   ##TYPE(#5),##SYMBOL IF ARGUMENT IS A SYMBOL
         BNE   ERROR3              THEN
         L     #5,##PNAME(,#5)      TAKE THE PRINT NAME, ELSE ERROR
ARG3OK   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Modify translate tables from argument 3                             *
*                                                                     *
* Note that any singleton character specified overrides the same      *
* character having been specified in the whitespace bag.              *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    #14,#14             Clear insert register
         ICM   #14,7,1(#5)         Get length of argument 3
         BZ    NOSINGLE            If zero, finished
         LA    #1,##VECDAT(,#5)    Point to text of string arg 3
         XR    #15,#15             Clear insert register
         LA    #0,8                Set value to stick into table
TMODLOOP DS    0H
         IC    #15,0(,#1)          Get character from string arg 3
         STC   #0,TRTDLM(#15)      Set table char to flag as singleton
         STC   #0,TRTNDLM(#15)     Set table char to flag as singleton
         LA    #1,1(,#1)           Increment character pointer
         BCT   #14,TMODLOOP        Continue until arg 3 exhausted
NOSINGLE DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Process argument 4, the quote bag                                   *
*                                                                     *
***********************************************************************
         SPACE 1
         CR    #6,#13              If arg 4 is unsupplied
         BE    NOQUOTE             then do nothing.
         CLI   ##TYPE(#6),##STRING IF ARGUMENT IS A STRING
         BE    ARG4OK              THEN OK
         CLI   ##TYPE(#6),##SYMBOL IF ARGUMENT IS A SYMBOL
         BNE   ERROR4              THEN
         L     #6,##PNAME(,#6)      TAKE THE PRINT NAME, ELSE ERROR
ARG4OK   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Modify translate tables from argument 4                             *
*                                                                     *
* Note that any quote character specified overrides the same          *
* character having been specified in a previous bag argument.         *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    #14,#14             Clear insert register
         ICM   #14,7,1(#6)         Get length of argument 4
         BZ    NOQUOTE             If zero, finished
         XR    #15,#15             Clear insert register
         LA    #0,12               Set value to stick into table
         IC    #15,##VECDAT(,#6)   Get quote character from arg 4
         STC   #0,TRTDLM(#15)      Set table char to flag as quoter
         STC   #0,TRTNDLM(#15)     Set table char to flag as quoter
         C     #14,#SFW1           If string length is 1,
         BE    EMDQUOTE            then embed quotes by doubling
         C     #14,#SFW2           If string length is not 2,
         BNE   ERROR4A             then invalid arg 4
         CLM   #15,1,##VECDAT+1(#6) If character 2 same as character 1
         BE    EMDQUOTE            then embed quotes by doubling
         LA    #0,4                Else set normal quote value
         STC   #0,TRTQUOTE(#15)    Set table char to flag as quoter
         LA    #0,12               Set escape value
         IC    #15,##VECDAT+1(,#6) Get escape character from arg 4
         STC   #0,TRTQUOTE(#15)    Set table char to flag as escape
         B     NOQUOTE
EMDQUOTE DS    0H
         LA    #0,8                Set doubling quote value
         STC   #0,TRTQUOTE(#15)    Set table char quote doubler
NOQUOTE  DS    0H
         SPACE 1
         XR    #14,#14             Clear insert register
         STH   #14,COMSLEN         Initialize start string length to 0
         STH   #14,COMELEN         Initialize end string length to 0
         SPACE 1
***********************************************************************
*                                                                     *
* Process argument 5, the comment start string                        *
*                                                                     *
***********************************************************************
         SPACE 1
         CR    #7,#13              If arg 5 is unsupplied
         BE    NOCOMM              then do nothing.
         CLI   ##TYPE(#7),##STRING IF ARGUMENT IS A STRING
         BE    ARG5OK              THEN OK
         CLI   ##TYPE(#7),##SYMBOL IF ARGUMENT IS A SYMBOL
         BNE   ERROR5              THEN
         L     #7,##PNAME(,#7)      TAKE THE PRINT NAME, ELSE ERROR
ARG5OK   DS    0H
         ST    #7,16(,#11)         Store back on stack for future use
         SPACE 1
***********************************************************************
*                                                                     *
* Modify translate tables from argument 5                             *
*                                                                     *
* Note that we alter the entry by adding 16 (X'10') to it.            *
* The original function of the character, if any, is unchanged.       *
*                                                                     *
***********************************************************************
         SPACE 1
         ICM   #14,7,1(#7)         Get length of argument 5
         BZ    NOCOMM              If zero, no comment start string
         CH    #14,=H'256'         Cannot be longer than 256
         BH    ERROR5A             (I mean, don't be ridiculous)
         STH   #14,COMSLEN         Save comment start string length
         BCTR  #14,0               Reduce for CLC
         STC   #14,CLCCOMS+1       Store into CLC instruction
*                                  Assert #14 = X'000000__'
         IC    #14,##VECDAT(,#7)   Get first character of string
         LA    #1,TRTDLM(#14)      Point to position in translate table
         OI    0(#1),X'10'         Set up for TRT
         LA    #1,TRTNDLM(#14)     Point to position in translate table
         OI    0(#1),X'10'         Set up for TRT
         XC    TRTCOM(256),TRTCOM  Initialize comment translate table
         XC    TRTCS(256),TRTCS    Initialize comment translate table
         LA    #1,TRTCS(#14)       Point to position in translate table
         MVI   0(#1),4             Set up for TRT
         SPACE 1
***********************************************************************
*                                                                     *
* Process argument 6, the comment end string                          *
*                                                                     *
***********************************************************************
         SPACE 1
         L     #7,20(,#11)         Load argument 6
         CR    #7,#13              If arg 6 is unsupplied
         BE    NOCOMM              then do nothing.
         CLI   ##TYPE(#7),##STRING IF ARGUMENT IS A STRING
         BE    ARG6OK              THEN OK
         CLI   ##TYPE(#7),##SYMBOL IF ARGUMENT IS A SYMBOL
         BNE   ERROR6              THEN
         L     #7,##PNAME(,#7)      TAKE THE PRINT NAME, ELSE ERROR
ARG6OK   DS    0H
         ST    #7,20(,#11)         Store back on stack for future use
         XR    #14,#14             Clear insert register
         ICM   #14,7,1(#7)         Get length of argument 6
         BZ    NOCOMM              If zero, no comment end string
         CH    #14,=H'256'         Cannot be longer than 256
         BH    ERROR6A             (I mean, don't be ridiculous)
         STH   #14,COMELEN         Save comment end string length
         BCTR  #14,0               Reduce for CLC
         STC   #14,CLCCOME+1       Store into CLC instruction
*                                  Assert #14 = X'000000__'
         IC    #14,##VECDAT(,#7)   Get first character of string
         LA    #1,TRTCOM(#14)      Point to position in translate table
         MVI   0(#1),4             Set up for TRT
         SPACE 1
NOCOMM   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Process argument 7, the multiple-character token list               *
*                                                                     *
***********************************************************************
         SPACE 1
         L     #7,24(,#11)         Get argument 7
         CR    #7,#13              If arg 7 is unsupplied
         BE    NOTLIST             then do nothing.
         SPACE 1
***********************************************************************
*                                                                     *
* Modify translate tables from argument 7                             *
*                                                                     *
* Note that we alter the entry by adding 32 (X'20') to it.            *
* The original function of the character, if any, is unchanged.       *
*                                                                     *
***********************************************************************
         SPACE 1
TLLOOP   DS    0H                  Loop through elements of list
         CR    #7,#10
         BE    NOTLIST             When list is null, finished
         ICM   #2,15,##CAR(#7)     Get CAR of list
         BM    ERROR7              If sublist was atomic, error
         CLI   ##TYPE(#2),##STRING IF ARGUMENT IS A STRING
         BE    ELEM7OK             THEN OK
         CLI   ##TYPE(#2),##SYMBOL IF ARGUMENT IS A SYMBOL
         BNE   ERROR7A             THEN
         L     #2,##PNAME(,#2)      TAKE THE PRINT NAME, ELSE ERROR
ELEM7OK  DS    0H
         ICM   #14,7,1(#2)         Get length of element
         BZ    ELEM7NXT            If zero, skip this one
         CH    #14,=H'256'         Cannot be longer than 256
         BH    ERROR7B             (I mean, don't be ridiculous)
         IC    #14,##VECDAT(,#2)   Get first character of string
         LA    #1,TRTDLM(#14)      Point to position in translate table
         OI    0(#1),X'20'         Set up for TRT
         LA    #1,TRTNDLM(#14)     Point to position in translate table
         OI    0(#1),X'20'         Set up for TRT
ELEM7NXT DS    0H
         L     #7,##CDR(,#7)       Get CDR of list
         B     TLLOOP              Continue
         SPACE 1
NOTLIST  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* OK, all arguments processed.  Let's get moving.                     *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    #7,#7               CLEAR INSERT REGISTER
         ST    #3,0(,#11)          STORE BACK ON STACK FOR FUTURE USE
         ICM   #7,7,1(#3)          GET LENGTH OF STRING
         BZ    RETNIL              IF ZERO-LENGTH STRING, RETURN NIL
         LA    #6,##VECDAT         Offset of substring to scan
         LA    #7,##VECDAT(,#7)    Offset of end of string
         LR    #15,#7              Get offset of end of string minus
         SH    #15,COMSLEN          length of comment start string
         ST    #15,COMSEND         Store it
         LR    #15,#7              Get offset of end of string minus
         SH    #15,COMELEN          length of comment end string
         ST    #15,COMEEND         Store it
         SPACE 1
***********************************************************************
*                                                                     *
* Initialize the return list on the stack.                            *
*                                                                     *
***********************************************************************
         SPACE 1
         ST    #10,40(,#11)        Initialize return list to NIL
         ST    #10,44(,#11)        Initialize return list to NIL
         ST    #10,48(,#11)        Initialize saved MT holder to NIL
         SPACE 1
LOOP     DS    0H                  Loop to search for words, etc.
         SPACE 1
***********************************************************************
*                                                                     *
*     Scan string for next non-whitespace character.                  *
*     #6 = offset of substring to scan                                *
*     #7 = offset of end of string                                    *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    #15,#7              Compute length to scan
         SR    #15,#6              If not positive,
         BNP   RETLIST              return with list
*
* In case a multi-character token was found in a previous scan and
* we'd just pick it up again, this is to avoid duplicating the search
*
         C     #10,48(,#11)        If there's a stacked token string
         BE    NOSTKDMT            then...
         L     #4,48(,#11)          load it up
         ST    #10,48(,#11)         clear stacked entry
         XR    #14,#14              clear insert register
         ICM   #14,7,1(#4)          get length of token string
         ST    #14,LEN2NEXT         remember it for future bumping
         B     CONSIT               and go add it to result list
NOSTKDMT DS    0H
         LR    #14,#6              Compute address in string to scan
         A     #14,0(,#11)          from offset
         XR    #2,#2               Clear TRT register
         XTRT  #14,TRTNDLM,LENR=#15 Scan for constituent
         CH    #2,=Y(32)           If X'20' bit is on from table
         BNL   FOUNDMT             then found possible multichar token
         B     XTRTND(#2)          Else go depending on what was found
XTRTND   B     RETLIST             0, nothing found, return with list
         B     FOUNDND             4, constituent found, process it
         B     MKSINGLE            8, singleton found, make character
         B     FOUNDQ              12, quote found, make quoted string
         B     COMMENT             16, comment or whitespace
         B     CFOUNDND            20, comment or constituent
         B     CMKSINGL            24, comment or singleton
         B     CFOUNDQ             28, comment or quote
         SPACE 1
FOUNDMT  DS    0H                  Found possible multicharacter token
         SPACE 1
         BAL   #3,TRYMT            Try to find a matching token
         ST    #14,LEN2NEXT        Set length to bump past
         LTR   #4,#15              If we found one, #15 -> the string
         BNZ   CONSIT              and go add it to result list
         SH    #2,=Y(32)           Else turn off X'20' bit
         BNZ   XTRTND(#2)          If nonzero, proceed from table
         LA    #6,1(,#6)           Else zero, process as whitespace
         B     LOOP                and go back to scan again.
         SPACE 1
COMMENT  DS    0H                  Either a comment or whitespace
         SPACE 1
         BAL   #3,TRYCOMT          See if this is really a comment
         LTR   #15,#15             If it was,
         BNZ   LOOP                then go back to scan again
         LA    #6,1(,#6)           Else bump past whitespace char
         B     LOOP                and go back to scan again.
         SPACE 1
CFOUNDND DS    0H                  Either a comment or constituent
         SPACE 1
         BAL   #3,TRYCOMT          See if this is really a comment
         LTR   #15,#15             If it was,
         BNZ   LOOP                 then go back to scan again
         B     FOUNDND             Else go to process constituent
         SPACE 1
CMKSINGL DS    0H                  Either a comment or singleton
         SPACE 1
         BAL   #3,TRYCOMT          See if this is really a comment
         LTR   #15,#15             If it was,
         BNZ   LOOP                 then go back to scan again
         B     MKSINGLE            Else go to process singleton
         SPACE 1
CFOUNDQ  DS    0H                  Either a comment or quote
         SPACE 1
         BAL   #3,TRYCOMT          See if this is really a comment
         LTR   #15,#15             If it was,
         BNZ   LOOP                 then go back to scan again
         B     FOUNDQ              Else go to process quote
         SPACE 1
MKSINGLE DS    0H                  #1 -> single character
         SPACE 1
         LR    #6,#1               Get pointer to substring
         S     #6,0(,#11)          Convert to offset
         LA    #3,1                Set length of substring
         ST    #3,LEN2NEXT         Save it
*                                  Assert #2 = X'00000008'
         IC    #2,0(,#1)           Get singleton character
         LR    #1,#2               Get singleton character
         SLA   #2,3                Convert to index into SINGTAB
         L     #4,=A(SINGTAB)
         ALR   #4,#2               Get address of SINGTAB entry
         CLI   0(#4),##STRING      If there's already a string there
         BE    CONSIT              then use it.
         SLL   #1,24               Else shift character over string
         L     #0,STRHDR           Set up string header with contents
         STM   #0,#1,0(#4)         Initialize string
         B     CONSIT              Go add it to list
         SPACE 1
FOUNDQ   DS    0H                  Start of a quoted string
         SPACE 1
***********************************************************************
*                                                                     *
*     Scan quoted string, processing either doubled quotes or         *
*     escape characters.                                              *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    #6,#1               Save address of first quote
         S     #6,0(,#11)          Convert to offset within string
         LA    #3,1(,#6)           Next character is first to scan
QLOOP    DS    0H
         LR    #15,#7              Compute length remaining to scan
         SR    #15,#3
         BNP   ERROR4B             If not positive, missing end quote
         LR    #14,#3              Compute address in string to scan
         A     #14,0(,#11)          from offset
         XR    #2,#2               Clear TRT register
         XTRT  #14,TRTQUOTE,LENR=#15 Scan quoted string
         B     XTRTQ(#2)           Branch depending on what found
XTRTQ    B     ERROR4B             0, nada found, missing quote error
         B     QEND                4, normal quote found, ends string
         B     QQUOTE              8, doubling quote found, check it
         B     QESCAPE             12, escape char found, process it
         SPACE 1
QEND     DS    0H                  Found quote that marks end of string
         SPACE 1
         LA    #3,1(,#1)           Get address of char following quote
         S     #3,0(,#11)          Convert to offset
         B     QWORDEND            Go to process complete quoted string
         SPACE 1
QQUOTE   DS    0H                  Found quote.  Check for double
         SPACE 1
         LA    #3,1(,#1)           Get address of char following quote
         S     #3,0(,#11)          Convert to offset
         LR    #15,#7              Compute length remaining to scan
         SR    #15,#3
         BNP   QWORDEND            If zero, this is an ending quote
         CLC   0(1,#1),1(#1)       If quote is not doubled
         BNE   QWORDEND            then this is an ending quote
         LA    #3,1(,#3)           Else bump past second quote
         B     QLOOP               and continue scanning
         SPACE 1
QESCAPE  DS    0H                  Found escape character.
         SPACE 1
         LA    #3,1(,#1)           Get address of char following escape
         S     #3,0(,#11)          Convert to offset
         LR    #15,#7              Compute length remaining to scan
         SR    #15,#3
         BNP   ERROR4C             If zero, dangling escape character
         LA    #3,1(,#3)           Else bump past char following escape
         B     QLOOP               and continue scanning
         SPACE 1
QWORDEND DS    0H
         SPACE 1
         ST    #6,WORDPTR          Store offset of start of "word"
         B     ENDWORDQ            Go to process complete quoted string
         SPACE 1
FOUNDND  DS    0H                  #1 -> constituent character
         SPACE 1
***********************************************************************
*                                                                     *
*     Scan string for first delimiter following constituents found,   *
*     or else end of string delimits this word.                       *
*     The substring from constituent to here is used to construct a   *
*     new string to be added at the end of the list being built.      *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    #6,#1               Save address of first constituent
         S     #6,0(,#11)          Convert to offset within string
         ST    #6,WORDPTR          Save it
         LA    #6,1(,#6)           Bump to next character
WORDLOOP DS    0H
         LR    #1,#7               Preset end-of-word to end-of-string
         A     #1,0(,#11)           from offset
         LR    #15,#7              Compute length remaining to scan
         SR    #15,#6              If zero, end of word
         BNP   ENDWORD
         LR    #14,#6              Compute address in string to scan
         A     #14,0(,#11)          from offset
         XR    #2,#2               Preset anything-found TRT register
         XTRT  #14,TRTDLM,LENR=#15 Scan for end of word
         CH    #2,=Y(32+16)        If multichar-token-or-comment-or-
         BE    DTRYMT               constituent, then check it.
         CH    #2,=Y(32)           If multichar-token-or-constituent
         BE    DTRYMT               then check it.
TRYNOTMT DS    0H
         CH    #2,=Y(16)           If comment-or-constituent,
         BE    DTRYCOM              then check it.
         B     ENDWORD             Else always end of word.
         SPACE 1
DTRYCOM  DS    0H                  Possible comment
         BAL   #3,TRYCOMT          See if this is a comment
         LTR   #15,#15              Get address of start of comment
         BNZ   ENDWORDC             If it was a comment, it ends word
         LA    #6,1(,#6)           Else bump past constituent char
         B     WORDLOOP            and continue scan.
         SPACE 1
ENDWORDC DS    0H                  Word ended by comment string
         SPACE 1
*                                  #6 = offset of end of comment
         S     #6,WORDPTR          Subtract offset of start of word
         ST    #6,LEN2NEXT         Save length to get to next word
         LR    #3,#15              Get address of start of comment
         S     #3,0(,#11)          Convert to offset
         L     #6,WORDPTR          Get offset of start of word
         SR    #3,#6               Compute length of word substring
         B     MAKEIT
         SPACE 1
DTRYMT   DS    0H                  Possible multi-character token
         BAL   #3,TRYMT            See if this is a token
         LTR   #15,#15             Get address of token string
         BNZ   ENDWORDM            If it was a token, it ends word
         SH    #2,=Y(32)           Else turn off token flag in TRT reg
         BNZ   TRYNOTMT            If still something, try again
         LA    #6,1(,#6)           Else bump past constituent char
         B     WORDLOOP            and continue scan.
         SPACE 1
ENDWORDM DS    0H                  Word ended by multi-char token
         SPACE 1
         ST    #15,48(,#11)        Save ptr to token string on stack
         LR    #3,#6               Get offset of start of new token
         L     #6,WORDPTR          Get offset of start of old word
         SR    #3,#6               Compute length of word substring
         ST    #3,LEN2NEXT         Save it
         B     MAKEIT              Go to make the word
         SPACE 1
ENDWORD  DS    0H                  Found end of word or substring
         SPACE 1
         LR    #3,#1               Get pointer past end of word
         S     #3,0(,#11)          Convert to offset
ENDWORDQ DS    0H                  #3 = offset of end of word
         L     #6,WORDPTR          Get offset of start of word
         SR    #3,#6               Compute length of word substring
         ST    #3,LEN2NEXT         Save it
MAKEIT   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Make a string out of the substring just scanned.                    *
*                                                                     *
* #1 -> position past last constituent character in word just scanned *
* #2 tells what was found                                             *
* #3 is offset of where we scanned to                                 *
* #6 is offset of start of word within string                         *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    #2,#3               Get length into reg for ZILVSS
         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE
         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS
         LA    #0,52(,#11)         SET CURRENT STACK POINTER FOR GC
         BALR  #14,#15             CALL ZILVSS TO CREATE A STRING
         LTR   #4,#15              IF STRING BUILD FAILED
         BZ    ERRORG              THEN ERROR
         LR    #0,#6               Get offset of substring to build
         A     #0,0(,#11)          Convert to address in string arg 1
         LA    #14,##VECDAT(,#4)   Point to where to move string text
         LR    #1,#3               Get length of string text to move
         LR    #15,#3
         MVCL  #14,#0              Move text from substring to new
CONSIT   DS    0H                  Add new string to list
*                                  #3 = length of new string
*                                  #4 = address of new string
*                                  #6 = offset of new string in arg 1
         LR    #1,#4               Arg 1 to CONS = new string
         LR    #2,#10              Arg 2 to CONS= NIL
         L     #15,ZLCCONS         Get address of ZILCONS
         LA    #0,52(,#11)         SET CURRENT STACK POINTER FOR GC
         BALR  #14,#15             Call ZILCONS to (cons string NIL)
         C     #10,44(,#11)        If no list so far yet,
         BNE   OLDLIST              then...
         ST    #15,40(,#11)         set the list to this
         B     AFTLIST
OLDLIST  DS    0H                  else...
         L     #14,44(,#11)         get address of last-cons-to-bash
         ST    #15,##CDR(,#14)      bash into list
AFTLIST  DS    0H
         ST    #15,44(,#11)        Set cons-to-bash to latest cons
         A     #6,LEN2NEXT         Reset string scanning offset
         B     LOOP                Continue looking for words
         SPACE 1
RETNIL   DS    0H                  Null string, or only whitespace
         LR    #15,#10             Return a null list
         B     RETURN
RETLIST  DS    0H
         L     #15,40(,#11)        Return the list built
RETURN   DS    0H
         SPACE 1
         #ZRET ,                   RESTORE REGISTERS AND RETURN
         SPACE 1
TRYCOMT  DS    0H                  Subroutine to check for comment
         SPACE 1
         LR    #6,#1               Get pointer to substring
         S     #6,0(,#11)          Convert to offset
         XR    #15,#15             Preset return value to "NO"
         C     #6,COMSEND          If past place where there can be
         BHR   #3                   a comment starter, return "NO"
         L     #14,16(,#11)        Get address of comment start string
*
* Note: The CLC length field was filled in when arg 5 was processed.
*
CLCCOMS  CLC   0(*-*,#1),##VECDAT(#14) If this isn't comment start
         BNER  #3                   then return "NO"
         ST    #1,CCSADDR          Else save address of comment start
         AH    #6,COMSLEN          Bump past end of comment string
TRYLOOP  DS    0H                  Else...
         LR    #15,#7              Compute length remaining to scan
         SR    #15,#6
         BNP   TRYCOMTE            If zero, hit end of string
         LR    #14,#6              Compute address in string to scan
         A     #14,0(,#11)          from offset
         XTRT  #14,TRTCOM,LENR=#15 Scan for comment end string
         BZ    TRYCOMTE            If hit end of string, so be it
         LR    #6,#1               Get pointer to substring
         S     #6,0(,#11)          Convert to offset
         C     #6,COMEEND          If past place where there can be
         BH    TRYCOMTE             a comment ender, go end of string
         L     #14,20(,#11)        Get address of comment start string
*
* Note: The CLC length field was filled in when arg 6 was processed.
*
CLCCOME  CLC   0(*-*,#1),##VECDAT(#14) If this isn't comment start
         BNE   TRYCONT              then keep scanning
         AH    #6,COMELEN          Bump past comment end string
         L     #15,CCSADDR         Indicate end-of-comment found
         BR    #3                  Return
TRYCONT  DS    0H                  Comment ender didn't match
         LA    #6,1(,#6)           Bump to next character
         B     TRYLOOP             Continue scanning
TRYCOMTE DS    0H                  Hit end of string
         LR    #6,#7               Set offset past string end
         L     #15,CCSADDR         Indicate comment ended at string end
         BR    #3                  Return
         SPACE 1
TRYMT    DS    0H                  Subroutine to find multi-char token
         SPACE 1
         ST    #3,SAVEMTR
         LR    #6,#1               Get address of character found
         S     #6,0(,#11)          Convert to offset in string
         LR    #0,#7               Get length of remainder of string
         SR    #0,#6
         XR    #14,#14             Clear register for inserts
         L     #3,24(,#11)         Get address of token list
MTLOOP   DS    0H
         CR    #3,#10              When null list,
         BE    NOTMT               no matching token
         L     #15,##CAR(,#3)      Get element of list
         CLI   ##TYPE(#15),##SYMBOL If it's actually a symbol
         BNE   MTNOTSYM            then
         L     #15,##PNAME(,#15)    get its print name
MTNOTSYM DS    0H
         ICM   #14,7,1(#15)        Get string length
         BZ    MTSKIP              If zero, skip this one
         CR    #0,#14              Compare remaining length
         BL    MTSKIP              If less than string length, skip
         BCTR  #14,0               Reduce string length for execute
         EX    #14,CLCMT           Compare substring to token
         BE    MTFOUND             If this is it, go process it
MTSKIP   DS    0H                  Else token not found yet
         L     #3,##CDR(,#3)       Get CDR of list
         B     MTLOOP              and continue.
MTFOUND  DS    0H                  We think we found a token, but...
*
* Check that the comment start string isn't embedded in the substring
*
* #7 = remaining length in substring
* #14 = token length - 1
* COMSLEN = length of defined comment start string if any
* #15 -> the string that defines the token
*
         LH    #4,COMSLEN          Get length of comment start string
         LTR   #0,#4               If zero
         BZ    MTREALLY             then no comment string, this is OK
         AR    #0,#14              Get tokenlength+comslen-1
         CR    #7,#0               If remaining length too short to
         BL    MTREALLY             be a comment, then this MT is OK
         STM   #14,#2,SAVEEM       Save regs across TRT, etc.
         LA    #0,1(#14,#1)        Get address of end of MT substr
         BCTR  #4,0                Reduce CSS length for future EX's
MTXLOOP  DS    0H
         LR    #14,#0               Get length to scan
         SR    #14,#1               If zero, no more to scan,
         BNP   MTLMREAL              this MT must be OK
         BCTR  #14,0                Adjust for execute
         EX    #14,MTTRT            See if comment may begin here
         BZ    MTLMREAL             If not, that's all
         L     #2,16(,#11)          Get address of comment string
         EX    #4,CLCCOM            If it matches
         BE    MTLMSKIP             then this isn't one...
         LA    #1,1(,#1)
         B     MTXLOOP              then keep trying
MTLMSKIP DS    0H                  Not the one because we found comment
         LM    #14,#2,SAVEEM        start string, so reload registers
         B     MTSKIP               and try the next token in list
MTLMREAL DS    0H                  OK, we really found the token
         LM    #14,#2,SAVEEM       (restoring regs across TRT)
MTREALLY DS    0H                  OK, we really found the token
         LA    #14,1(,#14)         Restore string token length
         L     #3,SAVEMTR
         BR    #3                  Return to caller
NOTMT    DS    0H                  No matching token found
         XR    #15,#15             Indicate nothing found
         L     #3,SAVEMTR
         BR    #3                  Return to caller
         SPACE 1
CLCMT    CLC   0(*-*,#1),##VECDAT(#15) Executed: compare string token
MTTRT    TRT   0(*-*,#1),TRTCS     Executed: scan for comment start
CLCCOM   CLC   0(*-*,#1),##VECDAT(#2) Executed: compare string comment
         SPACE 1
WORDPTR  DS    F                   Offset of start of word scanned
LEN2NEXT DS    F                   Offset of next place to scan
SAVEMTR  DS    A                   Return address
SAVEEM   DS    5A                  Save
CCSADDR  DS    F                   Address of start of comment string
COMSEND  DS    F                   Offset of last place to see c.s.s.
COMEEND  DS    F                   Offset of last place to see c.e.s.
COMSLEN  DS    H                   Length of comment start string
COMELEN  DS    H                   Length of comment end string
         SPACE 1
STRHDR   DS    0F
         DC    YL1(##STRING),AL3(1) Header for single-character strings
         SPACE 1
         LTORG
         SPACE 1
TRTDLM   DC    256X'00'            Table to scan for delimiters
         SPACE 1
TRTNDLM  DC    256X'00'            Table to scan for non-delimiters
         SPACE 1
TRTQUOTE DC    256X'00'            Table to scan quoted strings
         SPACE 1
TRTCOM   DC    256X'00'            Table to scan comment strings
         SPACE 1
TRTCS    DC    256X'00'            Table to scan comment strings
         SPACE 1
ERROR1   LA    #2,1
         LR    #7,#3
         B     ERROR
ERROR2   LA    #2,2
         LR    #7,#4
         B     ERROR
ERROR3   LA    #2,3
         LR    #7,#5
         B     ERROR
ERROR4   LA    #2,4
         LR    #7,#6
         B     ERROR
ERROR5   LA    #2,5
         B     ERROR
ERROR6   LA    #2,6
         B     ERROR
ERROR    #ERR  'Argument ',#2,' to STRING-SCAN not a string - ',(#7)
ERROR7   #ERR  'Argument 7 to STRING-SCAN not a proper list - ',       X
               24(#11)
ERROR4A  #ERR  'Argument 4 to STRING-SCAN longer than 2 characters - ',X
               (#6)
ERROR4B  #ERR  'Missing end quote found by STRING-SCAN while scanning -X
                ',0(#11)
ERROR4C  #ERR  'Dangling escape found by STRING-SCAN while scanning - 'X
               ,0(#11)
ERROR5A  #ERR  'Argument 5 to STRING-SCAN longer than 256 characters - X
               ',(#7)
ERROR6A  #ERR  'Argument 6 to STRING-SCAN longer than 256 characters - X
               ',(#7)
ERROR7A  #ERR  'Non-string element found in argument 7 to STRING-SCAN -X
                ',(#2)
ERROR7B  #ERR  'Argument 7 to STRING-SCAN contains an element longer thX
               an 256 characters - ',(#2)
ERRORG   #ERR  PREFIX=NO,          NOT ENUF ROOM                       X
               'ZIL4010 STRING-SCAN: Not enough vector/string space to X
               build string.'
         SPACE 1
SINGTAB  DC    256D'0'             Single-character string table
         END
