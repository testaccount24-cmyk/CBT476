         TITLE 'ZILDIV - BUILT-IN ZIL 1.3 SUBROUTINE'
***********************************************************************
*                                                                     *
* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *
*                     All rights reserved.                            *
*                                                                     *
***********************************************************************
*      ZILDIV takes two arguments. Both must be numeric atoms         *
*                                                                     *
* Conversion rules are as follows:                                    *
*                                                                     *
* 1. Both args fixed         - perform integer division.              *
* 2. Both args float         - perform real division                  *
* 3. Bne fixed, one float    - convert the fixed argument to          *
*                              float and perform real division.       *
*                                                                     *
* Division by 0 causes an error.                                      *
*                                                                     *
* Extended precision divide not used for bignum operations because    *
* it is very slow on the 3090 hardware.                               *
*                                                                     *
*                                                                     *
* Future improvements:                                                *
*                                                                     *
* ===> Optimization for lower zero bigits in the divisor.             *
*                                                                     *
* ===> Optimization with fast check on remainder (see Knuth).         *
*      Actually, since addition is much faster than multiplication    *
*      on typical hardware, the fast check is probably slower than    *
*      a full "quotient-bigit x divisor" correction which can be      *
*      done by addition or subtraction when the quotient-bigit        *
*      correction is an increment or decrement of 1.  Thus the        *
*      fast check is probably only faster for bignums of length       *
*      10 bigits and more.                                            *
*                                                                     *
* ===> Eliminate the paths that check the remainder to see if it's    *
*      larger than the divisor so that the quotient must be           *
*      incremented.  It will never need to be incremented, as proven  *
*      in Knuth.  You will also understand it intuivitely if you try  *
*      to construct a counterexample.                                 *
***********************************************************************
         SPACE 1
ZILDIV   #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILDIV'
         #ZPDS 20                  DEFINE STACK SIZE
         #ZSAV ,                   SAVE REGISTERS
         SPACE
         LM    #6,#7,0(#11)        LOAD ARGUMENTS
         CLI   ##TYPE(#6),##FIXNUM IS ARG 1 A FIXNUM?
         BNE   NFX1                BRANCH IF NOT A FIXNUM
         CLI   ##TYPE(#7),##FIXNUM IS ARG 2 A FIXNUM?
         BNE   FX1NFX2             BRANCH IF 1 IS FIXNUM AND 2 NOT
*=====================================================================*
*            FIXNUM BY FIXNUM DIVIDE                                  *
*=====================================================================*
         ICM   #1,15,##CDR(#7)     CHECK ARGUMENT 2
         L     #2,##CDR(,#6)       GET ARG1
         BZ    FFDIVBY0            IF ZERO, ERROR
         LCR   #3,#2               TEST COMPLEMENT OF NUMBER
         BO    FFTM31              RESULT WILL BE BIG IF DIVISOR -1
FFTM31NO SRDA  #2,32               SHIFT INTO REGISTERS FOR DIVIDE
         DR    #2,#1               DIVIDE THEM
         LR    #2,#3               GET QUOTIENT INTO REGISTER
         #MKAT FIXED               MAKE A FIXNUM
******** B     RETURN
RETURN   DS    0H                  RETURN WITH NEW ATOM
         SPACE
         #ZRET ,                   RESTORE REGISTERS AND RETURN
*
FFTM31   CH    #1,=H'-1'           WE MUST CHECK FOR -2¬31/-1
         BNE   FFTM31NO            IT'S NOT, CONTINUE WITH FIXNUM WORK
         LA    #15,TWO31           IT IS -2¬31/-1, RETURN 2¬31 BIGNUM
         B     RETURN
*
FX1NFX2  DS    0H
*---------------------------------------------------------------------*
*            ARG 1 IS A FIXNUM, ARG 2 IS NOT A FIXNUM                 *
*---------------------------------------------------------------------*
         CLI   ##TYPE(#7),##BIGNUM IS ARG 2 A BIGNUM?
         BNE   FX1NBF2             IF NOT, BRANCH TO FLONUM CHECK
*=====================================================================*
*            FIXNUM BY BIGNUM DIVIDE                                  *
*=====================================================================*
         L     #1,##CDR(,#6)       GET ARG 1
         LCR   #1,#1               CHECK FOR -2**31
         BO    FT31MB              LOOK AT BIGNUM TOO
         LA    #15,#SFT0           FIX/BIG MUST BE 0
         B     RETURN
*
FT31MB   CLC   TWO31,0(#7)         IS BIGNUM DIVIDEND = 2¬31 /
         BE    M1                  YES, BRANCH TO MAKE -1
         LA    #15,#SFT0           ELSE QUOTIENT IS 0
         B     RETURN
*
M1       LA    #15,#SFTM1          RESULT IS -1
         B     RETURN
*
NFX1     DS    0H
*---------------------------------------------------------------------*
*            ARG 1 IS NOT A FIXNUM                                    *
*---------------------------------------------------------------------*
         CLI   ##TYPE(#6),##BIGNUM WELL, IS IT A BIGNUM?
         BNE   NBFX1               IT'S NEITHER FIXED NOR BIG
*---------------------------------------------------------------------*
*            ARG 1 IS A BIGNUM                                        *
*---------------------------------------------------------------------*
         CLI   ##TYPE(#7),##BIGNUM
         BE    BIGBIG              WE HAVE BIGNUM BY BIGNUM
         CLI   ##TYPE(#7),##FIXNUM
         BNE   BG1NBF2             ARG 2 NEITHER FIXNUM NOR BIGNUM
*=====================================================================*
*            BIGNUM BY FIXNUM DIVIDE                                  *
*=====================================================================*
         L     #7,##CDR(#7)        LOAD FIXNUM
         XR    #2,#2               CLEAR FOR ICM OF LENGTH
         CH    #7,=H'1'            DIVIDING BY 1?
         BE    RETURN6             THEN RETURN POINTER TO DIVIDEND
         CH    #7,=H'-1'           DIVIDING BY -1?
         BE    BFM1                YES, THEN CHECK SPECIAL CASE
         ST    #7,FDIVISOR         STORE DIVISOR WITH ORIGINAL SIGN
         LPR   #7,#7               TAKE POSITIVE VALUE FOR DIVISOR
         LA    #3,4                MULTIPURPOSE CONSTANT 4
         BZ    BFDIVBY0            ATTEMPTED TO DIVIDE BIGNUM BY 0
         BO    BFMT31              DIVISOR IS MOST NEGATIVE FIXNUM
         ICM   #2,7,1(#6)          GET BIGNUM LENGTH
         L     #15,ZLCBIG          GET ADDRESS OF ZILBIG
         AR    #2,#3               ASK FOR BIGNUM LENGTH + ##VECDAT
         #BASR #14,#15             CALL ZILBIG
         L     #6,0(#11)           GC MAY HAVE MOVED BIGNUM POINTER
         LR    #1,#2               SAVE BIGNUM LENGTH + 1 WORD
         LCR   #3,#3               GENERATE MULTIPURPOSE -4
         AR    #1,#3               #1 = LENGTH
         L     #4,##VECDAT-4(#1,#6) LOAD MS WORD OF BIGNUM
         SRDL  #4,32               SHIFT RIGHT AND CLEAR
         DR    #4,#7               DO FIRST DIVIDE INTO HI WORD
         LTR   #5,#5               IS FIRST QUOTIENT 0?
         BZ    BF1LESS             RESULT IS ONE WORD SHORTER
         ST    #5,##VECDAT-4(#1,#15) STORE MS WORD OF QUOTIENT
         STCM  #1,7,1(#15)         SET LENGTH IN RESULT HEADER
         AR    #1,#3               #1 = LENGTH - 1 WORD
         AR    #1,#3               #1 = LENGTH - 2 WORDS
BFLOOP   L     #5,##VECDAT(#1,#6)  LOAD NEXT WORD OF DIVIDEND
         SLL   #5,1                SQUEEZE OUT (SIGN) JUNK BIT
         SRDL  #4,1                RIGHT JUSTIFY 64-BIT DIVIDEND
         DR    #4,#7               DIVIDE FOR THIS SIGNIFICANCE
         ST    #5,##VECDAT(#1,#15) STORE THIS INTO RESULT BIGNUM
         BXH   #1,#3,BFLOOP        ANY MORE DIVIDEND WORDS LEFT?
         AR    #2,#15              POINT TO END OF BIGNUM
         L     #7,FDIVISOR         get divisor with sign
         X     #7,##VECDAT(,#6)    combine with sign of dividend
         N     #7,=X'80000000'     retain only the sign
         O     #7,##VECDAT(,#15)   combine with least word of bignum
         ST    #7,##VECDAT(,#15)   store sign and least bignum word
         CLC   TWO31MX,0(#15)      check for illegal bignum -2¬31
         BE    RETT31M             if it's there, issue -2¬31 fixnum
         ST    #2,ZLCVSNXT         UPDATE VSS AVAILABILITY POINTER
         B     RETURN
*
BFM1     CLC   TWO31,0(#6)         IS SITUATION 2¬31/(-1)=-2¬31?
         BE    RETT31M             YES, THEN RETURN MOST NEG FIXNUM
         ICM   #2,7,1(#6)          OTHERWISE IT'S BIGNUM, GET LEN
         L     #15,ZLCBIG          GET ADDRESS OF SPACE SERVICE ROUTINE
         LA    #2,##VECDAT(,#2)    MUST ASK FOR HEADER SPACE TOO
         #BASR #14,#15             ALLOCATE THE RESULT BIGNUM SPACE
         L     #6,0(#11)           RELOAD POINTER (IN CASE OF GC)
         LR    #7,#2               LENGTH OF SOURCE FOR MVCL
         LR    #4,#15              DESTINATION START FOR MVCL
         LR    #5,#2               LENGTH OF DESTINATION FOR MVCL
         MVCL  #4,#6               MOVE THE BIGNUM
         XI    ##VECDAT(#15),X'80' FLIP THE SIGN IN THE RESULT
         ST    #4,ZLCVSNXT
         B     RETURN
*
BFMT31   CLC   0(4,#6),BIG8        CHECK IF RESULT WILL BE FIXNUM
         BE    BFMT31F             RESULT MUST BE A FIXNUM
         L     #15,ZLCBIG          GET ADDRESS OF ZILBIG
         ICM   #2,7,1(#6)          GET BIGNUM LENGTH
         #BASR #14,#15             CALL ZILBIG
         L     #6,0(#11)           GC MAY HAVE MOVED BIGNUM POINTER
         LA    #0,##VECDAT+4(,#6)  STARTING POINT FOR MVCL COPY
         LR    #1,#2               put source length into reg 1
         SLR   #1,#3               subtract 1 word from source length
         LA    #4,##VECDAT(,#15)   DESTINATION FOR MVCL
         STCM  #1,7,1(#15)         SET LENGTH IN RESULT HEADER
         LR    #5,#1               COPY LENGTH
         MVCL  #4,#0               COPY TO ANSWER
         TM    ##VECDAT(#6),X'80'  TEST DIVIDEND FOR MINUS SIGN
         BZ    BMFP                MAKE THE RESULT BIGNUM NEGATIVE
         ST    #4,ZLCVSNXT         UPDATE VSS AVAILABILITY POINTER
         B     RETURN
*
RETT31M  LA    #15,TWO31M          ANSWER MUST BE -2¬31, A FIXNUM
         B     RETURN
*
BFMT31F  L     #2,##VECDAT+4(,#6)  GET UPPER WORD WHICH WILL BE ANSWER
         TM    ##VECDAT(#6),X'80'  TEST DIVISOR FOR MINUS SIGN
         BO    NOCOMPL             DON'T NEED TO COMPLEMENT FIXNUM
         LCR   #2,#2               NEED TO COMPLEMENT FIXNUM
NOCOMPL  #MKAT FIXED               CONS UP A FIXNUM FOR ANSWER
         B     RETURN
*
BMFP     OI    ##VECDAT(#15),X'80' PUT MINUS SIGN INTO ANSWER
         CLC   TWO31MX,0(#15)      check for illegal bignum -2¬31
         BE    RETT31M             if it's there, issue -2¬31 fixnum
         ST    #4,ZLCVSNXT         UPDATE VSS AVAILABILITY POINTER
         B     RETURN
*
RETURN6  LR    #15,#6              RETURN DIVIDEND AS RESULT
         B     RETURN
*
BF1LESS  AR    #1,#3               #1 = LENGTH - 1 WORD
         STCM  #1,7,1(#15)         SET LENGTH IN HEADER OF RESULT
         AR    #1,#3               #1 = LENGTH - 2 WORDS
         BNZ   BFLOOP              is result not going to be fixnum?
         L     #7,FDIVISOR         PICK UP DIVISOR WITH SIGN
         ICM   #5,15,##VECDAT(#6)  GET LS WORD OF ARG1, TEST SIGN
         BNM   BF1LFXNM            RESULT WILL NOT BE MINUS FIXNUM
         LCR   #7,#7               THIS WILL ENSURE THAT SIGN COMES OUT
BF1LFXNM SLL   #5,1                SQUEEZE OUT SIGN BIT
         SRDL  #4,1                RIGHT JUSTIFY 64-BIT DIVIDEND
         DR    #4,#7               DIVIDE TO GET FIXNUM RESULT
         LR    #2,#5               POSITION QUOTIENT FOR FIXNUM CONS
         #MKAT FIXED               MAKE A FIXNUM
         B     RETURN
*=====================================================================*
*            BIGNUM BY BIGNUM DIVIDE                                  *
*=====================================================================*
BIGBIG   CLC   1(3,#6),1(#7)       COMPARE LENGTHS IN BIGNUM HEADERS
         BH    B1B2                QUOTIENT COULD BE EITHER FIX OR BIG
         BL    RETURN0             LENGTH OF ARG1 IS SMALLER, RETURN 0
         XR    #5,#5               CLEAR FOR INSERTION OF 3-BYTE LENGTH
         ICM   #5,7,1(#6)          GET BIGNUM LENGTHS - BOTH SAME NOW
         L     #0,##VECDAT-4(#5,#7) LOAD MS WORD OF ARG2 BIGNUM
         CL    #0,##VECDAT-4(#5,#6) COMPARE WITH MS WORD OF ARG1 BIGNUM
         BH    RETURN0             ARG1 MAGNITUDE SMALLER, RETURN 0
         BE    MSE                 MOST SIGNIFICANT WORDS ARE EQUAL
*---------------------------------------------------------------------*
*    MS WORD OF DIVIDEND IS LARGER, SAME LENGTH, ONLY 1 TRIAL DIVIDE  *
*    NEEDED BECAUSE RESULT WILL BE A FIXNUM                           *
*---------------------------------------------------------------------*
         SH    #5,=H'8'            FINDING OUT MORE ABOUT THE LENGTH
         BZ    MSH2                it must be 2 2-word bignums
         #BAS  #14,LJSHIFT         get negative of left justify amount
*
         L     #0,##VECDAT+4(#5,#7) GET MS WORD OF DIVISOR
         L     #1,##VECDAT(#5,#7)  GET NEXT MS WORD OF DIVISOR
         SLL   #1,1                SQUEEZE OUT JUNK BIT
         SRDL  #0,32(#4)           LEFT JUSTIFY 31 DIVISOR BITS IN #1
*
         L     #2,##VECDAT+4(#5,#6) GET MS WORD OF DIVIDEND
         L     #3,##VECDAT(#5,#6)  GET NEXT WORD OF DIVIDEND
         SLL   #3,1                SQUEEZE OUT JUNK BIT
         SRDL  #2,32(#4)           ALIGN DIVIDEND WITH DIVISOR IN #1
*
         DR    #2,#1               TRIAL DIVISION
*---------------------------------------------------------------------*
* Compute required size of work area.  Then if more space is needed,  *
* ask for about 1024 bytes more.  This will insure that many requests *
* for progressively slightly larger spaces will not often require     *
* a new FREEMAIN-GETMAIN combination.                                 *
*                                                                     *
* The workarea is here only needed for the remainder.  Since only     *
* one quotient bigit is used, only one remainder is computed, and     *
* is only needed for comparison with the divisor.  This workarea      *
* is actually not needed if we depend on Knuth's observation the      *
* quotient bigit will never be estimated too low.  If it is too high  *
* there will always be a borrow left over when computing the          *
* remainder, which tells us it's too high.                            *
*---------------------------------------------------------------------*
         LA    #14,16(,#5)         Required size of work area
         C     #14,ZLCWALEN        If current workarea is big enough
         BNH   WAOK1               then go use it
         L     #1,ZLCWA            Else get address of current workarea
         L     #0,ZLCWALEN         Get current workarea size
         FREEMAIN R,LV=(0),A=(1)   Free the old workarea
         LA    #14,1023(,#14)      Round up and ask for extra
         N     #14,=X'FFFFFFF8'     to next multiple of 8
         LR    #0,#14              Get that length ready for GETMAIN
         #GETMAIN RC,LV=(0),LOC=BELOW Get a new work area
         LTR   #15,#15             If getmain failed
         BNZ   GERROR              then error - not enough storage
         ST    #1,ZLCWA            Else store new work area address
         ST    #14,ZLCWALEN        and store new work area length
WAOK1    DS    0H                  Big enough workarea now available
         L     #14,ZLCWA           Get address of workarea
*
         STM   #8,#11,ZLCISAVE     NEED MORE REGISTERS (NOT #12,#13)
         OI    ZLCIFLGS,ZLCISVD    INDICATE THERE ARE REGISTERS SAVED
*
         EJECT
*---------------------------------------------------------------------*
*    MS WORD OF DIVIDEND IS LARGER, SAME LENGTH, ONLY 1 TRIAL DIVIDE  *
*    NEEDED BECAUSE RESULT WILL BE A FIXNUM                           *
*                                                                     *
*                                                    quotient         *
*                                                    +------+         *
*                                                    |  #3  |         *
*                                                    +------+         *
*                    divisor         +-----------------------         *
*             +------+------+s-----+ | +------+------+s-----+         *
*             |      |      |#1    | | |      |      |#8    | dividend*
*             +------+------+------+ | +------+------+------+         *
*                               +------+------+------+                *
*                             + |      |      |    #8|        carry   *
*                               +------+------+------+                *
*                               +------+------+------+                *
*                             - |      |      |  #0  |        mult hi *
*                               +------+------+------+                *
*                                      +------+------+------+         *
*                                    - |      |      |  #1  | mult lo *
*                                      +------+------+------+         *
*                              -------------------------------        *
*                                      +------+------+------+         *
*                                      |      |      |  #8  | remaindr*
*                                      +------+------+------+         *
*                                                                     *
* Inclusive range of possible results are indicated for operations    *
* where it is important to track the possibility of overflow.         *
* For example, a result can be known to be limited to a certain       *
* range between A and B inclusive, would be indicated by {A,B}        *
* in the comment field.  {0,2¬31-1}, for example, is the full         *
* range of positive, 32-bit signed integers in two's complement       *
* notation.                                                           *
*---------------------------------------------------------------------*
MSHCHK   L     #1,##VECDAT(,#7)    load divisor least-significant word
         N     #1,=X'7FFFFFFF'     {0,2¬31-1} mask out the sign bit
         MR    #0,#3               multiply quotient and divisor word
         SLDL  #0,1                {0,2¬31-2} shift for 31-bit radix
         SRL   #1,1                {0,2¬31-1} restore lower word
         L     #8,##VECDAT(,#6)    load dividend word
         N     #8,=X'7FFFFFFF'     {0,2¬31-1} mask out the sign bit
         SR    #8,#1               {-(2¬31-1),2¬31-1} subtract mult hi
         SRDA  #8,31               {-1,0} shift out all but carry
         SRL   #9,1                {0,2¬31-1} right-justify the 31 bits
         ST    #9,##VECDAT(,#14)   store remainder in word in work area
         EJECT
*---------------------------------------------------------------------*
* When we enter here, reg 0 contains the hi word from the previous    *
* multiplication, and reg 8 holds the carry from the previous         *
* remainder word computation.                                         *
*                                                    quotient         *
*                                                    +------+         *
*                                                    |  #3  |         *
*                                                    +------+         *
*                    divisor         +-----------------------         *
*             +------+------+s-----+ | +------+------+s-----+ (#2,#6) *
*    (#2,#7)  |      |#1    |      | | |      |      |      | dividend*
*             +------+------+------+ | +------+------+------+         *
*                               +------+------+------+                *
*                             + |      |    #8|#8    |        carry   *
*                               +------+------+------+                *
*                               +------+------+------+                *
*                             - |      |  #0  |#0    |        mult hi *
* BXLE registers:               +------+------+------+                *
*   #4 = increment                     +------+------+------+         *
*   #5 = length - 8                  - |      |  #1  |      | mult lo *
*                                      +------+------+------+         *
*                              -------------------------------        *
*                                      +------+------+------+         *
*                             (#2,#14) |      |  #8#9| done | remaindr*
*                                      +------+------+------+         *
*                                                                     *
*---------------------------------------------------------------------*
         XR    #2,#2               INITIALIZE INDUCTION BXLE COUNTER
         LA    #4,4                INCREMENT AMOUNT OF BXLE LOOP
MSHLOOPM L     #1,##VECDAT+4(#2,#7) load divisor word
         SLR   #8,#0               {-(2¬31-1),0} sub hi-mul from carry
         MR    #0,#3               multiply quotient and divisor words
         SLDL  #0,1                {0,2¬31-2} shift for 31-bit radix
         SRL   #1,1                {0,2¬31-1} restore lower word
         A     #8,##VECDAT+4(#2,#6) {-(2¬31-1),2¬31-1} add dividend wrd
         SR    #8,#1               {-(2¬32-2),2¬31-1} sub lo-mul
         BO    MSHMC               double carry if overflow
         SRDA  #8,31               {-1,0} shift all but carry amount
         SRL   #9,1                {0,2¬31-1} right-justify the 31 bits
         ST    #9,##VECDAT+4(#2,#14) store remainder word in work area
         BXLE  #2,#4,MSHLOOPM      iterate to next word?
*---------------------------------------------------------------------*
* Compare remainder to divisor.  Remainder should be positive but     *
* less than the divisor.  If it's negative, we decrement the quotient.*
* If it's positive, we increment the quotient.                        *
*---------------------------------------------------------------------*
         CR    #8,#0               carry off the end?
         BNE   MSHDQ               if not, then quotient is too high
*---------------------------------------------------------------------*
* The comparison with the divisor below can theoretically be          *
* eliminated, since the quotient bigit can never bee too low (see     *
* Knuth, Vol 2).  However, we keep it in here a little longer to      *
* catch any bugs in the code that leads to this point.  At the same   *
* time, this provides a more reliable divide since it has such a      *
* self check.                                                         *
*                                                                     *
* That is, all paths below which never lead to an MSHDQ can simply    *
* be replaced by a direct branch to MSHOK.                            *
*---------------------------------------------------------------------*
         C     #9,##VECDAT(#2,#7)  is highest word of remainder to big?
         BH    MSHIQ               if so, inc quotient & check it again
         LCR   #1,#4               generate a -4 for the BXH
         LR    #2,#5               initialize the count to the top
MSHCMPR  L     #9,##VECDAT+4(#2,#14) get remainder word
         C     #9,##VECDAT+4(#2,#7) compare with dividend word
         BH    MSHIQ               remainder to high, inc. quotient
         BL    MSHOK               remainder is lower than divisor, ok
         BXH   #2,#1,MSHCMPR       not reached next to last word?
*
         L     #9,##VECDAT(,#7)    least significant word of divisor
         N     #9,=X'7FFFFFFF'     mask out the sign bit
         C     #9,##VECDAT(,#14)   compare these words
         BH    MSHOK               divisor is bigger than remainder, ok
*
***MSHIQ AH    #3,=H'1'            increment the quotient
***      BP    MSHCHK              check the incremented quotient
MSHIQ    B     BUG3                MSHIQ should never happen, see Knuth
*
*                                  really part of MSHLOOPM above
MSHMC    SRDA  #8,31               {-1,0} shift all but carry amount
         BM    BUG5             DIVSRDA,BM,SRL,SH>LR #9,#8;LH #8,=H'-2'
         SRL   #9,1                {0,2¬31-1} right-justify the 31 bits
         SH    #8,=H'2'            subtract the double carry
         ST    #9,##VECDAT+4(#2,#14) store remainder word in work area
         BXLE  #2,#4,MSHLOOPM      iterate to next word?
*
MSHDQ    BCT   #3,MSHCHK           decrement quotient and check it
         B     BUG4                can't happen! quotient always > 0
*
MSHOK    LM    #8,#11,ZLCISAVE     RESTORE THE SAVED REGISTERS
         NI    ZLCIFLGS,255-ZLCISVD  INDICATE THAT REGISTERS RESTORED
         LR    #2,#3               get result into register for #MKAT
         TM    ##VECDAT(#6),X'80'  test sign of dividend
         BNO   *+6
         LCR   #2,#2               incorporate sign into answer
         TM    ##VECDAT(#7),X'80'  test sign of divisor
         BNO   *+6
         LCR   #2,#2               incorporate sign into answer
         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS
         #MKAT FIXED               create the fixnum answer
         B     RETURN
*---------------------------------------------------------------------*
*    MS WORD OF DIVIDEND AND DIVISOR ARE THE SAME, ANSWER WILL BE     *
*    -1, 0, OR 1.  TRIAL DIVISION NOT NECESSARY                       *
*---------------------------------------------------------------------*
MSE      SH    #5,=H'12'           SETUP COUNT FOR BXH
         BM    MSE2                2-WORD/2-WORD DIVIDE
         LH    #3,=H'-4'           DECREMENT COUNT FOR BXH
MSEBXH   L     #0,##VECDAT+4(#5,#6) GET WORD OF DIVIDEND FOR COMPARE
         CL    #0,##VECDAT+4(#5,#7) COMPARE WITH SAME WORD IN DIVISOR
         BNE   MSEBXHNE            STOP LOOP IF PAIR IS NOT EQUAL
         BXH   #5,#3,MSEBXH        CHECK NEXT PAIR OF WORDS?
*
MSE2     L     #0,##VECDAT(,#6)    DOWN TO LAST PAIR OF WORDS
         L     #1,##VECDAT(,#7)    GET THE DIVISOR LS WORD
         LR    #2,#0               SAVE FOR COMPUTATION OF SIGN
         XR    #2,#1               COMPUTE SIGN OF RESULT
         SLL   #0,1                SHIFT OUT THE SIGN BIT
         SLL   #1,1                SHIFT OUT THE SIGN BIT
         CLR   #0,#1               COMPARE THE TWO LS WORDS
         BL    RETURN0             DIVIDEND IS LESS, RETURN 0
         LTR   #2,#2               TEST SIGN OF RESULT
         BM    MSEFM1              RESULT IS -1 /
         LA    #15,#SFT1           RESULT IS 1
         B     RETURN
MSEFM1   LA    #15,#SFTM1          RESULT IS -1
         B     RETURN
*
MSEBXHNE BL    RETURN0             NUMERATOR SMALLER, RETURN 0
         L     #0,##VECDAT(,#6)    GET SIGN OF DIVIDEND
         X     #0,##VECDAT(,#7)    COMBINE WITH SIGN OF DIVISOR
         LTR   #0,#0               TEST SIGN OF RESULT
         BM    MSEFM1              RESULT IS -1
         LA    #15,#SFT1           RESULT IS 1
         B     RETURN
         SPACE
RETURN0  LA    #15,#SFT0           RETURN POINTER TO 0
         B     RETURN
         SPACE
*---------------------------------------------------------------------*
*    We know the answer will be a fixnum when we get here, because    *
*    the bignums are of the same length in terms of 31-bit "bigits".  *
*---------------------------------------------------------------------*
MSH2     #BAS  #14,LJSHIFT         GET NEGATIVE OF LEFT JUSTIFY AMOUNT
*
         L     #0,##VECDAT+4(,#7)  GET MS WORD OF DIVISOR
         L     #1,##VECDAT(,#7)    GET LS WORD OF DIVISOR
         SLL   #1,1                SQUEEZE OUT SIGN BIT
         SRDL  #0,32(#4)           LEFT JUSTIFY 31 DIVISOR BITS IN #1
*
         L     #2,##VECDAT+4(,#6)  GET MS WORD OF DIVIDEND
         L     #3,##VECDAT(,#6)    GET LS WORD OF DIVIDEND
         SLL   #3,1                SQUEEZE OUT SIGN BIT
         SRDL  #2,32(#4)           ALIGN DIVIDEND WITH DIVISOR IN #1
*
         DR    #2,#1               TRIAL DIVISION
*
MSH2CHK  L     #5,##VECDAT(,#7)    GENERATE TRIAL QUOTIENT * DIVISOR
         N     #5,=X'7FFFFFFF'     MASK OUT THE SIGN BIT
         MR    #4,#3               QUOTIENT * LS WORD OF DIVISOR
         L     #1,##VECDAT+4(,#7)  GET MS WORD OF DIVISOR
         MR    #0,#3               QUOTIENT * MS WORD OF DIVISOR
         SLDL  #4,1                MOVE OVER 1 BIT FOR 31-BIT RADIX
         SLDL  #0,1                MOVE OVER 1 BIT FOR 31-BIT RADIX
         SRL   #5,1                RESTORE POSITION OF LS WORD
         SRL   #1,1                RESOTRE POSITION OF LS WORD
*                                  SUBTRACT FROM DIVISOR
         LTR   #0,#0               TEST MS WORD OF HIGHER PRODUCT
         BNZ   MSH2DQ              GO AND DECREMENT QUOTIENT IF NOT 0
         LR    #2,#1
         L     #1,##VECDAT(,#6)    GET LS WORD OF DIVIDEND
         N     #1,=X'7FFFFFFF'     MASK OUT SIGN BIT
         SR    #1,#5               COMPUTE LS WORD OF REMAINDER
         XR    #0,#0               CLEAR REG
         SLDL  #0,1                SLIP IN THE SUBTRACT CARRY BIT
         SRL   #1,1                RESTORE LS WORD OF REM IN 31 RADIX
         L     #14,##VECDAT+4(,#6) GET MS WORD OF DIVIDEND
         SR    #14,#0              SUBTRACT THE CARRY BIT
         SR    #14,#4              SUBTRACT MS WORD OF LOWER PRODUCT
         BM    MSH2DQ              SUBTRACTING TOO MUCH, DECREMENT QUO
         SR    #14,#2              SUBTRACT LS WORD OF HIGHER PRODUCT
         BM    MSH2DQ              SUBTRACTING TOO MUCH, DECREMENT QUO
*
         CL    #14,##VECDAT+4(,#7) COMPARE REMAINDER AND DIVISOR MS WRD
         BH    MSH2IQ              REMAINDER TOO BIG, INCREMENT QUO
         BL    RETURNR3            QUOTIENT IS GOOD, IT'S IN REGISTER 3
         L     #5,##VECDAT(,#7)    GET LS WORD OF DIVISOR
         N     #5,=X'7FFFFFFF'     MASK OUT THE SIGN BIT
         CLR   #1,#5               COMPARE REMAINDER AND DIVISOR LS WRD
         BNL   MSH2IQ       DIV    REMAINDER TOO BIG, INCREMENT QUO
*
RETURNR3 LR    #2,#3               SETUP FOR REAL RETURN
         TM    ##VECDAT(#6),X'80'  test sign of dividend
         BNO   *+6
         LCR   #2,#2               incorporate sign into answer
         TM    ##VECDAT(#7),X'80'  test sign of divisor
         BNO   *+6
         LCR   #2,#2               incorporate sign into answer
         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS
         #MKAT FIXED               create the fixnum answer
         B     RETURN
*
MSH2DQ   BCT   #3,MSH2CHK
         B     BUG1                #3 should never decrement to 0
*
**MSH2IQ AH    #3,=H'1'            increment the quotient
**       BP    MSH2CHK
MSH2IQ   B     BUG2                MSH2IQ will never happen, see Knuth
*=====================================================================*
*  General bignum by bignum divide.  Here we know the indicated       *
*  length of the dividend is one word longer than the divisor.        *
*  So the magnitude of the answer must be 1 or greater.               *
*=====================================================================*
B1B2     XR    #3,#3               clear registers for next operations
         XR    #5,#5               "
         ICM   #3,B'0111',1(#6)    get length of dividend bignum
         ICM   #5,B'0111',1(#7)    get length of divisor bignum
         LA    #2,8(,#3)           result may be 8 greater than diff
         L     #15,ZLCBIG          get address ZILBIG
         SLR   #2,#5               subtract the two bignum lengths (+8)
         #BASR #14,#15             get space for possible bignum
         LM    #6,#7,0(#11)        reload args - moved if there was GC
*---------------------------------------------------------------------*
* Compute required size of work area.  Then if more space is needed,  *
* ask for about 1024 bytes more.  This will insure that many requests *
* for progressively slightly larger spaces will not often require     *
* a new FREEMAIN-GETMAIN combination.                                 *
*                                                                     *
* The workarea is here needed for both the remainder at each quotient *
* bigit but also for the continually updated full remainder, which    *
* is the new dividend for each new quotient bigit calculation.        *
*---------------------------------------------------------------------*
         LA    #14,16(#3,#5)       Required size of work area
         C     #14,ZLCWALEN        If current workarea is big enough
         BNH   WAOK2               then go use it
         STM   #15,#0,SAVE1500     Else save regs that'll get clobbered
         L     #1,ZLCWA            Else get address of current workarea
         L     #0,ZLCWALEN         Get current workarea size
         FREEMAIN R,LV=(0),A=(1)   Free the old workarea
         LA    #14,1023(,#14)      Round up and get extra to stop trash
         N     #14,=X'FFFFFFF8'     to next multiple of 8
         LR    #0,#14              Get that length ready for GETMAIN
         #GETMAIN RC,LV=(0),LOC=BELOW Get a new work area
         LTR   #15,#15             If getmain failed
         BNZ   GERROR              then error - not enough storage
         ST    #1,ZLCWA            Else store new work area address
         ST    #14,ZLCWALEN        and store new work area length
         LM    #15,#0,SAVE1500     Restore regs that got clobbered
WAOK2    DS    0H                  Big enough workarea now available
         L     #14,ZLCWA           Address of workarea - divident pntr
*
         STM   #8,#11,ZLCISAVE     NEED MORE REGISTERS (NOT #12,#13)
         OI    ZLCIFLGS,ZLCISVD    INDICATE THERE ARE REGISTERS SAVED
*
         LR    #11,#3              we need reg 3 for other purposes
*
         LA    #0,##VECDAT(,#6)    source starting point of dividend
         LR    #1,#3               length to copy from source
         LA    #2,##VECDAT(,#14)   destination
         LA    #3,4(,#3)           pad an extra word=0 at end
         MVCL  #2,#0               make a copy of the dividend
         NI    ##VECDAT(#14),X'7F' mask sign in work area dividend
*
         SH    #11,=H'8'           dividend offset the length by 8
         ST    #2,REMPTR           REMAINDER work area (left by MVCL)
         LR    #10,#11             get set to compute dividend offset
         SH    #5,=H'8'            divisor offset the length by 8
         SLR   #10,#5              dividend offset
         ST    #10,BIGLDIFF        save the length difference for later
*
         L     #0,##VECDAT+4(#5,#7) DIVcheck that reg 0 clobber OK
         #BAS  #14,LJSHIFT         call bit-justification routine
         ST    #4,RSHIFT           store the shift amount (negative)
*
         L     #0,##VECDAT+4(#5,#7) highest word of divisor
         L     #1,##VECDAT(#5,#7)  next most highest word
         SLL   #1,1                sqeeze out junk bit
         SRDL  #0,32(#4)           justify all 64 bits
         ST    #1,FDIVISOR
*
         L     #6,ZLCWA            load dividend pointer
         L     #2,##VECDAT+4(#11,#6) highest word of dividend
         L     #3,##VECDAT(#11,#6) next most highest word
         SLL   #3,1                squeeze out junk bit
         SRDL  #2,32(#4)           do shift amount
*
         DR    #2,#1               divide to get best guess
*
         LA    #6,0(#10,#6)        offset to fake dividend
         L     #14,REMPTR          load pointer to remainder
         B     BBCHK               check the quotient bigit
*---------------------------------------------------------------------*
* Start processing for next bigit.                                    *
*---------------------------------------------------------------------*
QBIGIT   L     #6,ZLCWA            load dividend pointer
         L     #4,RSHIFT           recall shift amount
         LA    #6,0(#10,#6)        offset to fake dividend
*
         L     #0,##VECDAT+8(#5,#6) highest word of dividend
         L     #2,##VECDAT+4(#5,#6) next word of dividend
         L     #3,##VECDAT(#5,#6)  next word of dividend
         LR    #1,#2               to avoid another memory load
         SLL   #3,1                squeeze out junk bit
         SLL   #1,1                squeeze out junk bit
         SRDL  #2,31(#4)           do shift amount
         SRDL  #0,32(#4)           do shift amount
         LR    #2,#1               put together the two parts
         CL    #1,FDIVISOR         is division going to overflow?
         BL    QDIV                no, go ahead and divide
         L     #3,=X'7FFFFFFF'     overflow, ok, just put in max
         B     BBCHK               then check this as if we divided
*
QDIV     SRDL  #2,1                final shift
         D     #2,FDIVISOR         divide to get best guess
         EJECT
*---------------------------------------------------------------------*
* Register usage:                                                     *
*                                                                     *
*   #0 = stack pointer and misc                                       *
*   #1 = misc                                                         *
*   #2 = misc                                                         *
*   #3 = quotient bigit                                               *
*   #4 = 4                                                            *
*   #5 = L2 (Length of B2 - the divisor)                              *
*   #6 = (fake B1) - full remainder (dividend for next bigit)         *
*   #7 = (B2)                                                         *
*   #8 = misc                                                         *
*   #9 = misc                                                         *
*  #10 = offset in dividend = (L1 - L2) or less                       *
*  #11 = L1 (length of B1 - the dividend)                             *
*  #12 = --base register for this module--                            *
*  #13 = --common area pointer--                                      *
*  #14 = temporary remainder (remainder by from bigit times divisor)  *
*  #15 = pointer to result vector                                     *
*                                                                     *
*  The temporary registers are used as follows in the first part      *
*  of the code below.                                                 *
*                                                    quotient         *
*                                             +------+                *
*                                             |    #3|                *
*                                             +------+                *
*                    divisor         +-----------------------         *
*                    +------+s-----+ | +------+------+------+ (#2,#6) *
*   (#2,#7)          |      |#1    | | |      |#8    |      | dividend*
*                    +------+------+ | +------+------+------+         *
*                               +------+------+                       *
*                             + |      |    #8|               carry   *
*                               +------+------+                       *
*                               +------+------+                       *
* BXLE registers:             - |      |  #0  |               mult hi *
*   #4 = increment              +------+------+                       *
*   #5 = length - 8                    +------+------+                *
*                                    - |      |  #1  |        mult lo *
*                                      +------+------+                *
*                              -------------------------------        *
*                                      +------+------+                *
*            (#2,#14)    new dividend  |      |  #8  |        remaindr*
*                                      +------+------+                *
*                                                                     *
* Inclusive range of possible results are indicated for operations    *
* where it is important to track the possibility of overflow.         *
* For example, a result can be known to be limited to a certain       *
* range between A and B inclusive, would be indicated by {A,B}        *
* in the comment field.  {0,2¬31-1}, for example, is the full         *
* range of positive, 32-bit signed integers in two's complement       *
* notation.                                                           *
*---------------------------------------------------------------------*
         EJECT
BBCHK    L     #1,##VECDAT(,#7)    load divisor least-significant word
         N     #1,=X'7FFFFFFF'     {0,2¬31-1} mask out the sign bit
         MR    #0,#3               multiply quotient and divisor word
         SLDL  #0,1                {0,2¬31-2} shift for 31-bit radix
         SRL   #1,1                {0,2¬31-1} restore lower word
         L     #8,##VECDAT(,#6)    load dividend word
         SR    #8,#1               {-(2¬31-1),2¬31-1} subtract mult lo
         SRDA  #8,31               {-1,0} shift out all but carry
         SRL   #9,1                {0,2¬31-1} right-justify the 31 bits
         ST    #9,##VECDAT(,#14)   store remainder in word in work area
*---------------------------------------------------------------------*
* When we enter here, reg 0 contains the hi word from the previous    *
* multiplication, and reg 8 holds the carry from the previous         *
* remainder word computation.                                         *
*---------------------------------------------------------------------*
         XR    #2,#2               INITIALIZE INDUCTION BXLE COUNTER
         LA    #4,4                INCREMENT AMOUNT OF BXLE LOOP
BBLOOPM  L     #1,##VECDAT+4(#2,#7) load divisor word
         SLR   #8,#0               {-(2¬31-1),0} sub hi-mul from carry
         MR    #0,#3               multiply quotient and divisor words
         SLDL  #0,1                {0,2¬31-2} shift for 31-bit radix
         SRL   #1,1                {0,2¬31-1} restore lower word
         A     #8,##VECDAT+4(#2,#6) {-(2¬31-1),2¬31-1} add dividend wrd
         SR    #8,#1               {-(2¬32-2),2¬31-1} sub lo-mul
         BO    BBMC                double carry if overflow
         SRDA  #8,31               {-1,0} shift all but carry amount
         SRL   #9,1                {0,2¬31-1} right-justify the 31 bits
         ST    #9,##VECDAT+4(#2,#14) store remainder word in work area
         BXLE  #2,#4,BBLOOPM       iterate to next word?
         EJECT
*---------------------------------------------------------------------*
* Compare remainder to divisor.  Remainder should be positive but     *
* less than the divisor.  If it's negative, we decrement the quotient.*
* The remainder will never be greater than the divisor.  However,     *
* traps (BUG# labels) have been inserted to catch instances where this*
* appears to happen.  Then it must be assumed that there is a bug     *
* in the algorithm which generated the trial divisor, or in the code  *
* that determined that it was greater than the divisor.               *
*                                                                     *
* The comparison with the divisor below can theoretically be          *
* eliminated, since the quotient bigit can never be too low (see      *
* Knuth, Vol 2).  However, we keep it in here a little longer to      *
* catch any bugs in the code that leads to this point.  At the same   *
* time, this provides a more reliable divide since it has such a      *
* self check.                                                         *
*                                                                     *
* That is, all paths below which never lead to an BBDQ can simply     *
* be replaced by a direct branch to BBQOK.                            *
*---------------------------------------------------------------------*
BBENDCHK SLR   #8,#0               {-(2¬31-1),0} sub hi-mul from carry
         A     #8,##VECDAT+4(#2,#6) {-(2¬31-1),2¬31-1} add dividend wrd
         BM    BBDQ                if not, then quotient is too high
         BP    BBIQ                if not, then quotient is too low
*
         C     #9,##VECDAT(#2,#7)  is highest word of remainder to big?
         BH    BBIQ                if so, inc quotient & check it again
         LCR   #1,#4               generate a -4 for the BXH
         LR    #2,#5               initialize the count to the top
BBCMPR   L     #9,##VECDAT+4(#2,#14) get remainder word
         C     #9,##VECDAT+4(#2,#7) compare with dividend word
         BH    BBIQ                remainder to high, inc. quotient
         BL    BBQOK               remainder is lower than divisor, ok
         BXH   #2,#1,BBCMPR        not reached next to last word?
*
         L     #9,##VECDAT(,#7)    least significant word of divisor
         N     #9,=X'7FFFFFFF'     mask out the sign bit
         C     #9,##VECDAT(,#14)   compare these words
         BH    BBQOK               divisor is bigger than remainder, ok
*
***BBIQ  AH    #3,=H'1'            increment the quotient
***      BP    BBCHK               check the incremented quotient
BBIQ     B     BUG6                BBIQ should never happen, see Knuth
*
*                                  really part of BBLOOPM above
BBMC     SRDA  #8,31               {-1,0} shift all but carry amount
         BM    BUG8             DIVSRDA,BM,SRL,SH>LR #9,#8;LH #8,=H'-2'
         SRL   #9,1                {0,2¬31-1} right-justify the 31 bits
         SH    #8,=H'2'            subtract the double carry
         ST    #9,##VECDAT+4(#2,#14) store remainder word in work area
         BXLE  #2,#4,BBLOOPM       iterate to next word?
         B     BBENDCHK            check the carry position at end
*
BBDQ     SH    #3,=H'1'            decrement quotient
         BNM   BBCHK
         B     BUG7                can't happen! quotient never < 0
*
BBQOK    ST    #3,##VECDAT(#10,#15) store result quotient
         LA    #0,##VECDAT(,#14)   address of remainder for MVCL
         LA    #1,8(,#5)           length of temp remainder
         LA    #2,##VECDAT(,#6)    destination - fake dividend
         LA    #3,12(,#5)          pad out higest rem word to 0
         MVCL  #2,#0               stuff remainder into dividend
         SR    #10,#4              any more quotient bigits to calc?
         BNM   QBIGIT              go compute another quotient bigit
*
         LM    #8,#11,ZLCISAVE     RESTORE THE SAVED REGISTERS
         NI    ZLCIFLGS,255-ZLCISVD  INDICATE THAT REGISTERS RESTORED
         L     #1,BIGLDIFF         length is this or 4 more
         CR    #1,#4
         L     #0,##VECDAT(#1,#15) Get higest word of result
         BNE   BBLONG              Result may be a long bignum
         LTR   #0,#0               Leading bigit=0?  then fixnum
         BNZ   BB2WRD              Result is a two-word bignum
         L     #2,##VECDAT(,#15)   get ls word of bignum-to-be-fixnum
         L     #6,0(,#11)          load address of original dividend
         TM    ##VECDAT(#6),X'80'  test sign of dividend
         BNO   *+6                 not negative, don't include sign
         LCR   #2,#2               incorporate sign into answer
         TM    ##VECDAT(#7),X'80'  test sign of divisor
         BNO   *+6                 not negative, don't include sign
         LCR   #2,#2               incorporate sign into answer
         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS
         #MKAT FIXED               create the fixnum answer
         B     RETURN
*
BB2WRD   L     #2,##VECDAT(,#7)    load signed word of divisor
         L     #6,0(#11)           Get pointer to real dividend
         MVC   1(3,#15),=X'000008' Insert length of two word bignum
         X     #2,##VECDAT(,#6)    combine with sign of dividend
         N     #2,=X'80000000'     retain only the sign
         O     #2,##VECDAT(,#15)   combine with least word of bignum
         LA    #1,##VECDAT+8(,#15) point to end of bignum in storage
         ST    #2,##VECDAT(,#15)   store sign and least bignum word
         CLC   TWO31MX,0(#15)      check for illegal bignum -2¬31
         BE    RETT31M             if it's there, issue -2¬31 fixnum
         ST    #1,ZLCVSNXT         UPDATE VSS AVAILABILITY POINTER
         B     RETURN
*
BBLONG   LTR   #0,#0               Leading bigit=0?
         L     #2,##VECDAT(,#7)    load signed word of divisor
         L     #6,0(#11)           Get pointer to real dividend
         BZ    BBLONG0             Bignum length in #1 is correct
         LA    #1,4(,#1)           Length is one more word
BBLONG0  X     #2,##VECDAT(,#6)    combine with sign of dividend
         STCM  #1,B'0111',1(#15)   Store bignum length into header
         N     #2,=X'80000000'     retain only the sign
         O     #2,##VECDAT(,#15)   combine with least word of bignum
         LA    #1,##VECDAT(#1,#15) point to end of bignum in storage
         ST    #2,##VECDAT(,#15)   store sign and least bignum word
         CLC   TWO31MX,0(#15)      check for illegal bignum -2¬31
         BE    RETT31M             if it's there, issue -2¬31 fixnum
         ST    #1,ZLCVSNXT         UPDATE VSS AVAILABILITY POINTER
         B     RETURN
*=====================================================================*
*  SUBROUTINE TO CALCULATE THE LEFT JUSTIFICATION SHIFT FOR TRIAL     *
*  DIVISION.  ANSWER IN REG 4 IS NEGATIVE, REG 0 IS DESTROYED.        *
*  The shift amount in reg 4 can be from -30 to 0.                    *
*=====================================================================*
LJSHIFT  LTR   #0,#0
         BM    BUG9                leading bignum bigit is 0, error!
         CL    #0,=X'000000FF'     ASSUMES HIGH TWO WORDS IN #0,#1
         BNH   BYTE0               ALL BITS ARE IN BYTE 0
         CL    #0,=X'0000FFFF'     ALL BITS IN LOWER HALF?
         BNH   BYTE1               YES, ALL BITS IN LOWER HALF
         CL    #0,=X'00FFFFFF'     ALL BITS IN LOWER THREE BYTES?
         BNH   BYTE2               YES, ALLB ITS IN LOWER 3 BYTES
*
         XR    #4,#4               SET INITIAL SHIFT NEGATIVE COUNT
         SLA   #0,1                DO FIRST SHIFT AND TEST HIGH BIT
         BOR   #14                 HIGH BIT IS A ONE
AGAIN3   BCTR  #4,0                INCREMENT SHIFT NEGATIVE COUNT
         SLA   #0,1                SHIFT ONE MORE AND TEST HIGH BIT
         BNO   AGAIN3              HIGH BIT IS NOT A ONE
         BR    #14                 RETURN TO CALLING POINT
*
BYTE2    LH    #4,=H'-7'           SET INITIAL SHIFT NEGATIVE COUNT
         SLA   #0,8                DO FIRST SHIFT AND TEST HIGH BIT
         BOR   #14                 HIGH BIT IS A ONE
AGAIN2   BCTR  #4,0                INCREMENT SHIFT NEGATIVE COUNT
         SLA   #0,1                SHIFT ONE MORE AND TEST HIGH BIT
         BNO   AGAIN2              HIGH BIT IS NOT A ONE
         BR    #14                 RETURN TO CALLING POINT
*
BYTE1    LH    #4,=H'-15'          SET INITIAL SHIFT NEGATIVE COUNT
         SLA   #0,16               DO FIRST SHIFT AND TEST HIGH BIT
         BOR   #14                 HIGH BIT IS A ONE
AGAIN1   BCTR  #4,0                INCREMENT SHIFT NEGATIVE COUNT
         SLA   #0,1                SHIFT ONE MORE AND TEST HIGH BIT
         BNO   AGAIN1              HIGH BIT IS NOT A ONE
         BR    #14                 RETURN TO CALLING POINT
*
BYTE0    LH    #4,=H'-23'          SET INITIAL SHIFT NEGATIVE COUNT
         SLA   #0,24               DO FIRST SHIFT AND TEST HIGH BIT
         BOR   #14                 HIGH BIT IS A ONE
AGAIN0   BCTR  #4,0                INCREMENT SHIFT NEGATIVE COUNT
         SLA   #0,1                SHIFT ONE MORE AND TEST HIGH BIT
         BNO   AGAIN0              HIGH BIT IS NOT A ONE
         BR    #14                 RETURN TO CALLING POINT
         EJECT
*=====================================================================*
* ARG 1 IS A BIGNUM                                                   *
* ARG 2 IS NOT A BIGNUM OR A FIXNUM                                   *
*=====================================================================*
BG1NBF2  DS    0H
         CLI   ##TYPE(#7),##SFLOAT IS ARG 2 A SINGLE FLOAT?
         BE    BIGSFLO
         CLI   ##TYPE(#7),##DFLOAT IS ARG 2 A DOUBLE FLOAT?
         BE    BIGDFLO
         B     ERROR2              IF NEITHER, ERROR
BIGSFLO  DS    0H                  Bignum / single-float
         L     #15,ZLCCVBF         Get address of ZILCVBF
         LR    #5,#6               Arg1 is bignum, arg2 is float
         #BASR #14,#15             Convert bignum to float
         LER   #F2,#F0             Get float value for arg1
         B     DIVSFLO1            Go to divide arg1 by float arg2
BIGDFLO  DS    0H                  Bignum / double-float
         L     #15,ZLCCVBF         Get address of ZILCVBF
         LNR   #5,#6               Arg1 is bignum, arg2 is float
         #BASR #14,#15             Convert bignum to float
         LDR   #F2,#F0             Get float value for arg1
         B     DIVDFLO1            Go to divide arg1 by float arg2
*
* ARG 1 IS NEITHER A FIXNUM NOR A BIGNUM
*
NBFX1    DS    0H
         CLI   ##TYPE(#6),##SFLOAT IS ARG 1 A SINGLE FLOAT?
         BE    ARG1SFLO
         CLI   ##TYPE(#6),##DFLOAT IS ARG 1 A DOUBLE FLOAT?
         BE    ARG1DFLO
         B     ERROR1              IF NOT, ERROR
*
*
* ARG 1 IS A FIXNUM
* ARG 2 IS NEITHER A FIXNUM NOR A BIGNUM
*
FX1NBF2  DS    0H                  ARG 1 IS FIXED BUT ARG2 IS NOT
         SPACE
*                                                                     *
*---------------------------------------------------------------------*
*                      CHECK TYPE OF ARG 2                            *
*---------------------------------------------------------------------*
         CLI   ##TYPE(#7),##SFLOAT
         BE    FIXSFLO             FIXED / SFLOAT = SFLOAT
         CLI   ##TYPE(#7),##DFLOAT
         BE    FIXDFLO             FIXED / DFLOAT = DFLOAT
         B     ERROR2              FIXED / NONUM = ERROR
FIXSFLO  L     #0,##CDR(,#6)       GET FIXED VALUE 1
         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT
         LRER  #F2,#F0             GET SINGLE FLOAT VALUE 1
         B     DIVSFLO1
FIXDFLO  L     #0,##CDR(,#6)       GET FIXED VALUE 1
         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT
         LDR   #F2,#F0             GET DOUBLE FLOAT VALUE 1
         B     DIVDFLO1
         SPACE
ARG1SFLO DS    0H                  ARG 1 IS SINGLE FLOAT
         SPACE
*---------------------------------------------------------------------*
*                      CHECK TYPE OF ARG 2                            *
*---------------------------------------------------------------------*
         CLI   ##TYPE(#7),##SFLOAT
         BE    SDIVSFLO            SFLOAT / SFLOAT = SFLOAT
         CLI   ##TYPE(#7),##DFLOAT
         BE    SDIVDFLO            SFLOAT / DFLOAT = DFLOAT
         CLI   ##TYPE(#7),##FIXNUM
         BE    SFLOPFIX            SFLOAT / FIXED = SFLOAT
         CLI   ##TYPE(#7),##BIGNUM
         BNE   ERROR2              SFLOAT / NONUM = ERROR
         LE    #F2,##CDR(,#6)      Get single float value 1
         L     #15,ZLCCVBF         Get address of ZILCVBF
         LR    #5,#7               Arg1 is float, arg2 is bignum
         #BASR #14,#15             Convert bignum to float
         LER   #F4,#F0             Get float value for arg2
         B     DIVSFLO2
         SPACE 1
*---------------------------------------------------------------------*
*                      FIXNUM TO SINGLE FLOAT                         *
*---------------------------------------------------------------------*
SFLOPFIX LE    #F2,##CDR(,#6)      Get single float value 1
         L     #0,##CDR(,#7)       GET FIXED VALUE 2
         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT
         LRER  #F4,#F0             GET FLOAT VALUE 2
         B     DIVSFLO2            FLOAT / FIXED = FLOAT
         SPACE
ARG1DFLO DS    0H                  ARG 1 IS DOUBLE FLOAT
         SPACE
         LD    #F2,8(,#6)          GET FLOAT VALUE 1
*---------------------------------------------------------------------*
*                      CHECK TYPE OF ARG 2                            *
*---------------------------------------------------------------------*
         CLI   ##TYPE(#7),##DFLOAT
         BE    DIVDFLO1            DFLOAT / DFLOAT = DFLOAT
         CLI   ##TYPE(#7),##SFLOAT
         BE    DDIVSFLO            DFLOAT / SFLOAT = DFLOAT
         CLI   ##TYPE(#7),##FIXNUM
         BE    DFLOPFIX            DFLOAT / FIXED = DFLOAT
         CLI   ##TYPE(#7),##BIGNUM
         BNE   ERROR2              DFLOAT / NONUM = ERROR
         L     #15,ZLCCVBF         Get address of ZILCVBF
         LNR   #5,#7               Arg1 is float, arg2 is bignum
         #BASR #14,#15             Convert bignum to float
         LDR   #F4,#F0             Get float value for arg2
         B     DIVDFLO2            Go to DIV float arg1 to arg2
         SPACE 1
*---------------------------------------------------------------------*
*                      FIXNUM TO DOUBLE FLOAT                         *
*---------------------------------------------------------------------*
DFLOPFIX L     #0,##CDR(,#7)       GET FIXED VALUE 2
         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT
         LDR   #F4,#F0             GET FLOAT VALUE 2
         B     DIVDFLO2            FLOAT / FIXED = FLOAT
         SPACE
*---------------------------------------------------------------------*
*                       SINGLE FLOAT DIV                              *
*---------------------------------------------------------------------*
SDIVSFLO DS    0H
         LE    #F2,##CDR(,#6)      Get single float value 1
DIVSFLO1 DS    0H
         LE    #F4,##CDR(,#7)      Get single float value 2
DIVSFLO2 DS    0H
         LTER  #F4,#F4             CHECK ARGUMENT 2
         BZ    FLDIVBY0            IF ZERO, ERROR
         DER   #F2,#F4             DIVIDE THEM
         STE   #F2,ZLCWORK         PUT RESULT IN REG FOR ATOM-MAKING
         L     #2,ZLCWORK
         LA    #0,20(,#11)         SET STACK LOCATION FOR CONS
         #MKAT FLOAT               MAKE A FLONUM
         B     RETURN              AND RETURN WITH IT
         SPACE 1
*---------------------------------------------------------------------*
*                       DOUBLE FLOAT DIV                              *
*---------------------------------------------------------------------*
DDIVSFLO DS    0H
         SDR   #F4,#F4
         LE    #F4,##CDR(,#7)      Get double float value 2
         B     DIVDFLO2
SDIVDFLO DS    0H
         SDR   #F2,#F2
         LE    #F2,##CDR(,#6)      Get double float value 1
DIVDFLO1 DS    0H
         LD    #F4,8(,#7)          Get double float value 2
DIVDFLO2 DS    0H
         LTDR  #F4,#F4             CHECK ARGUMENT 2
         BZ    FLDIVBY0            IF ZERO, ERROR
         DDR   #F2,#F4             DIVIDE THEM
         LDR   #F0,#F2
         L     #15,ZLCMDF          Get address of ZILMDF
         #BASR #14,#15             Call ZILMDF to make a double-float
         B     RETURN              AND RETURN WITH IT
         SPACE
         COPY  FIX2FLO             FIXED TO FLOAT CONVERSION SUBROUTINE
         SPACE
FDIVISOR DS    F                   TEMPORARY STORAGE FOR FIXNUM DIVISOR
RSHIFT   DS    F                   TEMPORARY STORAGE FOR SHIFT AMOUNT
REMPTR   DS    F                   TEMPORARY STORAGE REMAINDER POINTER
BIGLDIFF DS    F                   difference in lengths of two bignums
SAVE1500 DS    2A                  Regs saved across FREEMAIN/GETMAIN
         DS    0A
TWO31M   #IATM -2147483648         IN-LINE MOST NEGATIVE FIXNUM (-2¬31)
*        DS    0A                  ALIGN FIXNUM TO FULLWORD
*TWO31M  DC    YL1(##FIXNUM),AL3(0),F'-2147483648'  MOST NEG FIXNUM
         DS    0A                  ALIGN BIGNUM TO FULLWORD
ZTWO31   DC    YL1(##BIGNUM),AL3(8),F'0,1' 2**31 BIGNUM
TWO31    EQU   ZTWO31,*-ZTWO31     LABEL AND LENGTH FOR TWO31
ZTWO31MX DC    YL1(##BIGNUM),AL3(8),X'80000000',F'1' -2**31 bad BIGNUM
TWO31MX  EQU   ZTWO31MX,*-ZTWO31MX LABEL AND LENGTH FOR two31mx
BIG8     DC    YL1(##BIGNUM),AL3(8) LENGTH OF SHORT BIGNUM
         SPACE
FFDIVBY0 EQU   *
FLDIVBY0 EQU   *
BFDIVBY0 EQU   *
         #ERR  'Attempted to divide ',0(#11),' by ',4(#11)
ERROR1   #ERR  'Argument 1 to divide not a number - ',0(#11)
ERROR2   #ERR  'Argument 2 to divide not a number - ',4(#11)
BUG1     LA    #2,1
         B     BUGERR
BUG2     LA    #2,2
         B     BUGERR
BUG3     LA    #2,3
         B     BUGERR
BUG4     LA    #2,4
         B     BUGERR
BUG5     LA    #2,5
         B     BUGERR
BUG6     LM    #8,#11,ZLCISAVE     RESTORE THE SAVED REGISTERS
         NI    ZLCIFLGS,255-ZLCISVD  INDICATE THAT REGISTERS RESTORED
         LA    #2,6
         B     BUGERR
BUG7     LM    #8,#11,ZLCISAVE     RESTORE THE SAVED REGISTERS
         NI    ZLCIFLGS,255-ZLCISVD  INDICATE THAT REGISTERS RESTORED
         LA    #2,7
         B     BUGERR
BUG8     LM    #8,#11,ZLCISAVE     RESTORE THE SAVED REGISTERS
         NI    ZLCIFLGS,255-ZLCISVD  INDICATE THAT REGISTERS RESTORED
         LA    #2,8
         B     BUGERR
BUG9     LA    #2,9
******** B     BUGERR
BUGERR   #ERR  'Bignum/bignum divide, internal bug #',#2,' for ',      X
               0(#11),' and ',4(#11),' - please report.'
         SPACE 1
GERROR   DS    0H                  Error - not enough work area
         XR    #0,#0               Clear work area address and length
         ST    #0,ZLCWA
         ST    #0,ZLCWALEN
         #ERR  PREFIX=NO,                                              X
               'ZIL3102 ZILDIV: Not enough memory to perform trial diviX
               sion.'
         SPACE 1
         LTORG
         END
