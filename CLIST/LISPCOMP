
/**********************************************************************/
/*                                                                    */
/* LISPCOMP - compile a ZIL (LISP) source file                        */
/*                                                                    */
/**********************************************************************/

PROC 1  DSNAME +
        FUNCTION PROGRAM MODULE +
        NAME() +
        LOAD() NOLOAD +
        ASM() NOASM +
        PRINT(*) NOPRINT +
        MACROS() +
        SUBRLIB() +
        ACSIZE() +
        CSSIZE() +
        PDSIZE() +
        VSSIZE() +
        DEBUG NODEBUG +
        TRANSDEBUG NOTRANSNODEBUG +
        SYSPARM(XA) +
        NEW OLD +
        XTRACE

NGLOBAL RESULT

IF &XTRACE = XTRACE THEN CONTROL LIST SYMLIST CONLIST
CONTROL NOCAPS

/*  Preliminary syntax checks  */

IF &NOASM = NOASM THEN DO
 SET ASM =
 SET NOLOAD = NOLOAD
END
IF &NOLOAD = NOLOAD THEN SET LOAD =

SET KIND = &FUNCTION &PROGRAM &MODULE
IF &KIND = THEN DO
 WRITE LISPCOMP: Compile of MODULE assumed.
 SET KIND = MODULE
END
ELSE IF &KIND ¬= FUNCTION && &KIND ¬= PROGRAM && &KIND ¬= MODULE THEN DO
 WRITE LISPCOMP: Conflicting operands specified - &KIND
 EXIT C(12) Q
END

IF &NEW&OLD = NEW THEN SET SYS = N
ELSE IF &NEW&OLD = OLD THEN SET SYS = O
ELSE IF &NEW&OLD =     THEN SET SYS =
ELSE DO
 WRITE Cannot specify both NEW and OLD - specify one or neither.
 EXIT C(12) Q
END

/* You may need to do some configuring in this section. */

SET LIBRARY    = &STR(PROGLIB.ZIL.&SYS.LOAD)
SET MACLIB     = &STR(PROGLIB.ZIL.&SYS.MACLIB)
SET ASSEMBLER  = &STR('SYS1.LINKLIB(IEV90)')
SET SYSMACLIB  = &STR('SYS1.MACLIB')
SET TEMPPREFIX = &STR(&SYSPREF..ZIL.$ZILTEMP)

/* If the EXECPGM command from file 183 of the CBT tape is present
/* on your system, set this variable to Y.  Otherwise set it to N.

SET EXECPGM_IS_AVAILABLE = N

/* End of configuring section. */

IF &SYSTSOE GE 2050 THEN SET TSOLIB_IS_AVAILABLE = Y
ELSE SET TSOLIB_IS_AVAILABLE = N

SET SUBMETHOD =
IF &NRSTR(&SUBRLIB) NE THEN DO
 IF      &EXECPGM_IS_AVAILABLE = Y THEN SET SUBMETHOD = EXECPGM
 ELSE IF &TSOLIB_IS_AVAILABLE  = Y THEN DO
  ISPQRY
  IF &LASTCC = 0 THEN DO
   WRITE Error: SUBRLIB is not available from within ISPF.
   WRITE        Please reinvoke this CLIST from TSO READY mode, or
   WRITE        without the SUBRLIB keyword.
   EXIT C(16) Q
  END
  ELSE DO
   SET SUBMETHOD = TSOLIB
  END
 END
 ELSE DO
  WRITE Error: SUBRLIB is not available.
  WRITE        Please reinvoke this CLIST without the SUBRLIB keyword.
  EXIT C(16) Q
 END
END

IF &STR(&ACSIZE) ¬= THEN SET ACSIZE = &STR(A=&ACSIZE)
ELSE SET ACSIZE =
IF &STR(&CSSIZE) ¬= THEN SET CSSIZE = &STR(C=&CSSIZE)
ELSE SET CSSIZE =
IF &STR(&PDSIZE) ¬= THEN SET PDSIZE = &STR(P=&PDSIZE)
ELSE SET PDSIZE =
IF &STR(&VSSIZE) ¬= THEN SET VSSIZE = &STR(V=&VSSIZE)
ELSE SET VSSIZE =

IF &XTRACE = THEN CONTROL NOMSG
FREE F(SYSIN SYSLIN SYSPRINT SYSLIB SYSUT1 SYSTERM)
CONTROL MSG

SYSCALL SETDSN &DSNAME TYPE(LISP) ANYORG MEMBER VERIFY LET
SET MEMCC = &LASTCC
SET SYSDVAL = &NRSTR(&RESULT)
IF &MEMCC > 0 THEN EXIT C(&MEMCC) Q
READDVAL DSIDENT DSTYPE DSMEM
IF &STR(&DSMEM) ¬= THEN DO
 SET MEMBER = &STR((&DSMEM))
END
ELSE SET MEMBER =
SET ZILCODE = &STR('&DSIDENT..&DSTYPE&MEMBER')

SET INPUTNAME = &STR(&DSMEM)

IF &NOPRINT = NOPRINT THEN DO
 SET PRINT =
END
ELSE IF &STR(&PRINT) ¬= &STR(*) +
     && &STR(&PRINT) ¬= THEN DO
 SYSCALL SETDSN &PRINT TYPE(ZILLIST) ANYORG NOCHECKMEMBER OPTIONAL LET
 SET MEMCC = &LASTCC
 SET SYSDVAL = &NRSTR(&RESULT)
 READDVAL PRIDENT PRTYPE PRMEM
 IF &STR(&PRMEM) ¬= THEN SET MEMBER = &STR((&PRMEM))
 ELSE SET MEMBER =
 SET PRINT = &STR('&PRIDENT..&PRTYPE&MEMBER')
 IF &MEMCC = 8 THEN DO
  IF &STR(&MEMBER) = THEN SYSCALL MAKEDS &PRINT LISTF120
  ELSE SYSCALL MAKEPDS &PRINT LISTF120
 END
 ELSE IF &MEMCC > 0 THEN EXIT C(&MEMCC) Q
END
ELSE DO
 SET PRINT = &STR(*)
END

IF &NOASM = NOASM THEN DO
 SET ASMCODE =
END
ELSE IF &STR(&ASM) ¬= THEN DO
 SYSCALL SETDSN &ASM TYPE(ASM) ANYORG MEMBER NOCHECKMEMBER OPTIONAL LET
 SET MEMCC = &LASTCC
 SET SYSDVAL = &NRSTR(&RESULT)
 READDVAL ASMIDENT ASMTYPE ASMMEM
 IF &STR(&ASMMEM) ¬= THEN SET MEMBER = &STR((&ASMMEM))
 ELSE SET MEMBER =
 SET ASMCODE = &STR('&ASMIDENT..&ASMTYPE&MEMBER')
 IF &MEMCC = 8 THEN DO
  IF &STR(&MEMBER) = THEN SYSCALL MAKEDS '&ASMIDENT..&ASMTYPE' ASM
  ELSE SYSCALL MAKEPDS '&ASMIDENT..&ASMTYPE' ASM
 END
 ELSE IF &MEMCC > 4 THEN EXIT C(&MEMCC) Q
END
ELSE DO
 SET ASMCODE = &STR('&TEMPPREFIX..ASM')
END

SET ASMLIST = &STR('&TEMPPREFIX..ASMLIST')
SET OBJCODE = &STR('&TEMPPREFIX..OBJ')

IF &NOLOAD = NOLOAD THEN DO
 SET SYSLMOD =
END
ELSE DO
 IF &STR(&LOAD) = THEN DO
  IF &STR(&NAME) ¬= THEN SET OUTPUTNAME = &STR(&NAME)
  ELSE IF &STR(&INPUTNAME) ¬= THEN SET OUTPUTNAME = &STR(&INPUTNAME)
  ELSE SET OUTPUTNAME =
  SET LDIDENT = &STR(&DSIDENT)
  SET LDTYPE = LOAD
 END
 ELSE DO
  SYSCALL SETDSN &LOAD +
          TYPE(LOAD) PDSORG NOCHECKMEMBER OPTIONAL LET
  SET MEMCC = &LASTCC
  SET SYSDVAL = &NRSTR(&RESULT)
  READDVAL LDIDENT LDTYPE LDMEM
  IF &MEMCC > 4 THEN EXIT C(&MEMCC) Q
  IF &STR(&LDMEM) = THEN DO
   IF &STR(&NAME) ¬= THEN SET LDMEM = &STR(&NAME)
   ELSE IF &STR(&INPUTNAME) ¬= THEN SET LDMEM = &STR(&INPUTNAME)
   /* Otherwise LDMEM and OUTPUTNAME will be blank, which will
   /* be flagged below as an error.
  END
  SET OUTPUTNAME = &STR(&LDMEM)
 END
 IF &STR(&OUTPUTNAME) ¬= THEN DO
  SET MEMBER = &STR((&OUTPUTNAME))
 END
 ELSE SET MEMBER =
 SET SYSLMOD = &STR('&LDIDENT..&LDTYPE&MEMBER')
END

IF &STR(&NAME) = THEN DO
 IF &STR(&OUTPUTNAME) ¬= THEN SET NAME = &STR(&OUTPUTNAME)
 ELSE +
  IF &STR(&INPUTNAME) ¬= THEN SET NAME = &STR(&INPUTNAME)
 ELSE DO
  WRITE LISPCOMP: Input is sequential, a NAME is required
  EXIT C(12) Q
 END
END

SET KINDPARM = &SUBSTR(1,&KIND)
IF &DEBUG = DEBUG THEN SET DEBUGPARM = Y
ELSE SET DEBUGPARM = N
SET PARM = &STR(&KINDPARM&DEBUGPARM&NAME)

WRITE Compiling &SYSLC(&KIND) &NAME....
WRITE Source:   &ZILCODE
IF &STR(&ASM) ¬= THEN +
WRITE Assemble: &ASMCODE
IF &NOLOAD = THEN +
WRITE Load:     &SYSLMOD

IF &NOASM = NOASM THEN DO
 ALLOC F(ZILOCODE) DUMMY REU
 ALLOC F(SYSIN)    DUMMY REU
END
ELSE DO
 SYSCALL MAKEDS &ASMCODE ASM SIZE(20)
 ALLOC F(ZILOCODE) DA(&ASMCODE) REU
 ALLOC F(SYSIN) DA(&ASMCODE) REU
END
ALLOC F(ZILI) DA(*) REU
IF &NOPRINT = NOPRINT THEN DO
 ALLOC F(ZILO) DUMMY REU
END
ELSE DO
 ALLOC F(ZILO) DA(&PRINT) REU
END
IF &STR(&MACROS) ¬= THEN +
 ALLOC F(ZILICMAC) SHR REU DA(&MACROS)
ELSE +
 ALLOC F(ZILICMAC) DUMMY REU
ALLOC F(ZILISRC) SHR REU DA(&ZILCODE)
IF &TRANSDEBUG&NOTRANSDEBUG = TRANSDEBUG THEN DO
 ALLOC F(ZILOCTRN) SP(100 100) T REL REU DEL
 SET CTRN = Y
END
ELSE DO
 IF &XTRACE = THEN CONTROL NOMSG
 FREE F(ZILOCTRN)
 CONTROL MSG
 SET CTRN = N
END

SET ZILCOPARMS = &NRSTR(\&ACSIZE,&CSSIZE,&PDSIZE,&VSSIZE\&PARM)

IF &SUBMETHOD = EXECPGM THEN DO
 ALLOC FI(ZILLIB) DA(&SUBRLIB '&LIBRARY') SHR REU
 EXECPGM ZILCO PARM('&NRSTR(&ZILCOPARMS)') TASKLIB(ZILLIB)
 SET ZILCOCC = &LASTCC
 FREE FI(ZILLIB)
END
ELSE IF &SUBMETHOD = TSOLIB THEN DO
 TSOLIB ACT DATASET(&SUBRLIB '&LIBRARY')
 CALL *(ZILCO) '&NRSTR(&ZILCOPARMS)'
 SET ZILCOCC = &LASTCC
 TSOLIB DEACT
END
ELSE DO
 CALL '&LIBRARY(ZILCO)' '&NRSTR(&ZILCOPARMS)'
 SET ZILCOCC = &LASTCC
END

IF &ZILCOCC ¬= 0 THEN DO
 IF &NOPRINT = NOPRINT THEN DO
  WRITE LISPCOMP: ZIL compilation failed with error code &ZILCOCC..
  WRITE           Rerun this CLIST without NOPRINT to determine the error.
 END
 ELSE IF &SUBSTR(1,&PRINT ) = ' THEN DO
  WRITE LISPCOMP: ZIL compilation failed with error code &ZILCOCC..
  WRITE           Browse &PRINT to determine the error.
 END
 EXIT C(&ZILCOCC) QUIT
END
FREE F(ZILISRC ZILICMAC ZILI ZILO)
IF &CTRN = Y THEN DO
 SYSCALL LISTFILE ZILOCTRN
 FREE F(ZILOCTRN)
END

IF &NOASM&NOLOAD ¬= THEN EXIT

WRITE LISPCOMP: &NAME compiled into &ASMCODE
IF &SUBSTR(1,&PRINT ) = ' THEN +
WRITE           Listing in:  &PRINT

IF &SYSDSN(&OBJCODE) ¬= OK THEN SYSCALL MAKEDS &OBJCODE OBJ
IF &SYSDSN(&ASMLIST) ¬= OK THEN SYSCALL MAKEDS &ASMLIST ASMLIST
ALLOC F(SYSLIN)     REU DA(&OBJCODE)
ALLOC F(SYSPRINT)   REU DA(&ASMLIST)
ALLOC F(SYSLIB) SHR REU DA(&SYSMACLIB '&MACLIB')
ALLOC F(SYSUT1)     REU T SP(50 50) DEL REL
ALLOC F(SYSTERM)    REU DA(*)
WRITE Assembly listing output to: &ASMLIST
WRITE Assembling &NAME into &OBJCODE

CALL &ASSEMBLER +
     'LIST,TERM,ESD,RLD,NOXREF,OBJECT,NODECK,SYSPARM(&SYSPARM)'
IF &LASTCC ¬= 0 THEN DO
 WRITE LISPCOMP: Assembly failed - check &ASMLIST for errors.
 EXIT C(16) QUIT
END
FREE F(ZILOCODE SYSIN SYSLIN SYSPRINT SYSLIB SYSUT1 SYSTERM)

WRITE Linking &OBJCODE into &SYSLMOD
IF &SUBRLIB = THEN SET LINKLIB =
ELSE SET LINKLIB = LIB(&SUBRLIB)
IF &KIND = PROGRAM THEN DO
 LINK &OBJCODE +
      LOAD(&SYSLMOD) +
      &LINKLIB +
      PRINT(*) +
      LIST LET TERM &MAP &TEST
END
ELSE DO
 LINK &OBJCODE +
      LOAD(&SYSLMOD) +
      NOPRINT +
      LIST MAP LET TERM NCAL &MAP &TEST
END
IF &LASTCC > 4 THEN EXIT QUIT

WRITE
WRITE LISPCOMP: &NAME load module is in &SYSLMOD..

EXIT

/* *** */

SETDSN: +
PROC 1 DSNAME +
       TYPE() ANYORG PDSORG SEQORG VERIFY NOVERIFY +
       MEMBER NOMEMBER LET RECALL NORECALL +
       OPTIONAL CHECKMEMBER NOCHECKMEMBER

IF &STR(&SYSPREF) = &STR() THEN SET PREFIX =
ELSE SET PREFIX = &STR(&SYSPREF..)
SET LP = &SUBSTR(1,())
SET RP = &SUBSTR(2,())

SET RESULT =
SET ERRORMSG =
SET ERRORCODE = 0

SELECT &ANYORG&PDSORG&SEQORG
 WHEN (&STR()) SET ORG = ANY
 WHEN (ANYORG) SET ORG = ANY
 WHEN (PDSORG) SET ORG = PDS
 WHEN (SEQORG) SET ORG = SEQ
 OTHERWISE     SET ORG = ANY
END

SELECT &ORG
 WHEN (ANY) DO
  SET MEMBER =
  IF &MEMBER&NOMEMBER NE MEMBER   THEN SET MEMBER = NOMEMBER
  IF &VERIFY&NOVERIFY NE NOVERIFY THEN SET VERIFY = VERIFY
  IF &RECALL&NORECALL NE NORECALL THEN SET RECALL = RECALL
  IF &CHECKMEMBER&NOCHECKMEMBER NE NOCHECKMEMBER +
                                  THEN SET CHECKMEMBER = CHECKMEMBER
 END
 WHEN (SEQ) DO
  SET MEMBER =
  SET NOMEMBER = NOMEMBER
  SET CHECKMEMBER =
  SET NOCHECKMEMBER = NOCHECKMEMBER
  IF &MEMBER&NOMEMBER NE NOMEMBER THEN SET MEMBER = MEMBER
  IF &VERIFY&NOVERIFY NE NOVERIFY THEN SET VERIFY = VERIFY
  IF &RECALL&NORECALL NE NORECALL THEN SET RECALL = RECALL
  IF &CHECKMEMBER&NOCHECKMEMBER NE NOCHECKMEMBER +
                                  THEN SET CHECKMEMBER = CHECKMEMBER
 END
 WHEN (PDS) DO
  IF &MEMBER&NOMEMBER NE NOMEMBER THEN SET MEMBER = MEMBER
  IF &VERIFY&NOVERIFY NE NOVERIFY THEN SET VERIFY = VERIFY
  IF &RECALL&NORECALL NE NORECALL THEN SET RECALL = RECALL
  IF &CHECKMEMBER&NOCHECKMEMBER NE NOCHECKMEMBER +
                                  THEN SET CHECKMEMBER = CHECKMEMBER
  IF &NOMEMBER = NOMEMBER THEN NOCHECKMEMBER = NOCHECKMEMBER
 END
END

IF &CHECKMEMBER = CHECKMEMBER THEN SET NOVERIFY =

SET L = &LENGTH(&NRSTR(&DSNAME))

IF &SUBSTR(1,&NRSTR(&DSNAME)) = ' THEN DO
 SET QUOTED = Y
 IF &SUBSTR(&L,&NRSTR(&DSNAME)) NE ' THEN DO
  SET ERRORMSG = &STR(Invalid syntax (mismatched quotes))
  SET ERRORCODE = 32
  GOTO BLAZES
 END
 IF &L LT 3 THEN DO
  SET ERRORMSG = &STR(Invalid syntax (nothing between quotes))
  SET ERRORCODE = 32
  GOTO BLAZES
 END
 SET UDSN = &SUBSTR(2:&L-1,&DSNAME)
END
ELSE DO
 SET QUOTED = N
 IF &NRSTR(&SYSPREF) = THEN SET UDSN = &NRSTR(&DSNAME)
 ELSE SET UDSN = &NRSTR(&SYSPREF..&DSNAME)
END

SET U = &LENGTH(&NRSTR(&UDSN))

/* scan for member name */

SET P = &SYSINDEX(&LP,&NRSTR(&UDSN))
SET Q = &SYSINDEX(&RP,&NRSTR(&UDSN))
IF &P > 1 && &Q = &U && &P < &Q-1 THEN DO
 SET DSPART = &SUBSTR(1:&P-1,&NRSTR(&UDSN))
 SET DSMEMB = &SUBSTR(&P+1:&Q-1,&NRSTR(&UDSN))
END
ELSE DO
 SET DSPART = &NRSTR(&UDSN)
 SET DSMEMB =
END
SET B = &LENGTH(&NRSTR(&DSPART))
DO I = &B TO 1 BY -1 WHILE &SUBSTR(&I,&NRSTR(&DSPART)) NE .
END
IF &I = &B THEN DO
 SET ERRORMSG = &STR(Invalid syntax (ends in period))
 SET ERRORCODE = 32
 GOTO BLAZES
END
IF &I = 1 THEN DO
 SET ERRORMSG = &STR(Invalid syntax (start with period))
 SET ERRORCODE = 32
 GOTO BLAZES
END
IF &I = 0 THEN DO
 SET DSBASE = &NRSTR(&DSPART)
 SET DSTYPE =
END
ELSE DO
 SET DSBASE = &SUBSTR(1:&I-1,&NRSTR(&DSPART))
 SET DSTYPE = &SUBSTR(&I+1:&B,&NRSTR(&DSPART))
END

/* I'm not sure about this.

SET CHANGETYPE = N

IF &LET = LET THEN DO
 IF &QUOTED = N THEN DO
  IF &NRSTR(&TYPE) NE THEN DO
   IF &NRSTR(&TYPE) NE &NRSTR(&DSTYPE) THEN DO
    SET CHANGETYPE = Y
   END
  END
 END
END
ELSE DO
 IF &QUOTED = Y THEN DO
  IF &NRSTR(&TYPE) NE THEN DO
   IF &NRSTR(&TYPE) NE &NRSTR(&DSTYPE) THEN DO
    SET CHANGETYPE = Y
   END
  END
 END
 ELSE DO
  IF &NRSTR(&TYPE) NE THEN DO
   IF &NRSTR(&TYPE) NE &NRSTR(&DSTYPE) THEN DO
    SET CHANGETYPE = Y
   END
  END
 END
END

IF &CHANGETYPE = Y THEN DO
 SET DSBASE = &NRSTR(&DSPART)
 SET DSTYPE = &NRSTR(&TYPE)
END

IF &NRSTR(&DSMEMB) NE THEN SET UDSN = &NRSTR(&DSBASE..&DSTYPE(&DSMEMB))
ELSE                       SET UDSN = &NRSTR(&DSBASE..&DSTYPE)

SET FULLDSN = &NRSTR('&UDSN')

SET RESULT = &NRSTR(&DSBASE &DSTYPE &DSMEMB)

SET STATUS = &SYSDSN(&FULLDSN)
SELECT &STR(&STATUS)
 WHEN (OK) DO
 END
 WHEN (DATASET NOT FOUND) DO
  IF &OPTIONAL = OPTIONAL THEN RETURN CODE(8)
  ELSE DO
   SET ERRORMSG = &NRSTR(Cannot access data set &FULLDSN: &STATUS)
   SET ERRORCODE = 8
   GOTO BLAZES
  END
 END
 WHEN (MEMBER NOT FOUND) DO
  IF &NOCHECKMEMBER = NOCHECKMEMBER THEN DO
  END
  ELSE DO
   SET ERRORMSG = &NRSTR(Cannot access data set &FULLDSN: &STATUS)
   SET ERRORCODE = 8
   GOTO BLAZES
  END
 END
 OTHERWISE DO
  SET ERRORMSG = &NRSTR(Cannot access data set &FULLDSN: &STATUS)
  SET ERRORCODE = 12
  GOTO BLAZES
 END
END

IF &VERIFY = VERIFY THEN DO
 SET SYSDSORG =
 LISTDSI &FULLDSN &RECALL &NORECALL
 IF &ORG = ANY THEN DO
  IF &NRSTR(&DSMEMB) NE THEN SET ORG = PDS
  ELSE SET ORG = SEQ
 END
 IF &ORG = SEQ THEN DO
  IF &SUBSTR(1:2,&SYSDSORG  ) NE PS THEN DO
   SET ERRORMSG = &STR(Data set must not be partitioned, but is.)
   SET ERRORCODE = 12
   GOTO BLAZES
  END
 END
 IF &ORG = PDS THEN DO
  IF &SUBSTR(1:2,&SYSDSORG  ) NE PO THEN DO
   SET ERRORMSG = &STR(Data set must be partitioned, but is not.)
   SET ERRORCODE = 12
   GOTO BLAZES
  END
 END
END

RETURN CODE(0)

BLAZES: +
WRITE Error processing data set: &UDSN
IF &NRSTR(&ERRORMSG) = THEN WRITE Unknown error code &ERRORCODE
ELSE WRITE &NRSTR(&ERRORMSG)

RETURN CODE(&ERRORCODE)

END SETDSN

/* *** */

MAKEDS: PROC 2 DSNAME ATTRLIST SIZE(1)

SYSCALL MAKE &NRSTR(&DSNAME) &NRSTR(&ATTRLIST) SEQ SIZE('&SIZE')

RETURN

END MAKEDS

/* *** */

MAKEPDS: PROC 2 DSNAME ATTRLIST SIZE(1)

SYSCALL MAKE &NRSTR(&DSNAME) &NRSTR(&ATTRLIST) PDS SIZE('&SIZE')

RETURN

END MAKEPDS

/* *** */

MAKE: PROC 3 DSNAME ATTRLIST ORG SIZE(1)

SELECT &ATTRLIST
 WHEN (LISTF120) DO
  SET ARECFM   = F B A
  SET ALRECL   = 121
  SET ABLKSIZE = 6171
 END
 WHEN (TEXT) DO
  SET ARECFM   = V B
  SET ALRECL   = 255
  SET ABLKSIZE = 6233
 END
 WHEN (OBJ) DO
  SET ARECFM   = F B
  SET ALRECL   = 80
  SET ABLKSIZE = 2960
 END
 WHEN (ASMLIST) DO
  SET ARECFM   = F B A
  SET ALRECL   = 121
  SET ABLKSIZE = 6171
 END
 OTHERWISE DO
  SET ARECFM   = F B
  SET ALRECL   = 80
  SET ABLKSIZE = 6160
 END
END

SET ASPACE1  = 16 * &SIZE
SET ASPACE2  = 10 * &SIZE
SET ASPUNITS = BLOCK(&ABLKSIZE)

/* first see if it already exists

SET XMSTAT = &SYSDSN(&NRSTR(&DSNAME))

SELECT &NRSTR(&XMSTAT)
 WHEN (OK) DO
  RETURN CODE(0)
 END
 WHEN (DATASET NOT FOUND) DO
  /* go ahead */
 END
 WHEN (MEMBER NOT FOUND) DO
  RETURN CODE(0)
 END
 OTHERWISE DO
  WRITE &NRSTR(Error: Cannot use data set &DSNAME: &XMSTAT)
  RETURN CODE(16)
 END
END


SET ALLOCPARMS = &NRSTR(+
      RECFM(&ARECFM) LRECL(&ALRECL) BLKSIZE(&ABLKSIZE) +
      SPACE(&ASPACE1 &ASPACE2) &ASPUNITS +
      )
IF &ORG = PDS THEN DO
 SET ALLOCPARMS = &NRSTR(&ALLOCPARMS) DIR(32)
END

ALLOC DA(&NRSTR(&DSNAME)) &NRSTR(&ALLOCPARMS)
IF &LASTCC NE 0 THEN DO
 WRITE Error: Could not allocate new data set &DSNAME..
 RETURN CODE(12)
END

RETURN CODE(0)

END MAKE

/* *** */

LISTFILE: PROC 1 LFDD

CONTROL NOFLUSH
OPENFILE &LFDD INPUT
IF &LASTCC NE 0 THEN RETURN
SET EOF = N
CONTROL NOFLUSH
ERROR DO
 SET EOF = Y
 RETURN
END
DO WHILE &EOF = N
 GETFILE &LFDD
 SET LFLINE = &&&LFDD
 WRITE &SYSNSUB(2,&LFLINE)
END
CLOSFILE &LFDD
RETURN

END LISTFILE
