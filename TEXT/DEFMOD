
**********************************************************************
*                                                                    *
* This function is obsolete.  Use INCLUDE while compiling a MODULE.  *
*                                                                    *
**********************************************************************


Macro: DEFMODULE

Syntax:   (DEFMODULE arg1 arg2 &optional arg3)

 arg1 (required, not evaluated) - a function name.
 arg2 (required, not evaluated) - a data set name.
 arg3 (optional, not evaluated) - any LISP object, generally T or NIL.

Returns:

 arg1, after building a function definition for it that loads all the
 compiled forms contained in file arg2.

Processing:

 DEFMODULE compiles a file into a load module that may be invoked under
 the interpreter to bring in all the code from the file in compiled
 format, including function definitions.

 DEFMODULE is a macro that expands into a list of forms bracketed by
 a PROGN; the forms are taken from the file and processed as follows:

 Given a function FOO generated by:

  (DEFMODULE FOO "MY.LISP(STUFF)")

 a compilable function is built that, when executed by typing (foo)
 under the interpreter, does the operations generally expected by
 implementations of compiled modules created by, say, a COMPILE-FILE
 call in other LISP systems.
 When the function (FOO) is invoked inside the ZIL interpreter, code is
 executed to load all the compiled function definitions and other forms
 that appeared in MY.LISP(STUFF).  Each form from that file is
 processed by the compiler as follows:

 If the form is a macro call, the macro expansion is processed.
 This includes forms for which DEFMACRO's or DEFUN's that define
 the macro expansions are included in the file itself, as long as
 such definitions precede the macro calls.

 If the form is a DEFUN, then the function definition is compiled
 (where possible) and assigned at load time to the symbol naming
 the function, as follows:

 (DEFUN f arglist ...)
 or
 (DEFUN f EXPR ...)    places the compiled definition of f on the
                       SUBR property of f, insuring that no conflicting
                       function definitions are present.

 (DEFUN f MACRO ...)   (or DEFMACRO) makes the macro known in the
                       compiler environment.  The macro is not
                       made known at load time, however.

 (DEFUN f FEXPR ...)   places the interpretive definition of f on the
                       FEXPR property of f, after a warning is issued
                       that FEXPR's cannot be compiled.
                       In addition, creates an equivalent macro
                       definition which is used internally in case there
                       are any calls to the FEXPR in the code.

 (DEFUN f x ...)       (i.e. a non-null atomic arglist) places the
                       interpretive definition of f on the EXPR
                       property of f, after a warning is issued that
                       LEXPR's cannot be compiled.

 (DEFUN (f p) ...)     places the compiled definition on the "p"
                       property of the symbol F.  Note that this is
                       the only way that a file containing such a
                       function definition can be compiled.

 If the function f has been declared non-compilable by means of a
 declaration of the form (DECLARE (NOCOMPILE f ...)) or
 (DECLARE (NOCOMPILE (f p) ... )) - the latter being intended for
 the (DEFUN (f p) ...) definition type - the interpretive definition
 of the function will be placed on the appropriate property.

 Note: In cases where a compiled function definition is generated,
       the definition is assigned as a compiled SUBR; this is similar to
       the case where a function is autoloaded after having been
       compiled as a function.  This means that the code will be
       executed in the variable binding environment active when the
       function is evaluated (executed).  Thus, dynamic scoping is the
       normal behavior for compiled functions loaded in this manner.

 If the form is a DEFVAR or a DEFLOAD, the usual compiler processing
 is done for it, and a call to DEFVAR or DEFLOAD is added to the
 module to be executed at load time.

 If the form is a DECLARE, the usual compiler processing is done.

 If the form is an EVAL-WHEN, the forms within are processed thusly:

  EVAL-WHEN (COMPILE) - forms are evaluated by the compiler itself.
  EVAL-WHEN (LOAD)    - forms are processed as being described now.
  EVAL-WHEN (EVAL)    - ignored.

 If the form is a PROGN, the forms within are processed as being
 described now.

 If the form is anything else, it is added to the generated module
 to be executed at load time.

 The generated module is a function with no arguments.

 Description of the optional args to DEFMODULE:

  If arg3 is specified and non-NIL, the values of the forms as they are
  generated are printed on the standard output file during expansion
  (i.e. compilation); this is a debugging capability.

  As you might imagine, DEFMODULE is primarily for use with the
  compiler; in general, you would compile a ZIL source member FOO which
  contained ONLY the DEFMODULE form pointing to another data set which
  contained the actual forms to be compiled.

Errors signalled:

 Too few arguments.

Notes:

 The function generated by compiling a source file containing a
 DEFMODULE call is quite useful as an AUTOLOAD property on the
 functions that are contained within - e.g.:

  (defprop foo (loadfoo) autoload)
  (defprop bar (loadfoo) autoload)

 If LOADFOO is a module created by compiling a file containing:

  (defmodule loadfoo "some.file")

 and "some.file" is a data set containing DEFUN's for foo and bar,
 then this is a convenient way of autoloading the definitions of
 foo and bar.

 Compare DEFFLIC, which also produces a load module but does not
 compile any of the forms; rather, it causes them to be evaluated
 interpretively at load time.

Examples:


 If we encounter the form:

  (defmodule zmfoo "my.lisp(foo)")

 and the file MY.LISP(FOO) looks like this...

  (defun foo1 (x) (blah1))        ;    1
  (defun (baz frob) (y) (hair))   ;    2
  (defmacro mac (x) `(frob ,x))   ;    3
  (mac "junk")                    ;    4
  (some random form)              ;    5
  (defvar pi 3.1415926)           ;    6
  (defload frobnicate frobozz)    ;    7
  (eval-when (compile)
   (print "hello world"))         ;    8
  (eval-when (load)
   (frob))                        ;    9
  (eval-when (eval)
   (eccch))                       ;   10

 then the resulting form will be (more or less):

  (progn
   (defun zmfoo ()
     (zevdsub 'foo1 (subr foo1))                 ; 1 - assign SUBR prop
     (putprop 'baz (subr (lambda (y) (hair))) 'frob)  ; 2
     (frob "junk")                               ; 4 - expanded MAC
     (some random form)                          ; 5
     (xdefvar pi 3.1415926)                      ; 6
     (xdefload frobnicate frobozz)               ; 7
     (frob)                                      ; 9
   )
   (defun foo1 (x) (blah1))                      ; 1
   (defun mac macro (nil x) `(frob ,x))          ; 2 - expanded DEFMACRO
   (defvar pi 3.1415926)                         ; 6
   (defload frobnicate frobozz)                  ; 7
   (eval-when (compile)
    (print "hello world"))                       ; 8
  )

  Then if you type (zmfoo) under the interpreter, the following will
  occur:
   FOO1 will be defined as a SUBR (compiled EXPR) - dynamically scoped.
   BAZ will have a compiled SUBR on its FROB property.
   The FROB and SOME functions (whatever they are) will be executed.
   PI will be created as a globally bound variable with a value.
   FROBNICATE will be assigned FROBOZZ as its AUTOLOAD property.

  While this is being compiled, "hello world" will appear on the
  compiler's standard output file.

  Note that (9) is ignored - (eval-when (eval)) forms are always ignored
  at compile time.

  Note that function code is compiled with names where desirable and
  that is why sometimes (subr name) and sometimes (subr (lambda...)) is
  generated.

