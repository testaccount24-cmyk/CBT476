
Macro: DEFMACRO

Syntax:   (DEFMACRO macro1 arglist2 &rest forms)

 macro1   (required, not evaluated) - a non-null symbol.
 arglist2 (required, not evaluated) - a lambda list.
 form     (not evaluated) - an atom or proper list.

Returns:

 macro1, after establishing a macro definition for it in the current
 environment.

Processing:

 DEFMACRO is a macro that expands into a DEFUN that defines a macro.
 The syntax is as follows:

  (DEFMACRO macro-name (arg1 arg2 ... argn) form1 form2 ... formn)

 where:

  macro-name is the name of the macro being defined
  argn's     are symbols to be bound to the corresponding arguments
             on the macro call
  formn's    are forms to be evaluated when the macro is expanded,
             the last returning the macro expansion.

 For example, (DEFMACRO FOO (A B) `(CONS ,B ,A))

 is basically equivalent to:

              (DEFUN FOO MACRO (X) `(CONS ,(CADDR X) ,(CADR X)))

 except that the macro definition generated by DEFMACRO insures that
 the number of passed arguments is correct.

 DEFMACRO should be used to define macros when there must be a specific
 number of arguments on the macro call, including none.

 The &OPTIONAL and &REST keywords may be used as well, in the same way
 as they are used on the LAMBDA list of a function, for macros which
 accept a variable number of arguments.  In addition, destructuring of
 arguments is allowed, and default values and "supplied-p" variables for
 &OPTIONAL args are available.

 The single argument which is bound to the macro call is not accessible
 when DEFMACRO is used; if you wish to access this, you must use DEFUN
 to define your macro.

 In the interpretive environment, DEFMACRO places a LAMBDA-expression
 on the MACRO property of the symbol specified by the first argument.
 Some examples should illustrate:

  (DEFMACRO FOO (A B) (PRINT 'HI) (LIST 'CONS B A))

 makes a list functionally similar to

 (LAMBDA (G00001)
         (PRINT 'HI) (LIST 'CONS (CADDR G00001) (CADR G00001)))

 the value of FOO's MACRO property.

 Note that in a compiled program or function, DEFMACRO does not
 generate executable code to define the macro a la interpretive
 mode, but causes a macro to be made available to the compiler.
 For that reason, it can occur only at top level in compiled code.

 The use of NIL as the macro name is invalid.

Errors signalled:

 Invalid syntax (too few arguments, or invalid argument list).
 Errors detected by DEFUN (q.v.).

 The following errors are detected at macro call time by a macro
 created by DEFMACRO:

  Too few or too many arguments specified on macro call
  Invalid argument list syntax (misplaced &OPTIONAL or &REST)

Notes:

 To cause a macro to become defined at run time in a compiled program or
 function, it is necessary to use XDEFUN, XDEFMACRO or PUTPROP to place
 the function body (LAMBDA and all) on the symbol's property list under
 the MACRO property.  DEFMACRO's not at top level are not compilable.

 The Common LISP "destructuring" feature is supported in the
 argument list of DEFMACRO.  &OPTIONAL and &REST are supported as well.
 However, &WHOLE and &ENV are not supported at this time.

Examples:

 (DEFMACRO FIRST (A) (LIST 'CAR A))

   is equivalent to

 (DEFUN FIRST MACRO (X) (LIST 'CAR (CADR X)))

  and defines a function that returns the CAR of its one argument.

 (FIRST '(1 2 3))   ==>  1
 (FIRST)            signals a "too few arguments" error.
 (FIRST A B)        signals a "too many arguments" error.

