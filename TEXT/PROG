
Macro: PROG, PROG*

Syntax:   (PROG varlist1 &rest forms)
          (PROG* varlist1 &rest forms)

 The first argument (the local variable list) is required;
 at least one subsequent argument is required, but any number of
 arguments greater than one may be specified.

 varlist1 (not evaluated) - a (possibly empty) list of symbols or
                            variable-value pairs.
 form     (conditionally evaluated if a list) - a symbol or a list.

Returns:

 NIL, unless a RETURN (or RETURN-FROM NIL) is executed during evaluation
 of the forms within the PROG, in which case the value generated by the
 RETURN (or RETURN-FROM NIL) becomes the return value.

Processing:

 (1) The first argument is a list of variable bindings defining variable
     names local to the PROG.  Each is in one of the following forms:

      symbol   -  the variable named "symbol" is bound to NIL
      (symbol form)  - the variable named "symbol" is bound to the value
                       obtained by evaluating "form".  The environment
                       in which "form" is evaluated depends on whether
                       PROG or PROG* is being used - see below.

      In either case, a destructuring template may be substituted for
      "symbol", in which case the initial value is destructured.
      See LET or DESETQ for more information on destructuring.

     The variables become unbound when the PROG is terminated.

     SETQ may be used to assign values to these variables
     within the PROG.

 (2) Declarations may optionally follow the argument list, and are
     processed if present.  Declarations may affect the variables
     specified in the argument list.

 (3) The rest of the forms in the PROG constitute the body of the
     PROG, and are processed in succession, as follows:

     (a) If the form is NIL, it is ignored.

     (b) If the form is a symbol, it is not evaluated, but kept
         as a tag which a GO form can branch to.

     (c) If the form is an integer, it is not evaluated, but kept
         as a tag which a GO form can branch to.  In other words,
         integers can be used as GO tags much as symbols can, for
         compatibility with Maclisp.

     (d) If the form is a list, it is evaluated.

     (e) It is an error if the form is not of one of the above types.

 (3) If the end of the PROG is reached, it is terminated and NIL is
     returned as its value.

 The above sequence can be altered by the execution of the special
 forms GO and RETURN if they are encountered during evaluation (see
 the GO and RETURN documentation for details).

 GO causes control to pass to the specified tag (symbol or integer) in
 the PROG body.  The form following the tag becomes the next form to
 be evaluated, and processing continues from there.

 RETURN causes evaluation of its argument and exit from the PROG using
 that value as the return value.  If no RETURN statement is executed,
 the PROG will either loop infinitely (until an error occurs) or
 return NIL when the end of the body is reached.

 Since a BLOCK named NIL is built by the PROG, it is also possible to
 use the form (RETURN-FROM NIL ...) to return a value from the PROG in
 the same way as (RETURN ...).  See BLOCK and RETURN-FROM (member
 RETURNFR of this documentation) for more information.

 PROG* is the same as PROG, except that PROG binds its variables
 sequentially whereas PROG* does parallel binding.

 In other words:

 PROG binds each variable in the environment present outside of the
 PROG.

 PROG* binds each variable in the environment present immediately before
 the variable-value pair, so that each binding can refer to previous
 (but not subsequent) PROG variables.

Errors signaled:

 Invalid syntax (missing argument list or body, arg1 not a list).

Notes:

 PROG used to be a special form, but is now a macro which expands into
 a LET, BLOCK and TAGBODY.  PROG* is identical to PROG except that it
 expands into LET* instead of LET.

 GO and RETURN are valid as long as they are lexically apparent in
 the code.  This means that they will be processed as long as they
 are not the product of function evaluation.  The following are
 valid occurrences of GO and RETURN:

 (PROG (A B C) LOOP (DO 'SOMETHING) (GO LOOP) (RETURN T))
 (PROG (A B C) (COND ((EQ A T) (GO LOOP)))
               LOOP (PROG2 (PRINT A) (RETURN B)))

 The following is NOT valid:

 (DEFUN SUMFUNK () (GO LAB))
 (PROG (A) LAB (COND ((NULL A) (RETURN T))) (SUMFUNK))

 A "GO outside of PROG" error will be signalled.

 See members GO and RETURN for more information on restrictions
 pertaining to GO and RETURN, particularly those which involve
 functionality available under the interpreter but not (as yet)
 in compiled code.

 The same applies to RETURN-FROM.

Examples:

 (PROG () (RETURN T))             ==> T
 (PROG () T)                      ==> NIL

 (PROG (A B)
       (SETQ A '(1 2 3 4))
  LOOP (COND ((NULL A) (RETURN B)))
       (SETQ B (CONS (ADD1 (CAR A)) B))
       (SETQ A (CDR A))
       (GO LOOP)
 )                                ==> (5 4 3 2)

 (PROG ((A '(1 2 3 4))
        (B '(5 6 7 8))
        (C NIL)
        (D NIL)
       )
       (SETQ C (CAR A))
       (SETQ D (CAR B))
       (RETURN (+ C D))
 )                         ==>  6

 (SETQ A "a")          ==> "a"
 (SETQ B "b")          ==> "b"

 (PROG  ((A (LIST A)) (B A)) (RETURN (LIST A B)))  ==>  (("a") "a")
 (PROG* ((A (LIST A)) (B A)) (RETURN (LIST A B)))  ==>  (("a") ("a"))

