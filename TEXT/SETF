
Function: SETF

Syntax:   (SETF arg1 arg2)

 arg1 (required, not evaluated) - a symbol or one of a special
                                  group of forms (see below).
 arg2 (required, evaluated) - any LISP object.

Returns:

 The second argument, after altering the value of the entity
 described by the form of the first argument.

Processing:

 SETF is a macro that expands into code to execute a function that
 alters or updates the value or other entity associated with a
 LISP object.  The following forms are recognized by SETF for the
 first argument:

 * A symbol - (SETF foo bar) is equivalent to (SETQ foo bar).

 * A form beginning with one of the following functions:

    CAR    - (SETF (CAR a) b)       like (RPLACA a b).
    CDR    - (SETF (CDR a) b)       like (RPLACD a b).
    PLIST  - (SETF (PLIST a) b)     like (SETPLIST a b).
    NTH    - (SETF (NTH a b) c)     like (RPLACA (NTHCDR a b) c)
    NTHCDR - (SETF (NTHCDR a b) c)  like (RPLACD (NTHCDR (SUB1 a) b) c)
    VREF   - (SETF (VREF a b) c)    like (VSET a b c)
    ARG    - (SETF (ARG a) b)       like (SETARG a b)
    GET    - (SETF (GET a b) c)     like (PUTPROP a c b)
    ALIST  - (SETF (ALIST) a)       like (SETALIST a)

    (The CA---R and CD---R functions expand similarly to CAR and CDR.)

 * A form whose CAR is a symbol with a SETFMETHOD property.

 * A macro call that expands to one of the above.

 The generated code is "like" the above examples, but not always
 exactly equivalent, because:

   (1) SETF always returns the second argument as its value.

   (2) SETF guarantees that the values indicated by a, b, and c are
       evaluated exactly once and in the order in which they appear
       on the SETF macro.

Errors signalled:

 Invalid syntax (SETF requires exactly two arguments).

 Unsupported SETF form (not one of the above) for the first argument.

 Invalid syntax for the first form (must match the typical syntax
 of the function); e.g. (SETF (CAR A B) C) is an error.

Notes:

 SETF is not sensitive to user-defined macros under the compiler
 unless the macros are defined to the execution-time component of
 the compiler using %.  For example:

  (DEFMACRO MYMACRO (X) `(CAR ,X))

 In order to be able to compile the form (SETF (MYMACRO 'FOO) 'BAR)
 you must code in addition to the above:

  (EVAL-WHEN (COMPILE)
    (DEFMACRO MYMACRO (X) `(CAR ,X))
  )

 Or, you can combine both into one form as follows:

  (EVAL-WHEN (COMPILE LOAD)
    (DEFMACRO MYMACRO (X) `(CAR ,X))
  )

 so that the SETF macro expander, when invoked by the compiler,
 will recognize MYMACRO as a macro in its own environment; the
 first DEFMACRO enables the compiler to expand direct macro calls
 to MYMACRO only.

 In the case of NTHCDR, SETF will generate a SETQ if the first
 argument to NTHCDR is zero.  In many other cases, SETF may
 generate code that is in error, but will not necessarily be
 signalled as an error.  Use SETF with caution.

 Since the code generated by SETF usually involves destructive
 or environment-altering functions, all the basic caveats apply.
 SETF should not be used on an in-line compiled list, i.e. a list
 derived from compiling the construct (QUOTE (form1 form2 ...)).
 This may cause further references to the in-line constant list
 to be incorrect.

 It is the intention of the ZIL development group to add support
 for new forms to SETF as time goes by.

 Alternatively, you may make SETF recognize a form by placing a
 function of 2 arguments on the SETFMETHOD property of a function
 name to be known to SETF; this function will return the macro
 expansion to be evaluated.  The arguments will be the first and
 second arguments on the SETF call itself.

Examples:

 (SETF A '(FOO BAR))    ==>   (FOO BAR)
 A                      ==>   (FOO BAR)
 (SETF (CAR A) 'BAZ)    ==>   BAZ
 A                      ==>   (BAZ BAR)
 (SETF (CDR A) 'FROB)   ==>   FROB
 A                      ==>   (BAZ . FROB)

 (SETF (PLIST 'ATTR) '(TYPE INPUT CAPS OFF JUST LEFT))
                              ==>   (TYPE INPUT CAPS OFF JUST LEFT)
 (PLIST 'ATTR)                ==>   (TYPE INPUT CAPS OFF JUST LEFT)
 (GET 'ATTR 'CAPS)            ==>   OFF
 (SETF (GET 'ATTR 'CAPS) 'ON) ==>   ON
 (GET 'ATTR 'CAPS)            ==>   ON
 (PLIST 'ATTR)                ==>   (TYPE INPUT CAPS ON JUST LEFT)

